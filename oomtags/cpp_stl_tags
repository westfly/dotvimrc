!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CAlloc	stl_rope.h	/^    	typedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;$/;"	t	class:rope	access:protected
CAlloc	stl_rope.h	/^    typedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;$/;"	t	struct:__rope_RopeBase	access:public
DEFALLOC_H	defalloc.h	26;"	d
DataAlloc	stl_rope.h	/^    	typedef simple_alloc<charT, Alloc> DataAlloc;$/;"	t	class:rope	access:protected
DataAlloc	stl_rope.h	/^    typedef simple_alloc<charT, Alloc> DataAlloc;$/;"	t	struct:__rope_RopeBase	access:public
FAlloc	stl_rope.h	/^    	typedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;$/;"	t	class:rope	access:protected
FAlloc	stl_rope.h	/^    typedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;$/;"	t	struct:__rope_RopeBase	access:public
FREELIST_INDEX	stl_alloc.h	/^  static  size_t FREELIST_INDEX(size_t bytes) {$/;"	f	class:__default_alloc_template	access:private	signature:(size_t bytes)
LAlloc	stl_rope.h	/^    	typedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;$/;"	t	class:rope	access:protected
LAlloc	stl_rope.h	/^    typedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;$/;"	t	struct:__rope_RopeBase	access:public
ROUND_UP	stl_alloc.h	/^  static size_t ROUND_UP(size_t bytes) {$/;"	f	class:__default_alloc_template	access:private	signature:(size_t bytes)
RopeBase	stl_rope.h	/^	typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:rope	access:protected
RopeBase	stl_rope.h	/^    typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:__rope_charT_ref_proxy	access:private
RopeBase	stl_rope.h	/^    typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:__rope_iterator_base	access:public
RopeConcatenation	stl_rope.h	/^	typedef __rope_RopeConcatenation<charT,Alloc> RopeConcatenation;$/;"	t	class:rope	access:protected
RopeFunction	stl_rope.h	/^	typedef __rope_RopeFunction<charT,Alloc> RopeFunction;$/;"	t	class:rope	access:protected
RopeFunction_from_fn	ropeimpl.h	/^rope<charT,Alloc>::RopeFunction_from_fn$/;"	f	class:rope	signature:(char_producer<charT> *fn, size_t size, bool delete_fn)
RopeFunction_from_fn	stl_rope.h	/^	static RopeFunction * RopeFunction_from_fn$/;"	p	class:rope	access:protected	signature:(char_producer<charT> *fn, size_t size, bool delete_fn)
RopeLeaf	stl_rope.h	/^	typedef __rope_RopeLeaf<charT,Alloc> RopeLeaf;$/;"	t	class:rope	access:protected
RopeLeaf_from_char_ptr	ropeimpl.h	/^rope<charT,Alloc>::RopeLeaf_from_char_ptr(__GC_CONST charT *s, size_t size)$/;"	f	class:rope	signature:(__GC_CONST charT *s, size_t size)
RopeLeaf_from_char_ptr	stl_rope.h	/^	static RopeLeaf * RopeLeaf_from_char_ptr(__GC_CONST charT *s,$/;"	p	class:rope	access:protected	signature:(__GC_CONST charT *s, size_t size)
RopeLeaf_from_unowned_char_ptr	stl_rope.h	/^	static RopeLeaf * RopeLeaf_from_unowned_char_ptr(const charT *s,$/;"	f	class:rope	access:protected	signature:(const charT *s, size_t size)
RopeSubstring	stl_rope.h	/^	typedef __rope_RopeSubstring<charT,Alloc> RopeSubstring;$/;"	t	class:rope	access:protected
S	stl_function.h	/^  explicit const_mem_fun1_ref_t(S (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_ref_t	access:public	signature:(T::*pf) const
S	stl_function.h	/^  explicit const_mem_fun1_t(S (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_t	access:public	signature:(T::*pf) const
S	stl_function.h	/^  explicit const_mem_fun_ref_t(S (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_ref_t	access:public	signature:(T::*pf) const
S	stl_function.h	/^  explicit const_mem_fun_t(S (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_t	access:public	signature:(T::*pf) const
S	stl_function.h	/^  explicit mem_fun1_ref_t(S (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_ref_t	access:public	signature:(T::*pf)
S	stl_function.h	/^  explicit mem_fun1_t(S (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_t	access:public	signature:(T::*pf)
S	stl_function.h	/^  explicit mem_fun_ref_t(S (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_ref_t	access:public	signature:(T::*pf)
S	stl_function.h	/^  explicit mem_fun_t(S (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_t	access:public	signature:(T::*pf)
S	stl_function.h	/^inline const_mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A) const) {$/;"	f	signature:(T::*f) const
S	stl_function.h	/^inline const_mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A) const) {$/;"	f	signature:(T::*f) const
S	stl_function.h	/^inline const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const) {$/;"	f	signature:(T::*f) const
S	stl_function.h	/^inline const_mem_fun_t<S,T> mem_fun(S (T::*f)() const) {$/;"	f	signature:(T::*f) const
S	stl_function.h	/^inline mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A)) { $/;"	f	signature:(T::*f)
S	stl_function.h	/^inline mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A)) { $/;"	f	signature:(T::*f)
S	stl_function.h	/^inline mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)()) { $/;"	f	signature:(T::*f)
S	stl_function.h	/^inline mem_fun_t<S,T> mem_fun(S (T::*f)()) { $/;"	f	signature:(T::*f)
SAlloc	stl_rope.h	/^    	typedef simple_alloc<__rope_RopeSubstring<charT,Alloc>, Alloc> SAlloc;$/;"	t	class:rope	access:protected
SAlloc	stl_rope.h	/^    typedef simple_alloc<__rope_RopeSubstring<charT,Alloc>, Alloc> SAlloc;$/;"	t	struct:__rope_RopeBase	access:public
_NOTHREADS	stl_alloc.h	66;"	d
__ALIGN	stl_alloc.h	/^    enum {__ALIGN = 8};$/;"	e	enum:__default_alloc_template::__anon5
__ALIGN	stl_alloc.h	/^  enum {__ALIGN = 8};$/;"	e	enum:__anon2
__ALLOC	stl_alloc.h	50;"	d
__ALLOC_PAUSE	stl_alloc.h	605;"	d
__BVECTOR	stl_bvector.h	/^  __BVECTOR() : start(iterator()), finish(iterator()), end_of_storage(0) {}$/;"	f	class:vector	access:public	signature:()
__BVECTOR	stl_bvector.h	/^  __BVECTOR(InputIterator first, InputIterator last) {$/;"	f	class:vector	access:public	signature:(InputIterator first, InputIterator last)
__BVECTOR	stl_bvector.h	/^  __BVECTOR(const __BVECTOR& x) {$/;"	f	class:vector	access:public	signature:(const __BVECTOR& x)
__BVECTOR	stl_bvector.h	/^  __BVECTOR(const bool* first, const bool* last) {$/;"	f	class:vector	access:public	signature:(const bool* first, const bool* last)
__BVECTOR	stl_bvector.h	/^  __BVECTOR(const_iterator first, const_iterator last) {$/;"	f	class:vector	access:public	signature:(const_iterator first, const_iterator last)
__BVECTOR	stl_bvector.h	/^  __BVECTOR(int n, bool value) {$/;"	f	class:vector	access:public	signature:(int n, bool value)
__BVECTOR	stl_bvector.h	/^  __BVECTOR(long n, bool value) {$/;"	f	class:vector	access:public	signature:(long n, bool value)
__BVECTOR	stl_bvector.h	/^  __BVECTOR(size_type n, bool value) {$/;"	f	class:vector	access:public	signature:(size_type n, bool value)
__BVECTOR	stl_bvector.h	/^  explicit __BVECTOR(size_type n) {$/;"	f	class:vector	access:public	signature:(size_type n)
__BVECTOR	stl_bvector.h	247;"	d
__BVECTOR	stl_bvector.h	250;"	d
__BVECTOR	stl_bvector.h	604;"	d
__GC_CONST	stl_rope.h	22;"	d
__GC_CONST	stl_rope.h	24;"	d
__MAX_BYTES	stl_alloc.h	/^    enum {__MAX_BYTES = 128};$/;"	e	enum:__default_alloc_template::__anon6
__MAX_BYTES	stl_alloc.h	/^  enum {__MAX_BYTES = 128};$/;"	e	enum:__anon3
__NFREELISTS	stl_alloc.h	/^    enum {__NFREELISTS = __MAX_BYTES\/__ALIGN};$/;"	e	enum:__default_alloc_template::__anon7
__NFREELISTS	stl_alloc.h	/^  enum {__NFREELISTS = __MAX_BYTES\/__ALIGN};$/;"	e	enum:__anon4
__NODE_ALLOCATOR_LOCK	stl_alloc.h	102;"	d
__NODE_ALLOCATOR_LOCK	stl_alloc.h	111;"	d
__NODE_ALLOCATOR_LOCK	stl_alloc.h	74;"	d
__NODE_ALLOCATOR_LOCK	stl_alloc.h	84;"	d
__NODE_ALLOCATOR_THREADS	stl_alloc.h	106;"	d
__NODE_ALLOCATOR_THREADS	stl_alloc.h	113;"	d
__NODE_ALLOCATOR_THREADS	stl_alloc.h	78;"	d
__NODE_ALLOCATOR_THREADS	stl_alloc.h	88;"	d
__NODE_ALLOCATOR_UNLOCK	stl_alloc.h	104;"	d
__NODE_ALLOCATOR_UNLOCK	stl_alloc.h	112;"	d
__NODE_ALLOCATOR_UNLOCK	stl_alloc.h	76;"	d
__NODE_ALLOCATOR_UNLOCK	stl_alloc.h	86;"	d
__PRIVATE	stl_alloc.h	22;"	d
__PRIVATE	stl_alloc.h	26;"	d
__PRIVATE	stl_alloc.h	692;"	d
__RESTRICT	stl_alloc.h	61;"	d
__SGI_STL_ALGOBASE_H	algobase.h	27;"	d
__SGI_STL_ALGO_H	algo.h	28;"	d
__SGI_STL_ALLOC_H	alloc.h	15;"	d
__SGI_STL_BVECTOR_H	bvector.h	28;"	d
__SGI_STL_DEQUE_H	deque.h	28;"	d
__SGI_STL_FUNCTION_H	function.h	28;"	d
__SGI_STL_HASHTABLE_H	hashtable.h	32;"	d
__SGI_STL_HASH_FUN_H	stl_hash_fun.h	32;"	d
__SGI_STL_HASH_MAP_H	hash_map.h	28;"	d
__SGI_STL_HASH_SET_H	hash_set.h	28;"	d
__SGI_STL_HEAP_H	heap.h	27;"	d
__SGI_STL_INTERNAL_ALGOBASE_H	stl_algobase.h	33;"	d
__SGI_STL_INTERNAL_ALGO_H	stl_algo.h	32;"	d
__SGI_STL_INTERNAL_ALLOC_H	stl_alloc.h	19;"	d
__SGI_STL_INTERNAL_BVECTOR_H	stl_bvector.h	32;"	d
__SGI_STL_INTERNAL_CONSTRUCT_H	stl_construct.h	32;"	d
__SGI_STL_INTERNAL_DEQUE_H	stl_deque.h	32;"	d
__SGI_STL_INTERNAL_FUNCTION_H	stl_function.h	32;"	d
__SGI_STL_INTERNAL_HASHTABLE_H	stl_hashtable.h	32;"	d
__SGI_STL_INTERNAL_HASH_MAP_H	stl_hash_map.h	32;"	d
__SGI_STL_INTERNAL_HASH_SET_H	stl_hash_set.h	32;"	d
__SGI_STL_INTERNAL_HEAP_H	stl_heap.h	31;"	d
__SGI_STL_INTERNAL_ITERATOR_H	stl_iterator.h	32;"	d
__SGI_STL_INTERNAL_LIST_H	stl_list.h	32;"	d
__SGI_STL_INTERNAL_MAP_H	stl_map.h	32;"	d
__SGI_STL_INTERNAL_MULTIMAP_H	stl_multimap.h	32;"	d
__SGI_STL_INTERNAL_MULTISET_H	stl_multiset.h	32;"	d
__SGI_STL_INTERNAL_NUMERIC_H	stl_numeric.h	33;"	d
__SGI_STL_INTERNAL_PAIR_H	stl_pair.h	32;"	d
__SGI_STL_INTERNAL_QUEUE_H	stl_queue.h	32;"	d
__SGI_STL_INTERNAL_RAW_STORAGE_ITERATOR_H	stl_raw_storage_iter.h	32;"	d
__SGI_STL_INTERNAL_RELOPS	stl_relops.h	32;"	d
__SGI_STL_INTERNAL_ROPE_H	stl_rope.h	19;"	d
__SGI_STL_INTERNAL_SET_H	stl_set.h	32;"	d
__SGI_STL_INTERNAL_SLIST_H	stl_slist.h	20;"	d
__SGI_STL_INTERNAL_STACK_H	stl_stack.h	32;"	d
__SGI_STL_INTERNAL_TEMPBUF_H	stl_tempbuf.h	32;"	d
__SGI_STL_INTERNAL_TREE_H	stl_tree.h	34;"	d
__SGI_STL_INTERNAL_UNINITIALIZED_H	stl_uninitialized.h	32;"	d
__SGI_STL_INTERNAL_VECTOR_H	stl_vector.h	32;"	d
__SGI_STL_ITERATOR_H	iterator.h	28;"	d
__SGI_STL_LIST_H	list.h	28;"	d
__SGI_STL_MAP_H	map.h	28;"	d
__SGI_STL_MULTIMAP_H	multimap.h	28;"	d
__SGI_STL_MULTISET_H	multiset.h	28;"	d
__SGI_STL_NO_ARROW_OPERATOR	stl_config.h	146;"	d
__SGI_STL_NO_ARROW_OPERATOR	stl_config.h	159;"	d
__SGI_STL_PAIR_H	pair.h	28;"	d
__SGI_STL_PTHREAD_ALLOC_H	pthread_alloc.h	15;"	d
__SGI_STL_ROPE_H	rope.h	15;"	d
__SGI_STL_SET_H	set.h	28;"	d
__SGI_STL_SLIST_H	slist.h	16;"	d
__SGI_STL_STACK_H	stack.h	28;"	d
__SGI_STL_TEMPBUF_H	tempbuf.h	28;"	d
__SGI_STL_TREE_H	tree.h	30;"	d
__SGI_STL_VECBOOL_TEMPLATE	stl_bvector.h	246;"	d
__SGI_STL_VECBOOL_TEMPLATE	stl_bvector.h	249;"	d
__SGI_STL_VECBOOL_TEMPLATE	stl_bvector.h	603;"	d
__SGI_STL_VECTOR_H	vector.h	28;"	d
__STD	stl_config.h	199;"	d
__STD	stl_config.h	207;"	d
__STD_RELOPS	stl_config.h	205;"	d
__STD_RELOPS	stl_config.h	213;"	d
__STL_BEGIN_NAMESPACE	stl_config.h	200;"	d
__STL_BEGIN_NAMESPACE	stl_config.h	208;"	d
__STL_BEGIN_RELOPS_NAMESPACE	stl_config.h	203;"	d
__STL_BEGIN_RELOPS_NAMESPACE	stl_config.h	211;"	d
__STL_CATCH_ALL	stl_config.h	218;"	d
__STL_CATCH_ALL	stl_config.h	224;"	d
__STL_CLASS_PARTIAL_SPECIALIZATION	stl_config.h	110;"	d
__STL_CLASS_PARTIAL_SPECIALIZATION	stl_config.h	129;"	d
__STL_CLASS_PARTIAL_SPECIALIZATION	stl_config.h	82;"	d
__STL_CONFIG_H	stl_config.h	28;"	d
__STL_END_NAMESPACE	stl_config.h	201;"	d
__STL_END_NAMESPACE	stl_config.h	209;"	d
__STL_END_RELOPS_NAMESPACE	stl_config.h	204;"	d
__STL_END_RELOPS_NAMESPACE	stl_config.h	212;"	d
__STL_EXPLICIT_FUNCTION_TMPL_ARGS	stl_config.h	112;"	d
__STL_FUNCTION_TMPL_PARTIAL_ORDER	stl_config.h	111;"	d
__STL_LIMITED_DEFAULT_TEMPLATES	stl_config.h	158;"	d
__STL_MEMBER_TEMPLATES	stl_config.h	113;"	d
__STL_MEMBER_TEMPLATES	stl_config.h	128;"	d
__STL_MEMBER_TEMPLATES	stl_config.h	85;"	d
__STL_NEED_BOOL	stl_config.h	121;"	d
__STL_NEED_BOOL	stl_config.h	138;"	d
__STL_NEED_BOOL	stl_config.h	76;"	d
__STL_NEED_EXPLICIT	stl_config.h	107;"	d
__STL_NEED_EXPLICIT	stl_config.h	123;"	d
__STL_NEED_EXPLICIT	stl_config.h	143;"	d
__STL_NEED_EXPLICIT	stl_config.h	88;"	d
__STL_NEED_TYPENAME	stl_config.h	106;"	d
__STL_NEED_TYPENAME	stl_config.h	122;"	d
__STL_NEED_TYPENAME	stl_config.h	141;"	d
__STL_NEED_TYPENAME	stl_config.h	157;"	d
__STL_NEED_TYPENAME	stl_config.h	79;"	d
__STL_NON_TYPE_TMPL_PARAM_BUG	stl_config.h	145;"	d
__STL_NON_TYPE_TMPL_PARAM_BUG	stl_config.h	160;"	d
__STL_NOTHROW	stl_config.h	220;"	d
__STL_NOTHROW	stl_config.h	226;"	d
__STL_NO_DRAND48	stl_config.h	140;"	d
__STL_NO_DRAND48	stl_config.h	156;"	d
__STL_NULL_TMPL_ARGS	stl_config.h	185;"	d
__STL_NULL_TMPL_ARGS	stl_config.h	187;"	d
__STL_NULL_TMPL_ARGS	stl_hash_map.h	/^  operator== __STL_NULL_TMPL_ARGS (const hash_map&, const hash_map&);$/;"	p	class:hash_map	access:friend	signature:(const hash_map&, const hash_map&)
__STL_NULL_TMPL_ARGS	stl_hash_map.h	/^  operator== __STL_NULL_TMPL_ARGS (const hash_multimap&, const hash_multimap&);$/;"	p	class:hash_multimap	access:friend	signature:(const hash_multimap&, const hash_multimap&)
__STL_NULL_TMPL_ARGS	stl_hash_set.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const hash_multiset&,$/;"	p	class:hash_multiset	access:friend	signature:(const hash_multiset&, const hash_multiset&)
__STL_NULL_TMPL_ARGS	stl_hash_set.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const hash_set&,$/;"	p	class:hash_set	access:friend	signature:(const hash_set&, const hash_set&)
__STL_NULL_TMPL_ARGS	stl_hashtable.h	/^  operator== __STL_NULL_TMPL_ARGS (const hashtable&, const hashtable&);$/;"	p	class:hashtable	access:friend	signature:(const hashtable&, const hashtable&)
__STL_NULL_TMPL_ARGS	stl_iterator.h	/^  operator== __STL_NULL_TMPL_ARGS (const istream_iterator<T, Distance>& x,$/;"	p	class:istream_iterator	access:friend	signature:(const istream_iterator<T, Distance>& x, const istream_iterator<T, Distance>& y)
__STL_NULL_TMPL_ARGS	stl_list.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const list& x, const list& y);$/;"	p	class:list	access:friend	signature:(const list& x, const list& y)
__STL_NULL_TMPL_ARGS	stl_map.h	/^  friend bool operator< __STL_NULL_TMPL_ARGS (const map&, const map&);$/;"	p	class:map	access:friend	signature:(const map&, const map&)
__STL_NULL_TMPL_ARGS	stl_map.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const map&, const map&);$/;"	p	class:map	access:friend	signature:(const map&, const map&)
__STL_NULL_TMPL_ARGS	stl_multimap.h	/^  friend bool operator< __STL_NULL_TMPL_ARGS (const multimap&,$/;"	p	class:multimap	access:friend	signature:(const multimap&, const multimap&)
__STL_NULL_TMPL_ARGS	stl_multimap.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const multimap&,$/;"	p	class:multimap	access:friend	signature:(const multimap&, const multimap&)
__STL_NULL_TMPL_ARGS	stl_multiset.h	/^  friend bool operator< __STL_NULL_TMPL_ARGS (const multiset&,$/;"	p	class:multiset	access:friend	signature:(const multiset&, const multiset&)
__STL_NULL_TMPL_ARGS	stl_multiset.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const multiset&,$/;"	p	class:multiset	access:friend	signature:(const multiset&, const multiset&)
__STL_NULL_TMPL_ARGS	stl_queue.h	/^  friend bool operator< __STL_NULL_TMPL_ARGS (const queue& x, const queue& y);$/;"	p	class:queue	access:friend	signature:(const queue& x, const queue& y)
__STL_NULL_TMPL_ARGS	stl_queue.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const queue& x, const queue& y);$/;"	p	class:queue	access:friend	signature:(const queue& x, const queue& y)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^        operator+ __STL_NULL_TMPL_ARGS (const rope<charT,Alloc> &left,$/;"	p	class:rope	access:friend	signature:(const rope<charT,Alloc> &left, charT right)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^        operator+ __STL_NULL_TMPL_ARGS (const rope<charT,Alloc> &left,$/;"	p	class:rope	access:friend	signature:(const rope<charT,Alloc> &left, const charT* right)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^        operator+ __STL_NULL_TMPL_ARGS (const rope<charT,Alloc> &left,$/;"	p	class:rope	access:friend	signature:(const rope<charT,Alloc> &left, const rope<charT,Alloc> &right)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend __rope_const_iterator<charT,Alloc> operator+ __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_const_iterator	access:friend	signature:(const __rope_const_iterator<charT,Alloc> & x, ptrdiff_t n)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend __rope_const_iterator<charT,Alloc> operator+ __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_const_iterator	access:friend	signature:(ptrdiff_t n, const __rope_const_iterator<charT,Alloc> & x)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend __rope_const_iterator<charT,Alloc> operator- __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_const_iterator	access:friend	signature:(const __rope_const_iterator<charT,Alloc> & x, ptrdiff_t n)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend __rope_iterator<charT,Alloc> operator+ __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_iterator	access:friend	signature:(const __rope_iterator<charT,Alloc> & x, ptrdiff_t n)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend __rope_iterator<charT,Alloc> operator+ __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_iterator	access:friend	signature:(ptrdiff_t n, const __rope_iterator<charT,Alloc> & x)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend __rope_iterator<charT,Alloc> operator- __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_iterator	access:friend	signature:(const __rope_iterator<charT,Alloc> & x, ptrdiff_t n)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend bool operator< __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_const_iterator	access:friend	signature:(const __rope_const_iterator<charT,Alloc> & x, const __rope_const_iterator<charT,Alloc> & y)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend bool operator< __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_iterator	access:friend	signature:(const __rope_iterator<charT,Alloc> & x, const __rope_iterator<charT,Alloc> & y)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend bool operator== __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_charT_ptr_proxy	access:friend	signature:(const __rope_charT_ptr_proxy<charT,Alloc> & x, const __rope_charT_ptr_proxy<charT,Alloc> & y)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend bool operator== __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_const_iterator	access:friend	signature:(const __rope_const_iterator<charT,Alloc> & x, const __rope_const_iterator<charT,Alloc> & y)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend bool operator== __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_iterator	access:friend	signature:(const __rope_iterator<charT,Alloc> & x, const __rope_iterator<charT,Alloc> & y)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend ptrdiff_t operator- __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_const_iterator	access:friend	signature:(const __rope_const_iterator<charT,Alloc> & x, const __rope_const_iterator<charT,Alloc> & y)
__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend ptrdiff_t operator- __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_iterator	access:friend	signature:(const __rope_iterator<charT,Alloc> & x, const __rope_iterator<charT,Alloc> & y)
__STL_NULL_TMPL_ARGS	stl_set.h	/^  friend bool operator< __STL_NULL_TMPL_ARGS (const set&, const set&);$/;"	p	class:set	access:friend	signature:(const set&, const set&)
__STL_NULL_TMPL_ARGS	stl_set.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const set&, const set&);$/;"	p	class:set	access:friend	signature:(const set&, const set&)
__STL_NULL_TMPL_ARGS	stl_slist.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS(const slist<T, Alloc>& L1,$/;"	p	class:slist	access:friend	signature:(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)
__STL_NULL_TMPL_ARGS	stl_stack.h	/^  friend bool operator< __STL_NULL_TMPL_ARGS (const stack&, const stack&);$/;"	p	class:stack	access:friend	signature:(const stack&, const stack&)
__STL_NULL_TMPL_ARGS	stl_stack.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const stack&, const stack&);$/;"	p	class:stack	access:friend	signature:(const stack&, const stack&)
__STL_RETHROW	stl_config.h	219;"	d
__STL_RETHROW	stl_config.h	225;"	d
__STL_SGI_THREADS	stl_config.h	97;"	d
__STL_STATIC_TEMPLATE_MEMBER_BUG	stl_config.h	103;"	d
__STL_TEMPLATE_NULL	stl_config.h	191;"	d
__STL_TEMPLATE_NULL	stl_config.h	193;"	d
__STL_TRY	stl_config.h	217;"	d
__STL_TRY	stl_config.h	223;"	d
__STL_UNWIND	stl_config.h	221;"	d
__STL_UNWIND	stl_config.h	227;"	d
__STL_USE_EXCEPTIONS	stl_config.h	116;"	d
__STL_USE_EXCEPTIONS	stl_config.h	124;"	d
__STL_USE_EXCEPTIONS	stl_config.h	130;"	d
__STL_USE_EXCEPTIONS	stl_config.h	148;"	d
__STL_USE_EXCEPTIONS	stl_config.h	162;"	d
__STL_USE_EXCEPTIONS	stl_config.h	91;"	d
__STL_USE_NAMESPACES	stl_config.h	131;"	d
__STL_USE_NAMESPACES	stl_config.h	94;"	d
__STL_USE_NAMESPACE_FOR_RELOPS	stl_config.h	202;"	d
__STL_USE_NAMESPACE_FOR_RELOPS	stl_config.h	210;"	d
__STL_WIN32THREADS	stl_config.h	151;"	d
__STL_WIN32THREADS	stl_config.h	165;"	d
__THROW_BAD_ALLOC	stl_alloc.h	46;"	d
__TYPEDEF_WORKAROUND	stl_rope.h	97;"	d
__TYPE_TRAITS_H	type_traits.h	16;"	d
__USE_MALLOC	stl_alloc.h	30;"	d
__VOLATILE	stl_alloc.h	107;"	d
__VOLATILE	stl_alloc.h	114;"	d
__VOLATILE	stl_alloc.h	79;"	d
__VOLATILE	stl_alloc.h	89;"	d
__WORD_BIT	stl_bvector.h	/^static const int __WORD_BIT = int(CHAR_BIT*sizeof(unsigned int));$/;"	v
__add_and_fetch	stl_rope.h	288;"	d
__adjacent_difference	stl_numeric.h	/^OutputIterator __adjacent_difference(InputIterator first, InputIterator last, $/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, T*)
__adjacent_difference	stl_numeric.h	/^OutputIterator __adjacent_difference(InputIterator first, InputIterator last, $/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, T*, BinaryOperation binary_op)
__adjust_heap	stl_heap.h	/^void __adjust_heap(RandomAccessIterator first, Distance holeIndex,$/;"	f	signature:(RandomAccessIterator first, Distance holeIndex, Distance len, T value)
__adjust_heap	stl_heap.h	/^void __adjust_heap(RandomAccessIterator first, Distance holeIndex,$/;"	f	signature:(RandomAccessIterator first, Distance holeIndex, Distance len, T value, Compare comp)
__advance	stl_iterator.h	/^inline void __advance(BidirectionalIterator& i, Distance n, $/;"	f	signature:(BidirectionalIterator& i, Distance n, bidirectional_iterator_tag)
__advance	stl_iterator.h	/^inline void __advance(InputIterator& i, Distance n, input_iterator_tag) {$/;"	f	signature:(InputIterator& i, Distance n, input_iterator_tag)
__advance	stl_iterator.h	/^inline void __advance(RandomAccessIterator& i, Distance n, $/;"	f	signature:(RandomAccessIterator& i, Distance n, random_access_iterator_tag)
__bit_const_iterator	stl_bvector.h	/^  __bit_const_iterator() : p(0), offset(0) {}$/;"	f	struct:__bit_const_iterator	access:public	signature:()
__bit_const_iterator	stl_bvector.h	/^  __bit_const_iterator(const __bit_iterator& x) : p(x.p), offset(x.offset) {}$/;"	f	struct:__bit_const_iterator	access:public	signature:(const __bit_iterator& x)
__bit_const_iterator	stl_bvector.h	/^  __bit_const_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}$/;"	f	struct:__bit_const_iterator	access:public	signature:(unsigned int* x, unsigned int y)
__bit_const_iterator	stl_bvector.h	/^struct __bit_const_iterator$/;"	s	inherits:random_access_iterator
__bit_const_iterator::__bit_const_iterator	stl_bvector.h	/^  __bit_const_iterator() : p(0), offset(0) {}$/;"	f	struct:__bit_const_iterator	access:public	signature:()
__bit_const_iterator::__bit_const_iterator	stl_bvector.h	/^  __bit_const_iterator(const __bit_iterator& x) : p(x.p), offset(x.offset) {}$/;"	f	struct:__bit_const_iterator	access:public	signature:(const __bit_iterator& x)
__bit_const_iterator::__bit_const_iterator	stl_bvector.h	/^  __bit_const_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}$/;"	f	struct:__bit_const_iterator	access:public	signature:(unsigned int* x, unsigned int y)
__bit_const_iterator::bump_down	stl_bvector.h	/^  void bump_down() {$/;"	f	struct:__bit_const_iterator	access:public	signature:()
__bit_const_iterator::bump_up	stl_bvector.h	/^  void bump_up() {$/;"	f	struct:__bit_const_iterator	access:public	signature:()
__bit_const_iterator::const_iterator	stl_bvector.h	/^  typedef __bit_const_iterator const_iterator;$/;"	t	struct:__bit_const_iterator	access:public
__bit_const_iterator::const_reference	stl_bvector.h	/^  typedef bool                 const_reference;$/;"	t	struct:__bit_const_iterator	access:public
__bit_const_iterator::offset	stl_bvector.h	/^  unsigned int offset;$/;"	m	struct:__bit_const_iterator	access:public
__bit_const_iterator::operator !=	stl_bvector.h	/^  bool operator!=(const const_iterator& x) const {$/;"	f	struct:__bit_const_iterator	access:public	signature:(const const_iterator& x) const
__bit_const_iterator::operator *	stl_bvector.h	/^  const_reference operator*() const {$/;"	f	struct:__bit_const_iterator	access:public	signature:() const
__bit_const_iterator::operator +	stl_bvector.h	/^  const_iterator operator+(difference_type i) const {$/;"	f	struct:__bit_const_iterator	access:public	signature:(difference_type i) const
__bit_const_iterator::operator ++	stl_bvector.h	/^  const_iterator operator++(int) {$/;"	f	struct:__bit_const_iterator	access:public	signature:(int)
__bit_const_iterator::operator ++	stl_bvector.h	/^  const_iterator& operator++() {$/;"	f	struct:__bit_const_iterator	access:public	signature:()
__bit_const_iterator::operator +=	stl_bvector.h	/^  const_iterator& operator+=(difference_type i) {$/;"	f	struct:__bit_const_iterator	access:public	signature:(difference_type i)
__bit_const_iterator::operator -	stl_bvector.h	/^  const_iterator operator-(difference_type i) const {$/;"	f	struct:__bit_const_iterator	access:public	signature:(difference_type i) const
__bit_const_iterator::operator -	stl_bvector.h	/^  difference_type operator-(const_iterator x) const {$/;"	f	struct:__bit_const_iterator	access:public	signature:(const_iterator x) const
__bit_const_iterator::operator --	stl_bvector.h	/^  const_iterator operator--(int) {$/;"	f	struct:__bit_const_iterator	access:public	signature:(int)
__bit_const_iterator::operator --	stl_bvector.h	/^  const_iterator& operator--() {$/;"	f	struct:__bit_const_iterator	access:public	signature:()
__bit_const_iterator::operator -=	stl_bvector.h	/^  const_iterator& operator-=(difference_type i) {$/;"	f	struct:__bit_const_iterator	access:public	signature:(difference_type i)
__bit_const_iterator::operator <	stl_bvector.h	/^  bool operator<(const_iterator x) const {$/;"	f	struct:__bit_const_iterator	access:public	signature:(const_iterator x) const
__bit_const_iterator::operator ==	stl_bvector.h	/^  bool operator==(const const_iterator& x) const {$/;"	f	struct:__bit_const_iterator	access:public	signature:(const const_iterator& x) const
__bit_const_iterator::operator []	stl_bvector.h	/^  const_reference operator[](difference_type i) { $/;"	f	struct:__bit_const_iterator	access:public	signature:(difference_type i)
__bit_const_iterator::p	stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_const_iterator	access:public
__bit_const_iterator::pointer	stl_bvector.h	/^  typedef const bool*          pointer;$/;"	t	struct:__bit_const_iterator	access:public
__bit_const_iterator::reference	stl_bvector.h	/^  typedef bool                 reference;$/;"	t	struct:__bit_const_iterator	access:public
__bit_iterator	stl_bvector.h	/^  __bit_iterator() : p(0), offset(0) {}$/;"	f	struct:__bit_iterator	access:public	signature:()
__bit_iterator	stl_bvector.h	/^  __bit_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}$/;"	f	struct:__bit_iterator	access:public	signature:(unsigned int* x, unsigned int y)
__bit_iterator	stl_bvector.h	/^struct __bit_iterator : public random_access_iterator<bool, ptrdiff_t> {$/;"	s	inherits:random_access_iterator
__bit_iterator::__bit_iterator	stl_bvector.h	/^  __bit_iterator() : p(0), offset(0) {}$/;"	f	struct:__bit_iterator	access:public	signature:()
__bit_iterator::__bit_iterator	stl_bvector.h	/^  __bit_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}$/;"	f	struct:__bit_iterator	access:public	signature:(unsigned int* x, unsigned int y)
__bit_iterator::bump_down	stl_bvector.h	/^  void bump_down() {$/;"	f	struct:__bit_iterator	access:public	signature:()
__bit_iterator::bump_up	stl_bvector.h	/^  void bump_up() {$/;"	f	struct:__bit_iterator	access:public	signature:()
__bit_iterator::iterator	stl_bvector.h	/^  typedef __bit_iterator iterator;$/;"	t	struct:__bit_iterator	access:public
__bit_iterator::offset	stl_bvector.h	/^  unsigned int offset;$/;"	m	struct:__bit_iterator	access:public
__bit_iterator::operator !=	stl_bvector.h	/^  bool operator!=(const iterator& x) const {$/;"	f	struct:__bit_iterator	access:public	signature:(const iterator& x) const
__bit_iterator::operator *	stl_bvector.h	/^  reference operator*() const { return reference(p, 1U << offset); }$/;"	f	struct:__bit_iterator	access:public	signature:() const
__bit_iterator::operator +	stl_bvector.h	/^  iterator operator+(difference_type i) const {$/;"	f	struct:__bit_iterator	access:public	signature:(difference_type i) const
__bit_iterator::operator ++	stl_bvector.h	/^  iterator operator++(int) {$/;"	f	struct:__bit_iterator	access:public	signature:(int)
__bit_iterator::operator ++	stl_bvector.h	/^  iterator& operator++() {$/;"	f	struct:__bit_iterator	access:public	signature:()
__bit_iterator::operator +=	stl_bvector.h	/^  iterator& operator+=(difference_type i) {$/;"	f	struct:__bit_iterator	access:public	signature:(difference_type i)
__bit_iterator::operator -	stl_bvector.h	/^  difference_type operator-(iterator x) const {$/;"	f	struct:__bit_iterator	access:public	signature:(iterator x) const
__bit_iterator::operator -	stl_bvector.h	/^  iterator operator-(difference_type i) const {$/;"	f	struct:__bit_iterator	access:public	signature:(difference_type i) const
__bit_iterator::operator --	stl_bvector.h	/^  iterator operator--(int) {$/;"	f	struct:__bit_iterator	access:public	signature:(int)
__bit_iterator::operator --	stl_bvector.h	/^  iterator& operator--() {$/;"	f	struct:__bit_iterator	access:public	signature:()
__bit_iterator::operator -=	stl_bvector.h	/^  iterator& operator-=(difference_type i) {$/;"	f	struct:__bit_iterator	access:public	signature:(difference_type i)
__bit_iterator::operator <	stl_bvector.h	/^  bool operator<(iterator x) const {$/;"	f	struct:__bit_iterator	access:public	signature:(iterator x) const
__bit_iterator::operator ==	stl_bvector.h	/^  bool operator==(const iterator& x) const {$/;"	f	struct:__bit_iterator	access:public	signature:(const iterator& x) const
__bit_iterator::operator []	stl_bvector.h	/^  reference operator[](difference_type i) { return *(*this + i); }$/;"	f	struct:__bit_iterator	access:public	signature:(difference_type i)
__bit_iterator::p	stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_iterator	access:public
__bit_iterator::pointer	stl_bvector.h	/^  typedef __bit_reference* pointer;$/;"	t	struct:__bit_iterator	access:public
__bit_iterator::reference	stl_bvector.h	/^  typedef __bit_reference  reference;$/;"	t	struct:__bit_iterator	access:public
__bit_reference	stl_bvector.h	/^  __bit_reference() : p(0), mask(0) {}$/;"	f	struct:__bit_reference	access:public	signature:()
__bit_reference	stl_bvector.h	/^  __bit_reference(unsigned int* x, unsigned int y) : p(x), mask(y) {}$/;"	f	struct:__bit_reference	access:public	signature:(unsigned int* x, unsigned int y)
__bit_reference	stl_bvector.h	/^struct __bit_reference {$/;"	s
__bit_reference::__bit_reference	stl_bvector.h	/^  __bit_reference() : p(0), mask(0) {}$/;"	f	struct:__bit_reference	access:public	signature:()
__bit_reference::__bit_reference	stl_bvector.h	/^  __bit_reference(unsigned int* x, unsigned int y) : p(x), mask(y) {}$/;"	f	struct:__bit_reference	access:public	signature:(unsigned int* x, unsigned int y)
__bit_reference::flip	stl_bvector.h	/^  void flip() { *p ^= mask; }$/;"	f	struct:__bit_reference	access:public	signature:()
__bit_reference::mask	stl_bvector.h	/^  unsigned int mask;$/;"	m	struct:__bit_reference	access:public
__bit_reference::operator <	stl_bvector.h	/^  bool operator<(const __bit_reference& x) const {$/;"	f	struct:__bit_reference	access:public	signature:(const __bit_reference& x) const
__bit_reference::operator =	stl_bvector.h	/^  __bit_reference& operator=(bool x) {$/;"	f	struct:__bit_reference	access:public	signature:(bool x)
__bit_reference::operator =	stl_bvector.h	/^  __bit_reference& operator=(const __bit_reference& x) { return *this = bool(x); }$/;"	f	struct:__bit_reference	access:public	signature:(const __bit_reference& x)
__bit_reference::operator ==	stl_bvector.h	/^  bool operator==(const __bit_reference& x) const {$/;"	f	struct:__bit_reference	access:public	signature:(const __bit_reference& x) const
__bit_reference::operator bool	stl_bvector.h	/^  operator bool() const { return !(!(*p & mask)); }$/;"	f	struct:__bit_reference	access:public	signature:() const
__bit_reference::p	stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_reference	access:public
__black_count	stl_tree.h	/^inline int __black_count(__rb_tree_node_base* node, __rb_tree_node_base* root)$/;"	f	signature:(__rb_tree_node_base* node, __rb_tree_node_base* root)
__chunk_insertion_sort	stl_algo.h	/^void __chunk_insertion_sort(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Distance chunk_size)
__chunk_insertion_sort	stl_algo.h	/^void __chunk_insertion_sort(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Distance chunk_size, Compare comp)
__cond_store_eos	stl_rope.h	/^inline void __cond_store_eos(char& c) { c = 0; }$/;"	f	signature:(char& c)
__cond_store_eos	stl_rope.h	/^inline void __cond_store_eos(charT&) {}$/;"	f	signature:(charT&)
__cond_store_eos	stl_rope.h	/^inline void __cond_store_eos(wchar_t& c) { c = 0; }$/;"	f	signature:(wchar_t& c)
__copy	stl_algobase.h	/^__copy(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, OutputIterator result, random_access_iterator_tag)
__copy	stl_algobase.h	/^inline OutputIterator __copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, input_iterator_tag)
__copy	stl_tree.h	/^  link_type __copy(link_type x, link_type p);$/;"	p	class:rb_tree	access:private	signature:(link_type x, link_type p)
__copy	stl_tree.h	/^rb_tree<K, V, KeyOfValue, Compare, Alloc>::__copy(link_type x, link_type p) {$/;"	f	class:rb_tree	signature:(link_type x, link_type p)
__copy_backward	stl_algobase.h	/^inline BidirectionalIterator2 __copy_backward(BidirectionalIterator1 first, $/;"	f	signature:(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 result)
__copy_backward_dispatch	stl_algobase.h	/^struct __copy_backward_dispatch$/;"	s
__copy_backward_dispatch	stl_algobase.h	/^struct __copy_backward_dispatch<T*, T*>$/;"	s
__copy_backward_dispatch	stl_algobase.h	/^struct __copy_backward_dispatch<const T*, T*>$/;"	s
__copy_backward_dispatch::operator ()	stl_algobase.h	/^  BidirectionalIterator2 operator()(BidirectionalIterator1 first, $/;"	f	struct:__copy_backward_dispatch	access:public	signature:(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 result)
__copy_backward_dispatch::operator ()	stl_algobase.h	/^  T* operator()(T* first, T* last, T* result) {$/;"	f	struct:__copy_backward_dispatch	access:public	signature:(T* first, T* last, T* result)
__copy_backward_dispatch::operator ()	stl_algobase.h	/^  T* operator()(const T* first, const T* last, T* result) {$/;"	f	struct:__copy_backward_dispatch	access:public	signature:(const T* first, const T* last, T* result)
__copy_backward_t	stl_algobase.h	/^inline T* __copy_backward_t(const T* first, const T* last, T* result,$/;"	f	signature:(const T* first, const T* last, T* result, __false_type)
__copy_backward_t	stl_algobase.h	/^inline T* __copy_backward_t(const T* first, const T* last, T* result,$/;"	f	signature:(const T* first, const T* last, T* result, __true_type)
__copy_d	stl_algobase.h	/^__copy_d(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, OutputIterator result, Distance*)
__copy_dispatch	stl_algobase.h	/^struct __copy_dispatch$/;"	s
__copy_dispatch	stl_algobase.h	/^struct __copy_dispatch<T*, T*>$/;"	s
__copy_dispatch	stl_algobase.h	/^struct __copy_dispatch<const T*, T*>$/;"	s
__copy_dispatch::operator ()	stl_algobase.h	/^  OutputIterator operator()(InputIterator first, InputIterator last,$/;"	f	struct:__copy_dispatch	access:public	signature:(InputIterator first, InputIterator last, OutputIterator result)
__copy_dispatch::operator ()	stl_algobase.h	/^  T* operator()(T* first, T* last, T* result) {$/;"	f	struct:__copy_dispatch	access:public	signature:(T* first, T* last, T* result)
__copy_dispatch::operator ()	stl_algobase.h	/^  T* operator()(const T* first, const T* last, T* result) {$/;"	f	struct:__copy_dispatch	access:public	signature:(const T* first, const T* last, T* result)
__copy_n	stl_algobase.h	/^__copy_n(RandomAccessIterator first, Size count,$/;"	f	signature:(RandomAccessIterator first, Size count, OutputIterator result, random_access_iterator_tag)
__copy_n	stl_algobase.h	/^pair<InputIterator, OutputIterator> __copy_n(InputIterator first, Size count,$/;"	f	signature:(InputIterator first, Size count, OutputIterator result, input_iterator_tag)
__copy_t	stl_algobase.h	/^inline T* __copy_t(const T* first, const T* last, T* result, __false_type) {$/;"	f	signature:(const T* first, const T* last, T* result, __false_type)
__copy_t	stl_algobase.h	/^inline T* __copy_t(const T* first, const T* last, T* result, __true_type) {$/;"	f	signature:(const T* first, const T* last, T* result, __true_type)
__default_alloc_template	stl_alloc.h	/^    __default_alloc_template() {$/;"	f	class:__default_alloc_template	access:public	signature:()
__default_alloc_template	stl_alloc.h	/^class __default_alloc_template {$/;"	c
__default_alloc_template::FREELIST_INDEX	stl_alloc.h	/^  static  size_t FREELIST_INDEX(size_t bytes) {$/;"	f	class:__default_alloc_template	access:private	signature:(size_t bytes)
__default_alloc_template::ROUND_UP	stl_alloc.h	/^  static size_t ROUND_UP(size_t bytes) {$/;"	f	class:__default_alloc_template	access:private	signature:(size_t bytes)
__default_alloc_template::__ALIGN	stl_alloc.h	/^    enum {__ALIGN = 8};$/;"	e	enum:__default_alloc_template::__anon5
__default_alloc_template::__MAX_BYTES	stl_alloc.h	/^    enum {__MAX_BYTES = 128};$/;"	e	enum:__default_alloc_template::__anon6
__default_alloc_template::__NFREELISTS	stl_alloc.h	/^    enum {__NFREELISTS = __MAX_BYTES\/__ALIGN};$/;"	e	enum:__default_alloc_template::__anon7
__default_alloc_template::__default_alloc_template	stl_alloc.h	/^    __default_alloc_template() {$/;"	f	class:__default_alloc_template	access:public	signature:()
__default_alloc_template::__lock	stl_alloc.h	/^    static void __lock(volatile unsigned long *); $/;"	p	class:__default_alloc_template	access:private	signature:(volatile unsigned long *)
__default_alloc_template::__lock	stl_alloc.h	/^__default_alloc_template<threads, inst>::__lock(volatile unsigned long *lock)$/;"	f	class:__default_alloc_template	signature:(volatile unsigned long *lock)
__default_alloc_template::__node_allocator_lock	stl_alloc.h	/^    __default_alloc_template<threads, inst>::__node_allocator_lock$/;"	m	class:__default_alloc_template
__default_alloc_template::__node_allocator_lock	stl_alloc.h	/^    __default_alloc_template<threads, inst>::__node_allocator_lock;$/;"	m	class:__default_alloc_template
__default_alloc_template::__node_allocator_lock	stl_alloc.h	/^    static CRITICAL_SECTION __node_allocator_lock;$/;"	m	class:__default_alloc_template	access:private
__default_alloc_template::__node_allocator_lock	stl_alloc.h	/^    static pthread_mutex_t __node_allocator_lock;$/;"	m	class:__default_alloc_template	access:private
__default_alloc_template::__node_allocator_lock	stl_alloc.h	/^    static volatile unsigned long __node_allocator_lock;$/;"	m	class:__default_alloc_template	access:private
__default_alloc_template::__node_allocator_lock	stl_alloc.h	/^__default_alloc_template<threads, inst>::__node_allocator_lock = 0;$/;"	m	class:__default_alloc_template
__default_alloc_template::__node_allocator_lock_initialized	stl_alloc.h	/^    __default_alloc_template<threads, inst>::__node_allocator_lock_initialized$/;"	m	class:__default_alloc_template
__default_alloc_template::__node_allocator_lock_initialized	stl_alloc.h	/^    static bool __node_allocator_lock_initialized;$/;"	m	class:__default_alloc_template	access:private
__default_alloc_template::__unlock	stl_alloc.h	/^    static inline void __unlock(volatile unsigned long *);$/;"	p	class:__default_alloc_template	access:private	signature:(volatile unsigned long *)
__default_alloc_template::__unlock	stl_alloc.h	/^__default_alloc_template<threads, inst>::__unlock(volatile unsigned long *lock)$/;"	f	class:__default_alloc_template	signature:(volatile unsigned long *lock)
__default_alloc_template::allocate	stl_alloc.h	/^  static void * allocate(size_t n)$/;"	f	class:__default_alloc_template	access:public	signature:(size_t n)
__default_alloc_template::chunk_alloc	stl_alloc.h	/^  static char *chunk_alloc(size_t size, int &nobjs);$/;"	p	class:__default_alloc_template	access:private	signature:(size_t size, int &nobjs)
__default_alloc_template::chunk_alloc	stl_alloc.h	/^__default_alloc_template<threads, inst>::chunk_alloc(size_t size, int& nobjs)$/;"	f	class:__default_alloc_template	signature:(size_t size, int& nobjs)
__default_alloc_template::deallocate	stl_alloc.h	/^  static void deallocate(void *p, size_t n)$/;"	f	class:__default_alloc_template	access:public	signature:(void *p, size_t n)
__default_alloc_template::end_free	stl_alloc.h	/^  static char *end_free;$/;"	m	class:__default_alloc_template	access:private
__default_alloc_template::end_free	stl_alloc.h	/^char *__default_alloc_template<threads, inst>::end_free = 0;$/;"	m	class:__default_alloc_template
__default_alloc_template::free_list	stl_alloc.h	/^    static obj * __VOLATILE free_list[]; $/;"	m	class:__default_alloc_template	access:private
__default_alloc_template::free_list	stl_alloc.h	/^    static obj * __VOLATILE free_list[__NFREELISTS]; $/;"	m	class:__default_alloc_template	access:private
__default_alloc_template::free_list	stl_alloc.h	/^__default_alloc_template<threads, inst> ::free_list[$/;"	m	class:__default_alloc_template
__default_alloc_template::heap_size	stl_alloc.h	/^  static size_t heap_size;$/;"	m	class:__default_alloc_template	access:private
__default_alloc_template::heap_size	stl_alloc.h	/^size_t __default_alloc_template<threads, inst>::heap_size = 0;$/;"	m	class:__default_alloc_template
__default_alloc_template::lock	stl_alloc.h	/^    class lock {$/;"	c	class:__default_alloc_template	access:private
__default_alloc_template::lock::lock	stl_alloc.h	/^            lock() { __NODE_ALLOCATOR_LOCK; }$/;"	f	class:__default_alloc_template::lock	access:public	signature:()
__default_alloc_template::lock::~lock	stl_alloc.h	/^            ~lock() { __NODE_ALLOCATOR_UNLOCK; }$/;"	f	class:__default_alloc_template::lock	access:public	signature:()
__default_alloc_template::obj	stl_alloc.h	/^  union obj {$/;"	u	class:__default_alloc_template	access:private
__default_alloc_template::obj::client_data	stl_alloc.h	/^        char client_data[1];    \/* The client sees this.        *\/$/;"	m	union:__default_alloc_template::obj	access:public
__default_alloc_template::obj::free_list_link	stl_alloc.h	/^        union obj * free_list_link;$/;"	m	union:__default_alloc_template::obj	typeref:union:__default_alloc_template::obj::obj	access:public
__default_alloc_template::reallocate	stl_alloc.h	/^  static void * reallocate(void *p, size_t old_sz, size_t new_sz);$/;"	p	class:__default_alloc_template	access:public	signature:(void *p, size_t old_sz, size_t new_sz)
__default_alloc_template::reallocate	stl_alloc.h	/^__default_alloc_template<threads, inst>::reallocate(void *p,$/;"	f	class:__default_alloc_template	signature:(void *p, size_t old_sz, size_t new_sz)
__default_alloc_template::refill	stl_alloc.h	/^  static void *refill(size_t n);$/;"	p	class:__default_alloc_template	access:private	signature:(size_t n)
__default_alloc_template::refill	stl_alloc.h	/^void* __default_alloc_template<threads, inst>::refill(size_t n)$/;"	f	class:__default_alloc_template	signature:(size_t n)
__default_alloc_template::start_free	stl_alloc.h	/^  static char *start_free;$/;"	m	class:__default_alloc_template	access:private
__default_alloc_template::start_free	stl_alloc.h	/^char *__default_alloc_template<threads, inst>::start_free = 0;$/;"	m	class:__default_alloc_template
__deque_buf_size	stl_deque.h	/^inline size_t __deque_buf_size(size_t n, size_t sz)$/;"	f	signature:(size_t n, size_t sz)
__deque_iterator	stl_deque.h	/^  __deque_iterator() : cur(0), first(0), last(0), node(0) {}$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:()
__deque_iterator	stl_deque.h	/^  __deque_iterator(T* x, map_pointer y) $/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(T* x, map_pointer y)
__deque_iterator	stl_deque.h	/^  __deque_iterator(const iterator& x)$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(const iterator& x)
__deque_iterator	stl_deque.h	/^struct __deque_iterator {$/;"	s
__deque_iterator	stl_deque.h	/^struct __deque_iterator {$/;"	s	struct:__deque_iterator	access:public
__deque_iterator::__deque_iterator	stl_deque.h	/^struct __deque_iterator {$/;"	s	struct:__deque_iterator	access:public
__deque_iterator::__deque_iterator::__deque_iterator	stl_deque.h	/^  __deque_iterator() : cur(0), first(0), last(0), node(0) {}$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:()
__deque_iterator::__deque_iterator::__deque_iterator	stl_deque.h	/^  __deque_iterator(T* x, map_pointer y) $/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(T* x, map_pointer y)
__deque_iterator::__deque_iterator::__deque_iterator	stl_deque.h	/^  __deque_iterator(const iterator& x)$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(const iterator& x)
__deque_iterator::__deque_iterator::buffer_size	stl_deque.h	/^  static size_t buffer_size() {return __deque_buf_size(0, sizeof(T)); }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:()
__deque_iterator::__deque_iterator::const_iterator	stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::__deque_iterator::cur	stl_deque.h	/^  T* cur;$/;"	m	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::__deque_iterator::difference_type	stl_deque.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::__deque_iterator::first	stl_deque.h	/^  T* first;$/;"	m	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::__deque_iterator::iterator	stl_deque.h	/^  typedef __deque_iterator<T, T&, T*>             iterator;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::__deque_iterator::iterator_category	stl_deque.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::__deque_iterator::last	stl_deque.h	/^  T* last;$/;"	m	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::__deque_iterator::map_pointer	stl_deque.h	/^  typedef T** map_pointer;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::__deque_iterator::node	stl_deque.h	/^  map_pointer node;$/;"	m	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::__deque_iterator::operator !=	stl_deque.h	/^  bool operator!=(const self& x) const { return !(*this == x); }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(const self& x) const
__deque_iterator::__deque_iterator::operator *	stl_deque.h	/^  reference operator*() const { return *cur; }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:() const
__deque_iterator::__deque_iterator::operator +	stl_deque.h	/^  self operator+(difference_type n) const {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(difference_type n) const
__deque_iterator::__deque_iterator::operator ++	stl_deque.h	/^  self operator++(int)  {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(int)
__deque_iterator::__deque_iterator::operator ++	stl_deque.h	/^  self& operator++() {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:()
__deque_iterator::__deque_iterator::operator +=	stl_deque.h	/^  self& operator+=(difference_type n) {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(difference_type n)
__deque_iterator::__deque_iterator::operator -	stl_deque.h	/^  difference_type operator-(const self& x) const {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(const self& x) const
__deque_iterator::__deque_iterator::operator -	stl_deque.h	/^  self operator-(difference_type n) const {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(difference_type n) const
__deque_iterator::__deque_iterator::operator --	stl_deque.h	/^  self operator--(int) {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(int)
__deque_iterator::__deque_iterator::operator --	stl_deque.h	/^  self& operator--() {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:()
__deque_iterator::__deque_iterator::operator -=	stl_deque.h	/^  self& operator-=(difference_type n) { return *this += -n; }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(difference_type n)
__deque_iterator::__deque_iterator::operator ->	stl_deque.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:() const
__deque_iterator::__deque_iterator::operator <	stl_deque.h	/^  bool operator<(const self& x) const {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(const self& x) const
__deque_iterator::__deque_iterator::operator ==	stl_deque.h	/^  bool operator==(const self& x) const { return cur == x.cur; }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(const self& x) const
__deque_iterator::__deque_iterator::operator []	stl_deque.h	/^  reference operator[](difference_type n) const { return *(*this + n); }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(difference_type n) const
__deque_iterator::__deque_iterator::pointer	stl_deque.h	/^  typedef Ptr pointer;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::__deque_iterator::reference	stl_deque.h	/^  typedef Ref reference;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::__deque_iterator::self	stl_deque.h	/^  typedef __deque_iterator self;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::__deque_iterator::set_node	stl_deque.h	/^  void set_node(map_pointer new_node) {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(map_pointer new_node)
__deque_iterator::__deque_iterator::size_type	stl_deque.h	/^  typedef size_t size_type;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::__deque_iterator::value_type	stl_deque.h	/^  typedef T value_type;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
__deque_iterator::buffer_size	stl_deque.h	/^  static size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T)); }$/;"	f	struct:__deque_iterator	access:public	signature:()
__deque_iterator::const_iterator	stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T*, BufSiz> const_iterator;$/;"	t	struct:__deque_iterator	access:public
__deque_iterator::deque	stl_deque.h	/^class deque {$/;"	c	struct:__deque_iterator	access:public
__deque_iterator::deque::allocate_node	stl_deque.h	/^  pointer allocate_node() { return data_allocator::allocate(buffer_size()); }$/;"	f	class:__deque_iterator::deque	access:protected	signature:()
__deque_iterator::deque::back	stl_deque.h	/^  const_reference back() const {$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
__deque_iterator::deque::back	stl_deque.h	/^  reference back() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::begin	stl_deque.h	/^  const_iterator begin() const { return start; }$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
__deque_iterator::deque::begin	stl_deque.h	/^  iterator begin() { return start; }$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::buffer_size	stl_deque.h	/^  static size_type buffer_size() {$/;"	f	class:__deque_iterator::deque	access:protected	signature:()
__deque_iterator::deque::clear	stl_deque.h	/^  void clear(); $/;"	p	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::clear	stl_deque.h	/^void deque<T, Alloc, BufSize>::clear() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::const_iterator	stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T&, BufSiz>  const_iterator;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::const_iterator	stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T*>          const_iterator;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::const_pointer	stl_deque.h	/^  typedef const value_type* const_pointer;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::const_reference	stl_deque.h	/^  typedef const value_type& const_reference;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::const_reverse_iterator	stl_deque.h	/^          const_reverse_iterator;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::const_reverse_iterator	stl_deque.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::create_map_and_nodes	stl_deque.h	/^  void create_map_and_nodes(size_type num_elements);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(size_type num_elements)
__deque_iterator::deque::create_map_and_nodes	stl_deque.h	/^void deque<T, Alloc, BufSize>::create_map_and_nodes(size_type num_elements) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type num_elements)
__deque_iterator::deque::data_allocator	stl_deque.h	/^  typedef simple_alloc<value_type, Alloc> data_allocator;$/;"	t	class:__deque_iterator::deque	access:protected
__deque_iterator::deque::deallocate_node	stl_deque.h	/^  void deallocate_node(pointer n) {$/;"	f	class:__deque_iterator::deque	access:protected	signature:(pointer n)
__deque_iterator::deque::deque	stl_deque.h	/^  deque()$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::deque	stl_deque.h	/^  deque(InputIterator first, InputIterator last)$/;"	f	class:__deque_iterator::deque	access:public	signature:(InputIterator first, InputIterator last)
__deque_iterator::deque::deque	stl_deque.h	/^  deque(const deque& x)$/;"	f	class:__deque_iterator::deque	access:public	signature:(const deque& x)
__deque_iterator::deque::deque	stl_deque.h	/^  deque(const value_type* first, const value_type* last)$/;"	f	class:__deque_iterator::deque	access:public	signature:(const value_type* first, const value_type* last)
__deque_iterator::deque::deque	stl_deque.h	/^  deque(const_iterator first, const_iterator last)$/;"	f	class:__deque_iterator::deque	access:public	signature:(const_iterator first, const_iterator last)
__deque_iterator::deque::deque	stl_deque.h	/^  deque(int n, const value_type& value)$/;"	f	class:__deque_iterator::deque	access:public	signature:(int n, const value_type& value)
__deque_iterator::deque::deque	stl_deque.h	/^  deque(long n, const value_type& value)$/;"	f	class:__deque_iterator::deque	access:public	signature:(long n, const value_type& value)
__deque_iterator::deque::deque	stl_deque.h	/^  deque(size_type n, const value_type& value)$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type n, const value_type& value)
__deque_iterator::deque::deque	stl_deque.h	/^  explicit deque(size_type n)$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type n)
__deque_iterator::deque::destroy_map_and_nodes	stl_deque.h	/^  void destroy_map_and_nodes();$/;"	p	class:__deque_iterator::deque	access:protected	signature:()
__deque_iterator::deque::destroy_map_and_nodes	stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_map_and_nodes() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::destroy_nodes_at_back	stl_deque.h	/^  void destroy_nodes_at_back(iterator after_finish);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator after_finish)
__deque_iterator::deque::destroy_nodes_at_back	stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_nodes_at_back(iterator after_finish) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator after_finish)
__deque_iterator::deque::destroy_nodes_at_front	stl_deque.h	/^  void destroy_nodes_at_front(iterator before_start);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator before_start)
__deque_iterator::deque::destroy_nodes_at_front	stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_nodes_at_front(iterator before_start) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator before_start)
__deque_iterator::deque::difference_type	stl_deque.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::empty	stl_deque.h	/^  bool empty() const { return finish == start; }$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
__deque_iterator::deque::end	stl_deque.h	/^  const_iterator end() const { return finish; }$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
__deque_iterator::deque::end	stl_deque.h	/^  iterator end() { return finish; }$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::erase	stl_deque.h	/^  iterator erase(iterator first, iterator last);$/;"	p	class:__deque_iterator::deque	access:public	signature:(iterator first, iterator last)
__deque_iterator::deque::erase	stl_deque.h	/^  iterator erase(iterator pos) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos)
__deque_iterator::deque::erase	stl_deque.h	/^deque<T, Alloc, BufSize>::erase(iterator first, iterator last) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator first, iterator last)
__deque_iterator::deque::fill_initialize	stl_deque.h	/^  void fill_initialize(size_type n, const value_type& value);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(size_type n, const value_type& value)
__deque_iterator::deque::fill_initialize	stl_deque.h	/^void deque<T, Alloc, BufSize>::fill_initialize(size_type n,$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type n, const value_type& value)
__deque_iterator::deque::finish	stl_deque.h	/^  iterator finish;$/;"	m	class:__deque_iterator::deque	access:protected
__deque_iterator::deque::front	stl_deque.h	/^  const_reference front() const { return *start; }$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
__deque_iterator::deque::front	stl_deque.h	/^  reference front() { return *start; }$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::initial_map_size	stl_deque.h	/^  static size_type initial_map_size() { return 8; }$/;"	f	class:__deque_iterator::deque	access:protected	signature:()
__deque_iterator::deque::insert	stl_deque.h	/^  iterator insert(iterator position) { return insert(position, value_type()); }$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator position)
__deque_iterator::deque::insert	stl_deque.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator position, const value_type& x)
__deque_iterator::deque::insert	stl_deque.h	/^  void insert(iterator pos, ForwardIterator first, ForwardIterator last,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, ForwardIterator first, ForwardIterator last, forward_iterator_tag)
__deque_iterator::deque::insert	stl_deque.h	/^  void insert(iterator pos, InputIterator first, InputIterator last) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, InputIterator first, InputIterator last)
__deque_iterator::deque::insert	stl_deque.h	/^  void insert(iterator pos, InputIterator first, InputIterator last,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, InputIterator first, InputIterator last, input_iterator_tag)
__deque_iterator::deque::insert	stl_deque.h	/^  void insert(iterator pos, const value_type* first, const value_type* last);$/;"	p	class:__deque_iterator::deque	access:public	signature:(iterator pos, const value_type* first, const value_type* last)
__deque_iterator::deque::insert	stl_deque.h	/^  void insert(iterator pos, const_iterator first, const_iterator last);$/;"	p	class:__deque_iterator::deque	access:public	signature:(iterator pos, const_iterator first, const_iterator last)
__deque_iterator::deque::insert	stl_deque.h	/^  void insert(iterator pos, int n, const value_type& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, int n, const value_type& x)
__deque_iterator::deque::insert	stl_deque.h	/^  void insert(iterator pos, long n, const value_type& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, long n, const value_type& x)
__deque_iterator::deque::insert	stl_deque.h	/^  void insert(iterator pos, size_type n, const value_type& x); $/;"	p	class:__deque_iterator::deque	access:public	signature:(iterator pos, size_type n, const value_type& x)
__deque_iterator::deque::insert	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, ForwardIterator first, ForwardIterator last, forward_iterator_tag)
__deque_iterator::deque::insert	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, InputIterator first, InputIterator last, input_iterator_tag)
__deque_iterator::deque::insert	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, const value_type* first, const value_type* last)
__deque_iterator::deque::insert	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, const_iterator first, const_iterator last)
__deque_iterator::deque::insert	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, size_type n, const value_type& x)
__deque_iterator::deque::insert_aux	stl_deque.h	/^  iterator insert_aux(iterator pos, const value_type& x);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, const value_type& x)
__deque_iterator::deque::insert_aux	stl_deque.h	/^  void insert_aux(iterator pos, ForwardIterator first, ForwardIterator last,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, ForwardIterator first, ForwardIterator last, size_type n)
__deque_iterator::deque::insert_aux	stl_deque.h	/^  void insert_aux(iterator pos, const_iterator first, const_iterator last,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, const_iterator first, const_iterator last, size_type n)
__deque_iterator::deque::insert_aux	stl_deque.h	/^  void insert_aux(iterator pos, size_type n, const value_type& x);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, size_type n, const value_type& x)
__deque_iterator::deque::insert_aux	stl_deque.h	/^  void insert_aux(iterator pos,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, const value_type* first, const value_type* last, size_type n)
__deque_iterator::deque::insert_aux	stl_deque.h	/^deque<T, Alloc, BufSize>::insert_aux(iterator pos, const value_type& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, const value_type& x)
__deque_iterator::deque::insert_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert_aux(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, ForwardIterator first, ForwardIterator last, size_type n)
__deque_iterator::deque::insert_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert_aux(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, const value_type* first, const value_type* last, size_type n)
__deque_iterator::deque::insert_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert_aux(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, const_iterator first, const_iterator last, size_type n)
__deque_iterator::deque::insert_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert_aux(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, size_type n, const value_type& x)
__deque_iterator::deque::iterator	stl_deque.h	/^  typedef __deque_iterator<T, T&, T*, BufSiz>              iterator;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::iterator	stl_deque.h	/^  typedef __deque_iterator<T, T&, T*>                      iterator;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::map	stl_deque.h	/^  map_pointer map;$/;"	m	class:__deque_iterator::deque	access:protected
__deque_iterator::deque::map_allocator	stl_deque.h	/^  typedef simple_alloc<pointer, Alloc> map_allocator;$/;"	t	class:__deque_iterator::deque	access:protected
__deque_iterator::deque::map_pointer	stl_deque.h	/^  typedef pointer* map_pointer;$/;"	t	class:__deque_iterator::deque	access:protected
__deque_iterator::deque::map_size	stl_deque.h	/^  size_type map_size;$/;"	m	class:__deque_iterator::deque	access:protected
__deque_iterator::deque::max_size	stl_deque.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
__deque_iterator::deque::new_elements_at_back	stl_deque.h	/^  void new_elements_at_back(size_type new_elements);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(size_type new_elements)
__deque_iterator::deque::new_elements_at_back	stl_deque.h	/^void deque<T, Alloc, BufSize>::new_elements_at_back(size_type new_elements) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type new_elements)
__deque_iterator::deque::new_elements_at_front	stl_deque.h	/^  void new_elements_at_front(size_type new_elements);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(size_type new_elements)
__deque_iterator::deque::new_elements_at_front	stl_deque.h	/^void deque<T, Alloc, BufSize>::new_elements_at_front(size_type new_elements) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type new_elements)
__deque_iterator::deque::operator !=	stl_deque.h	/^  bool operator!=(const deque<T, Alloc, 0>& x) const {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const deque<T, Alloc, 0>& x) const
__deque_iterator::deque::operator <	stl_deque.h	/^  bool operator<(const deque<T, Alloc, 0>& x) const {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const deque<T, Alloc, 0>& x) const
__deque_iterator::deque::operator =	stl_deque.h	/^  deque& operator= (const deque& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const deque& x)
__deque_iterator::deque::operator ==	stl_deque.h	/^  bool operator==(const deque<T, Alloc, 0>& x) const {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const deque<T, Alloc, 0>& x) const
__deque_iterator::deque::operator []	stl_deque.h	/^  const_reference operator[](size_type n) const {$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type n) const
__deque_iterator::deque::operator []	stl_deque.h	/^  reference operator[](size_type n) { return start[difference_type(n)]; }$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type n)
__deque_iterator::deque::pointer	stl_deque.h	/^  typedef value_type* pointer;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::pop_back	stl_deque.h	/^  void pop_back() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::pop_back_aux	stl_deque.h	/^  void pop_back_aux();$/;"	p	class:__deque_iterator::deque	access:protected	signature:()
__deque_iterator::deque::pop_back_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>:: pop_back_aux() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::pop_front	stl_deque.h	/^  void pop_front() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::pop_front_aux	stl_deque.h	/^  void pop_front_aux();$/;"	p	class:__deque_iterator::deque	access:protected	signature:()
__deque_iterator::deque::pop_front_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::pop_front_aux() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::push_back	stl_deque.h	/^  void push_back(const value_type& t) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const value_type& t)
__deque_iterator::deque::push_back_aux	stl_deque.h	/^  void push_back_aux(const value_type& t);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(const value_type& t)
__deque_iterator::deque::push_back_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::push_back_aux(const value_type& t) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const value_type& t)
__deque_iterator::deque::push_front	stl_deque.h	/^  void push_front(const value_type& t) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const value_type& t)
__deque_iterator::deque::push_front_aux	stl_deque.h	/^  void push_front_aux(const value_type& t);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(const value_type& t)
__deque_iterator::deque::push_front_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::push_front_aux(const value_type& t) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const value_type& t)
__deque_iterator::deque::range_initialize	stl_deque.h	/^  void range_initialize(ForwardIterator first, ForwardIterator last,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
__deque_iterator::deque::range_initialize	stl_deque.h	/^  void range_initialize(InputIterator first, InputIterator last,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(InputIterator first, InputIterator last, input_iterator_tag)
__deque_iterator::deque::range_initialize	stl_deque.h	/^void deque<T, Alloc, BufSize>::range_initialize(ForwardIterator first,$/;"	f	class:__deque_iterator::deque	access:public	signature:(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
__deque_iterator::deque::range_initialize	stl_deque.h	/^void deque<T, Alloc, BufSize>::range_initialize(InputIterator first,$/;"	f	class:__deque_iterator::deque	access:public	signature:(InputIterator first, InputIterator last, input_iterator_tag)
__deque_iterator::deque::rbegin	stl_deque.h	/^  const_reverse_iterator rbegin() const {$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
__deque_iterator::deque::rbegin	stl_deque.h	/^  reverse_iterator rbegin() { return reverse_iterator(finish); }$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::reallocate_map	stl_deque.h	/^  void reallocate_map(size_type nodes_to_add, bool add_at_front);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(size_type nodes_to_add, bool add_at_front)
__deque_iterator::deque::reallocate_map	stl_deque.h	/^void deque<T, Alloc, BufSize>::reallocate_map(size_type nodes_to_add,$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type nodes_to_add, bool add_at_front)
__deque_iterator::deque::reference	stl_deque.h	/^  typedef value_type& reference;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::rend	stl_deque.h	/^  const_reverse_iterator rend() const {$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
__deque_iterator::deque::rend	stl_deque.h	/^  reverse_iterator rend() { return reverse_iterator(start); }$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::deque::reserve_elements_at_back	stl_deque.h	/^  iterator reserve_elements_at_back(size_type n) {$/;"	f	class:__deque_iterator::deque	access:protected	signature:(size_type n)
__deque_iterator::deque::reserve_elements_at_front	stl_deque.h	/^  iterator reserve_elements_at_front(size_type n) {$/;"	f	class:__deque_iterator::deque	access:protected	signature:(size_type n)
__deque_iterator::deque::reserve_map_at_back	stl_deque.h	/^  void reserve_map_at_back (size_type nodes_to_add = 1) {$/;"	f	class:__deque_iterator::deque	access:protected	signature:(size_type nodes_to_add = 1)
__deque_iterator::deque::reserve_map_at_front	stl_deque.h	/^  void reserve_map_at_front (size_type nodes_to_add = 1) {$/;"	f	class:__deque_iterator::deque	access:protected	signature:(size_type nodes_to_add = 1)
__deque_iterator::deque::resize	stl_deque.h	/^  void resize(size_type new_size) { resize(new_size, value_type()); }$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type new_size)
__deque_iterator::deque::resize	stl_deque.h	/^  void resize(size_type new_size, const value_type& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type new_size, const value_type& x)
__deque_iterator::deque::reverse_iterator	stl_deque.h	/^          reverse_iterator; $/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::reverse_iterator	stl_deque.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::size	stl_deque.h	/^  size_type size() const { return finish - start;; }$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
__deque_iterator::deque::size_type	stl_deque.h	/^  typedef size_t size_type;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::start	stl_deque.h	/^  iterator start;$/;"	m	class:__deque_iterator::deque	access:protected
__deque_iterator::deque::swap	stl_deque.h	/^  void swap(deque& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(deque& x)
__deque_iterator::deque::value_type	stl_deque.h	/^  typedef T value_type;$/;"	t	class:__deque_iterator::deque	access:public
__deque_iterator::deque::~deque	stl_deque.h	/^  ~deque() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
__deque_iterator::distance_type	stl_deque.h	/^inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {$/;"	f	struct:__deque_iterator	access:public	signature:(const __deque_iterator<T, Ref, Ptr, BufSiz>&)
__deque_iterator::distance_type	stl_deque.h	/^inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr>&) {$/;"	f	struct:__deque_iterator	access:public	signature:(const __deque_iterator<T, Ref, Ptr>&)
__deque_iterator::iterator	stl_deque.h	/^  typedef __deque_iterator<T, T&, T*, BufSiz>             iterator;$/;"	t	struct:__deque_iterator	access:public
__deque_iterator::iterator_category	stl_deque.h	/^iterator_category(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {$/;"	f	struct:__deque_iterator	access:public	signature:(const __deque_iterator<T, Ref, Ptr, BufSiz>&)
__deque_iterator::iterator_category	stl_deque.h	/^iterator_category(const __deque_iterator<T, Ref, Ptr>&) {$/;"	f	struct:__deque_iterator	access:public	signature:(const __deque_iterator<T, Ref, Ptr>&)
__deque_iterator::operator <	stl_deque.h	/^bool operator<(const deque<T, Alloc, BufSiz>& x,$/;"	f	struct:__deque_iterator	access:public	signature:(const deque<T, Alloc, BufSiz>& x, const deque<T, Alloc, BufSiz>& y)
__deque_iterator::operator ==	stl_deque.h	/^bool operator==(const deque<T, Alloc, BufSiz>& x,$/;"	f	struct:__deque_iterator	access:public	signature:(const deque<T, Alloc, BufSiz>& x, const deque<T, Alloc, BufSiz>& y)
__deque_iterator::swap	stl_deque.h	/^inline void swap(deque<T, Alloc, BufSiz>& x, deque<T, Alloc, BufSiz>& y) {$/;"	f	struct:__deque_iterator	access:public	signature:(deque<T, Alloc, BufSiz>& x, deque<T, Alloc, BufSiz>& y)
__deque_iterator::value_type	stl_deque.h	/^inline T* value_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {$/;"	f	struct:__deque_iterator	access:public	signature:(const __deque_iterator<T, Ref, Ptr, BufSiz>&)
__deque_iterator::value_type	stl_deque.h	/^inline T* value_type(const __deque_iterator<T, Ref, Ptr>&) { return 0; }$/;"	f	struct:__deque_iterator	access:public	signature:(const __deque_iterator<T, Ref, Ptr>&)
__destroy	stl_construct.h	/^inline void __destroy(ForwardIterator first, ForwardIterator last, T*) {$/;"	f	signature:(ForwardIterator first, ForwardIterator last, T*)
__destroy_aux	stl_construct.h	/^__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) {$/;"	f	signature:(ForwardIterator first, ForwardIterator last, __false_type)
__destroy_aux	stl_construct.h	/^inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}$/;"	f	signature:(ForwardIterator, ForwardIterator, __true_type)
__distance	stl_iterator.h	/^__distance(InputIterator first, InputIterator last, input_iterator_tag) {$/;"	f	signature:(InputIterator first, InputIterator last, input_iterator_tag)
__distance	stl_iterator.h	/^__distance(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag)
__distance	stl_iterator.h	/^inline void __distance(InputIterator first, InputIterator last, Distance& n, $/;"	f	signature:(InputIterator first, InputIterator last, Distance& n, input_iterator_tag)
__distance	stl_iterator.h	/^inline void __distance(RandomAccessIterator first, RandomAccessIterator last, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Distance& n, random_access_iterator_tag)
__eos	stl_rope.h	/^inline charT __eos(charT*) { return charT(); }$/;"	f	signature:(charT*)
__equal_range	stl_algo.h	/^__equal_range(ForwardIterator first, ForwardIterator last, const T& value,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value, Compare comp, Distance*, forward_iterator_tag)
__equal_range	stl_algo.h	/^__equal_range(ForwardIterator first, ForwardIterator last, const T& value,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value, Distance*, forward_iterator_tag)
__equal_range	stl_algo.h	/^__equal_range(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, const T& value, Compare comp, Distance*, random_access_iterator_tag)
__equal_range	stl_algo.h	/^__equal_range(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, const T& value, Distance*, random_access_iterator_tag)
__erase	stl_tree.h	/^  void __erase(link_type x);$/;"	p	class:rb_tree	access:private	signature:(link_type x)
__erase	stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__erase(link_type x) {$/;"	f	class:rb_tree	signature:(link_type x)
__false_type	type_traits.h	/^struct __false_type {$/;"	s
__final_insertion_sort	stl_algo.h	/^void __final_insertion_sort(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last)
__final_insertion_sort	stl_algo.h	/^void __final_insertion_sort(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
__find_end	stl_algo.h	/^ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f	signature:(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, forward_iterator_tag, forward_iterator_tag)
__find_end	stl_algo.h	/^ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f	signature:(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, forward_iterator_tag, forward_iterator_tag, BinaryPredicate comp)
__find_end	stl_algo.h	/^__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,$/;"	f	signature:(BidirectionalIterator1 first1, BidirectionalIterator1 last1, BidirectionalIterator2 first2, BidirectionalIterator2 last2, bidirectional_iterator_tag, bidirectional_iterator_tag)
__find_end	stl_algo.h	/^__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,$/;"	f	signature:(BidirectionalIterator1 first1, BidirectionalIterator1 last1, BidirectionalIterator2 first2, BidirectionalIterator2 last2, bidirectional_iterator_tag, bidirectional_iterator_tag, BinaryPredicate comp)
__gcd	stl_algo.h	/^EuclideanRingElement __gcd(EuclideanRingElement m, EuclideanRingElement n)$/;"	f	signature:(EuclideanRingElement m, EuclideanRingElement n)
__hashtable_const_iterator	stl_hashtable.h	/^  __hashtable_const_iterator() {}$/;"	f	struct:__hashtable_const_iterator	access:public	signature:()
__hashtable_const_iterator	stl_hashtable.h	/^  __hashtable_const_iterator(const iterator& it) : cur(it.cur), ht(it.ht) {}$/;"	f	struct:__hashtable_const_iterator	access:public	signature:(const iterator& it)
__hashtable_const_iterator	stl_hashtable.h	/^  __hashtable_const_iterator(const node* n, const hashtable* tab)$/;"	f	struct:__hashtable_const_iterator	access:public	signature:(const node* n, const hashtable* tab)
__hashtable_const_iterator	stl_hashtable.h	/^struct __hashtable_const_iterator {$/;"	s
__hashtable_const_iterator::__hashtable_const_iterator	stl_hashtable.h	/^  __hashtable_const_iterator() {}$/;"	f	struct:__hashtable_const_iterator	access:public	signature:()
__hashtable_const_iterator::__hashtable_const_iterator	stl_hashtable.h	/^  __hashtable_const_iterator(const iterator& it) : cur(it.cur), ht(it.ht) {}$/;"	f	struct:__hashtable_const_iterator	access:public	signature:(const iterator& it)
__hashtable_const_iterator::__hashtable_const_iterator	stl_hashtable.h	/^  __hashtable_const_iterator(const node* n, const hashtable* tab)$/;"	f	struct:__hashtable_const_iterator	access:public	signature:(const node* n, const hashtable* tab)
__hashtable_const_iterator::const_iterator	stl_hashtable.h	/^          const_iterator;$/;"	t	struct:__hashtable_const_iterator	access:public
__hashtable_const_iterator::cur	stl_hashtable.h	/^  const node* cur;$/;"	m	struct:__hashtable_const_iterator	access:public
__hashtable_const_iterator::difference_type	stl_hashtable.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__hashtable_const_iterator	access:public
__hashtable_const_iterator::hashtable	stl_hashtable.h	/^          hashtable;$/;"	t	struct:__hashtable_const_iterator	access:public
__hashtable_const_iterator::ht	stl_hashtable.h	/^  const hashtable* ht;$/;"	m	struct:__hashtable_const_iterator	access:public
__hashtable_const_iterator::iterator	stl_hashtable.h	/^          iterator;$/;"	t	struct:__hashtable_const_iterator	access:public
__hashtable_const_iterator::iterator_category	stl_hashtable.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__hashtable_const_iterator	access:public
__hashtable_const_iterator::node	stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	struct:__hashtable_const_iterator	access:public
__hashtable_const_iterator::operator !=	stl_hashtable.h	/^  bool operator!=(const const_iterator& it) const { return cur != it.cur; }$/;"	f	struct:__hashtable_const_iterator	access:public	signature:(const const_iterator& it) const
__hashtable_const_iterator::operator *	stl_hashtable.h	/^  reference operator*() const { return cur->val; }$/;"	f	struct:__hashtable_const_iterator	access:public	signature:() const
__hashtable_const_iterator::operator ++	stl_hashtable.h	/^  const_iterator operator++(int);$/;"	p	struct:__hashtable_const_iterator	access:public	signature:(int)
__hashtable_const_iterator::operator ++	stl_hashtable.h	/^  const_iterator& operator++();$/;"	p	struct:__hashtable_const_iterator	access:public	signature:()
__hashtable_const_iterator::operator ++	stl_hashtable.h	/^__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++()$/;"	f	class:__hashtable_const_iterator	signature:()
__hashtable_const_iterator::operator ++	stl_hashtable.h	/^__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++(int)$/;"	f	class:__hashtable_const_iterator	signature:(int)
__hashtable_const_iterator::operator ->	stl_hashtable.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__hashtable_const_iterator	access:public	signature:() const
__hashtable_const_iterator::operator ==	stl_hashtable.h	/^  bool operator==(const const_iterator& it) const { return cur == it.cur; }$/;"	f	struct:__hashtable_const_iterator	access:public	signature:(const const_iterator& it) const
__hashtable_const_iterator::pointer	stl_hashtable.h	/^  typedef const Value* pointer;$/;"	t	struct:__hashtable_const_iterator	access:public
__hashtable_const_iterator::reference	stl_hashtable.h	/^  typedef const Value& reference;$/;"	t	struct:__hashtable_const_iterator	access:public
__hashtable_const_iterator::size_type	stl_hashtable.h	/^  typedef size_t size_type;$/;"	t	struct:__hashtable_const_iterator	access:public
__hashtable_const_iterator::value_type	stl_hashtable.h	/^  typedef Value value_type;$/;"	t	struct:__hashtable_const_iterator	access:public
__hashtable_iterator	stl_hashtable.h	/^  __hashtable_iterator() {}$/;"	f	struct:__hashtable_iterator	access:public	signature:()
__hashtable_iterator	stl_hashtable.h	/^  __hashtable_iterator(node* n, hashtable* tab) : cur(n), ht(tab) {}$/;"	f	struct:__hashtable_iterator	access:public	signature:(node* n, hashtable* tab)
__hashtable_iterator	stl_hashtable.h	/^struct __hashtable_iterator {$/;"	s
__hashtable_iterator::__hashtable_iterator	stl_hashtable.h	/^  __hashtable_iterator() {}$/;"	f	struct:__hashtable_iterator	access:public	signature:()
__hashtable_iterator::__hashtable_iterator	stl_hashtable.h	/^  __hashtable_iterator(node* n, hashtable* tab) : cur(n), ht(tab) {}$/;"	f	struct:__hashtable_iterator	access:public	signature:(node* n, hashtable* tab)
__hashtable_iterator::const_iterator	stl_hashtable.h	/^          const_iterator;$/;"	t	struct:__hashtable_iterator	access:public
__hashtable_iterator::cur	stl_hashtable.h	/^  node* cur;$/;"	m	struct:__hashtable_iterator	access:public
__hashtable_iterator::difference_type	stl_hashtable.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__hashtable_iterator	access:public
__hashtable_iterator::hashtable	stl_hashtable.h	/^          hashtable;$/;"	t	struct:__hashtable_iterator	access:public
__hashtable_iterator::ht	stl_hashtable.h	/^  hashtable* ht;$/;"	m	struct:__hashtable_iterator	access:public
__hashtable_iterator::iterator	stl_hashtable.h	/^          iterator;$/;"	t	struct:__hashtable_iterator	access:public
__hashtable_iterator::iterator_category	stl_hashtable.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__hashtable_iterator	access:public
__hashtable_iterator::node	stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	struct:__hashtable_iterator	access:public
__hashtable_iterator::operator !=	stl_hashtable.h	/^  bool operator!=(const iterator& it) const { return cur != it.cur; }$/;"	f	struct:__hashtable_iterator	access:public	signature:(const iterator& it) const
__hashtable_iterator::operator *	stl_hashtable.h	/^  reference operator*() const { return cur->val; }$/;"	f	struct:__hashtable_iterator	access:public	signature:() const
__hashtable_iterator::operator ++	stl_hashtable.h	/^  iterator operator++(int);$/;"	p	struct:__hashtable_iterator	access:public	signature:(int)
__hashtable_iterator::operator ++	stl_hashtable.h	/^  iterator& operator++();$/;"	p	struct:__hashtable_iterator	access:public	signature:()
__hashtable_iterator::operator ++	stl_hashtable.h	/^__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++()$/;"	f	class:__hashtable_iterator	signature:()
__hashtable_iterator::operator ++	stl_hashtable.h	/^__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++(int)$/;"	f	class:__hashtable_iterator	signature:(int)
__hashtable_iterator::operator ->	stl_hashtable.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__hashtable_iterator	access:public	signature:() const
__hashtable_iterator::operator ==	stl_hashtable.h	/^  bool operator==(const iterator& it) const { return cur == it.cur; }$/;"	f	struct:__hashtable_iterator	access:public	signature:(const iterator& it) const
__hashtable_iterator::pointer	stl_hashtable.h	/^  typedef Value* pointer;$/;"	t	struct:__hashtable_iterator	access:public
__hashtable_iterator::reference	stl_hashtable.h	/^  typedef Value& reference;$/;"	t	struct:__hashtable_iterator	access:public
__hashtable_iterator::size_type	stl_hashtable.h	/^  typedef size_t size_type;$/;"	t	struct:__hashtable_iterator	access:public
__hashtable_iterator::value_type	stl_hashtable.h	/^  typedef Value value_type;$/;"	t	struct:__hashtable_iterator	access:public
__hashtable_node	stl_hashtable.h	/^struct __hashtable_node$/;"	s
__hashtable_node::next	stl_hashtable.h	/^  __hashtable_node* next;$/;"	m	struct:__hashtable_node	access:public
__hashtable_node::val	stl_hashtable.h	/^  Value val;$/;"	m	struct:__hashtable_node	access:public
__inplace_merge_aux	stl_algo.h	/^inline void __inplace_merge_aux(BidirectionalIterator first,$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, T*, Distance*)
__inplace_merge_aux	stl_algo.h	/^inline void __inplace_merge_aux(BidirectionalIterator first,$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, T*, Distance*, Compare comp)
__inplace_stable_partition	stl_algo.h	/^ForwardIterator __inplace_stable_partition(ForwardIterator first,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, Predicate pred, Distance len)
__inplace_stable_sort	stl_algo.h	/^void __inplace_stable_sort(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last)
__inplace_stable_sort	stl_algo.h	/^void __inplace_stable_sort(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
__insert	stl_tree.h	/^  iterator __insert(base_ptr x, base_ptr y, const value_type& v);$/;"	p	class:rb_tree	access:private	signature:(base_ptr x, base_ptr y, const value_type& v)
__insert	stl_tree.h	/^__insert(base_ptr x_, base_ptr y_, const Value& v) {$/;"	f	class:rb_tree	signature:(base_ptr x_, base_ptr y_, const Value& v)
__insertion_sort	stl_algo.h	/^void __insertion_sort(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last)
__insertion_sort	stl_algo.h	/^void __insertion_sort(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
__introsort_loop	stl_algo.h	/^void __introsort_loop(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, T*, Size depth_limit)
__introsort_loop	stl_algo.h	/^void __introsort_loop(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, T*, Size depth_limit, Compare comp)
__is_basic_char_type	stl_rope.h	/^inline bool __is_basic_char_type(char *) { return true; }$/;"	f	signature:(char *)
__is_basic_char_type	stl_rope.h	/^inline bool __is_basic_char_type(charT *) { return false; }$/;"	f	signature:(charT *)
__is_basic_char_type	stl_rope.h	/^inline bool __is_basic_char_type(wchar_t *) { return true; }$/;"	f	signature:(wchar_t *)
__is_heap	stl_algo.h	/^bool __is_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Distance*)
__is_heap	stl_algo.h	/^bool __is_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp, Distance*)
__is_one_byte_char_type	stl_rope.h	/^inline bool __is_one_byte_char_type(char *) { return true; }$/;"	f	signature:(char *)
__is_one_byte_char_type	stl_rope.h	/^inline bool __is_one_byte_char_type(charT *) { return false; }$/;"	f	signature:(charT *)
__iter_swap	stl_algobase.h	/^inline void __iter_swap(ForwardIterator1 a, ForwardIterator2 b, T*) {$/;"	f	signature:(ForwardIterator1 a, ForwardIterator2 b, T*)
__lg	stl_algo.h	/^inline Size __lg(Size n) {$/;"	f	signature:(Size n)
__linear_insert	stl_algo.h	/^inline void __linear_insert(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, T*)
__linear_insert	stl_algo.h	/^inline void __linear_insert(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, T*, Compare comp)
__list_iterator	stl_list.h	/^  __list_iterator() {}$/;"	f	struct:__list_iterator	access:public	signature:()
__list_iterator	stl_list.h	/^  __list_iterator(const iterator& x) : node(x.node) {}$/;"	f	struct:__list_iterator	access:public	signature:(const iterator& x)
__list_iterator	stl_list.h	/^  __list_iterator(link_type x) : node(x) {}$/;"	f	struct:__list_iterator	access:public	signature:(link_type x)
__list_iterator	stl_list.h	/^struct __list_iterator {$/;"	s
__list_iterator::__list_iterator	stl_list.h	/^  __list_iterator() {}$/;"	f	struct:__list_iterator	access:public	signature:()
__list_iterator::__list_iterator	stl_list.h	/^  __list_iterator(const iterator& x) : node(x.node) {}$/;"	f	struct:__list_iterator	access:public	signature:(const iterator& x)
__list_iterator::__list_iterator	stl_list.h	/^  __list_iterator(link_type x) : node(x) {}$/;"	f	struct:__list_iterator	access:public	signature:(link_type x)
__list_iterator::const_iterator	stl_list.h	/^  typedef __list_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:__list_iterator	access:public
__list_iterator::difference_type	stl_list.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__list_iterator	access:public
__list_iterator::iterator	stl_list.h	/^  typedef __list_iterator<T, T&, T*>             iterator;$/;"	t	struct:__list_iterator	access:public
__list_iterator::iterator_category	stl_list.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:__list_iterator	access:public
__list_iterator::link_type	stl_list.h	/^  typedef __list_node<T>* link_type;$/;"	t	struct:__list_iterator	access:public
__list_iterator::node	stl_list.h	/^  link_type node;$/;"	m	struct:__list_iterator	access:public
__list_iterator::operator !=	stl_list.h	/^  bool operator!=(const self& x) const { return node != x.node; }$/;"	f	struct:__list_iterator	access:public	signature:(const self& x) const
__list_iterator::operator *	stl_list.h	/^  reference operator*() const { return (*node).data; }$/;"	f	struct:__list_iterator	access:public	signature:() const
__list_iterator::operator ++	stl_list.h	/^  self operator++(int) { $/;"	f	struct:__list_iterator	access:public	signature:(int)
__list_iterator::operator ++	stl_list.h	/^  self& operator++() { $/;"	f	struct:__list_iterator	access:public	signature:()
__list_iterator::operator --	stl_list.h	/^  self operator--(int) { $/;"	f	struct:__list_iterator	access:public	signature:(int)
__list_iterator::operator --	stl_list.h	/^  self& operator--() { $/;"	f	struct:__list_iterator	access:public	signature:()
__list_iterator::operator ->	stl_list.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__list_iterator	access:public	signature:() const
__list_iterator::operator ==	stl_list.h	/^  bool operator==(const self& x) const { return node == x.node; }$/;"	f	struct:__list_iterator	access:public	signature:(const self& x) const
__list_iterator::pointer	stl_list.h	/^  typedef Ptr pointer;$/;"	t	struct:__list_iterator	access:public
__list_iterator::reference	stl_list.h	/^  typedef Ref reference;$/;"	t	struct:__list_iterator	access:public
__list_iterator::self	stl_list.h	/^  typedef __list_iterator<T, Ref, Ptr>           self;$/;"	t	struct:__list_iterator	access:public
__list_iterator::size_type	stl_list.h	/^  typedef size_t size_type;$/;"	t	struct:__list_iterator	access:public
__list_iterator::value_type	stl_list.h	/^  typedef T value_type;$/;"	t	struct:__list_iterator	access:public
__list_node	stl_list.h	/^struct __list_node {$/;"	s
__list_node::data	stl_list.h	/^  T data;$/;"	m	struct:__list_node	access:public
__list_node::next	stl_list.h	/^  void_pointer next;$/;"	m	struct:__list_node	access:public
__list_node::prev	stl_list.h	/^  void_pointer prev;$/;"	m	struct:__list_node	access:public
__list_node::void_pointer	stl_list.h	/^  typedef void* void_pointer;$/;"	t	struct:__list_node	access:public
__lock	stl_alloc.h	/^    static void __lock(volatile unsigned long *); $/;"	p	class:__default_alloc_template	access:private	signature:(volatile unsigned long *)
__lock	stl_alloc.h	/^__default_alloc_template<threads, inst>::__lock(volatile unsigned long *lock)$/;"	f	class:__default_alloc_template	signature:(volatile unsigned long *lock)
__lower_bound	stl_algo.h	/^ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value, Compare comp, Distance*, forward_iterator_tag)
__lower_bound	stl_algo.h	/^ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value, Distance*, forward_iterator_tag)
__lower_bound	stl_algo.h	/^RandomAccessIterator __lower_bound(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, const T& value, Compare comp, Distance*, random_access_iterator_tag)
__lower_bound	stl_algo.h	/^RandomAccessIterator __lower_bound(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, const T& value, Distance*, random_access_iterator_tag)
__make_heap	stl_heap.h	/^void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, T*, Distance*)
__make_heap	stl_heap.h	/^void __make_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Compare comp, T*, Distance*)
__malloc_alloc_oom_handler	stl_alloc.h	/^    static void (* __malloc_alloc_oom_handler)();$/;"	m	class:__malloc_alloc_template	access:private
__malloc_alloc_oom_handler	stl_alloc.h	/^    void (* __malloc_alloc_oom_handler)() = 0;$/;"	v
__malloc_alloc_oom_handler	stl_alloc.h	/^void (* __malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = 0;$/;"	v
__malloc_alloc_template	stl_alloc.h	/^class __malloc_alloc_template {$/;"	c
__malloc_alloc_template::__malloc_alloc_oom_handler	stl_alloc.h	/^    static void (* __malloc_alloc_oom_handler)();$/;"	m	class:__malloc_alloc_template	access:private
__malloc_alloc_template::allocate	stl_alloc.h	/^static void * allocate(size_t n)$/;"	f	class:__malloc_alloc_template	access:public	signature:(size_t n)
__malloc_alloc_template::deallocate	stl_alloc.h	/^static void deallocate(void *p, size_t \/* n *\/)$/;"	f	class:__malloc_alloc_template	access:public	signature:(void *p, size_t )
__malloc_alloc_template::oom_malloc	stl_alloc.h	/^static void *oom_malloc(size_t);$/;"	p	class:__malloc_alloc_template	access:private	signature:(size_t)
__malloc_alloc_template::oom_malloc	stl_alloc.h	/^void * __malloc_alloc_template<inst>::oom_malloc(size_t n)$/;"	f	class:__malloc_alloc_template	signature:(size_t n)
__malloc_alloc_template::oom_realloc	stl_alloc.h	/^static void *oom_realloc(void *, size_t);$/;"	p	class:__malloc_alloc_template	access:private	signature:(void *, size_t)
__malloc_alloc_template::oom_realloc	stl_alloc.h	/^void * __malloc_alloc_template<inst>::oom_realloc(void *p, size_t n)$/;"	f	class:__malloc_alloc_template	signature:(void *p, size_t n)
__malloc_alloc_template::reallocate	stl_alloc.h	/^static void * reallocate(void *p, size_t \/* old_sz *\/, size_t new_sz)$/;"	f	class:__malloc_alloc_template	access:public	signature:(void *p, size_t , size_t new_sz)
__malloc_alloc_template::set_malloc_handler	stl_alloc.h	/^static void (* set_malloc_handler(void (*f)()))()$/;"	f	class:__malloc_alloc_template	access:public	signature:(void (*f)())
__median	stl_algo.h	/^inline const T& __median(const T& a, const T& b, const T& c) {$/;"	f	signature:(const T& a, const T& b, const T& c)
__median	stl_algo.h	/^inline const T& __median(const T& a, const T& b, const T& c, Compare comp) {$/;"	f	signature:(const T& a, const T& b, const T& c, Compare comp)
__merge_adaptive	stl_algo.h	/^void __merge_adaptive(BidirectionalIterator first, $/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Distance len1, Distance len2, Pointer buffer, Distance buffer_size)
__merge_adaptive	stl_algo.h	/^void __merge_adaptive(BidirectionalIterator first, $/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Distance len1, Distance len2, Pointer buffer, Distance buffer_size, Compare comp)
__merge_backward	stl_algo.h	/^BidirectionalIterator3 __merge_backward(BidirectionalIterator1 first1,$/;"	f	signature:(BidirectionalIterator1 first1, BidirectionalIterator1 last1, BidirectionalIterator2 first2, BidirectionalIterator2 last2, BidirectionalIterator3 result)
__merge_backward	stl_algo.h	/^BidirectionalIterator3 __merge_backward(BidirectionalIterator1 first1,$/;"	f	signature:(BidirectionalIterator1 first1, BidirectionalIterator1 last1, BidirectionalIterator2 first2, BidirectionalIterator2 last2, BidirectionalIterator3 result, Compare comp)
__merge_sort_loop	stl_algo.h	/^void __merge_sort_loop(RandomAccessIterator1 first,$/;"	f	signature:(RandomAccessIterator1 first, RandomAccessIterator1 last, RandomAccessIterator2 result, Distance step_size)
__merge_sort_loop	stl_algo.h	/^void __merge_sort_loop(RandomAccessIterator1 first,$/;"	f	signature:(RandomAccessIterator1 first, RandomAccessIterator1 last, RandomAccessIterator2 result, Distance step_size, Compare comp)
__merge_sort_with_buffer	stl_algo.h	/^void __merge_sort_with_buffer(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Pointer buffer, Distance*)
__merge_sort_with_buffer	stl_algo.h	/^void __merge_sort_with_buffer(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Pointer buffer, Distance*, Compare comp)
__merge_without_buffer	stl_algo.h	/^void __merge_without_buffer(BidirectionalIterator first,$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Distance len1, Distance len2)
__merge_without_buffer	stl_algo.h	/^void __merge_without_buffer(BidirectionalIterator first,$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Distance len1, Distance len2, Compare comp)
__mutable_reference_at	stl_rope.h	/^inline crope::reference __mutable_reference_at(crope& c, size_t i)$/;"	f	signature:(crope& c, size_t i)
__mutable_reference_at	stl_rope.h	/^inline wrope::reference __mutable_reference_at(wrope& c, size_t i)$/;"	f	signature:(wrope& c, size_t i)
__node_allocator_dummy_instance	stl_alloc.h	/^  static alloc __node_allocator_dummy_instance;$/;"	v
__node_allocator_lock	stl_alloc.h	/^    __default_alloc_template<threads, inst>::__node_allocator_lock$/;"	m	class:__default_alloc_template
__node_allocator_lock	stl_alloc.h	/^    __default_alloc_template<threads, inst>::__node_allocator_lock;$/;"	m	class:__default_alloc_template
__node_allocator_lock	stl_alloc.h	/^    static CRITICAL_SECTION __node_allocator_lock;$/;"	m	class:__default_alloc_template	access:private
__node_allocator_lock	stl_alloc.h	/^    static pthread_mutex_t __node_allocator_lock;$/;"	m	class:__default_alloc_template	access:private
__node_allocator_lock	stl_alloc.h	/^    static volatile unsigned long __node_allocator_lock;$/;"	m	class:__default_alloc_template	access:private
__node_allocator_lock	stl_alloc.h	/^__default_alloc_template<threads, inst>::__node_allocator_lock = 0;$/;"	m	class:__default_alloc_template
__node_allocator_lock_initialized	stl_alloc.h	/^    __default_alloc_template<threads, inst>::__node_allocator_lock_initialized$/;"	m	class:__default_alloc_template
__node_allocator_lock_initialized	stl_alloc.h	/^    static bool __node_allocator_lock_initialized;$/;"	m	class:__default_alloc_template	access:private
__nth_element	stl_algo.h	/^void __nth_element(RandomAccessIterator first, RandomAccessIterator nth,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, T*)
__nth_element	stl_algo.h	/^void __nth_element(RandomAccessIterator first, RandomAccessIterator nth,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, T*, Compare comp)
__partial_sort	stl_algo.h	/^void __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, T*)
__partial_sort	stl_algo.h	/^void __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, T*, Compare comp)
__partial_sort_copy	stl_algo.h	/^RandomAccessIterator __partial_sort_copy(InputIterator first,$/;"	f	signature:(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp, Distance*, T*)
__partial_sort_copy	stl_algo.h	/^RandomAccessIterator __partial_sort_copy(InputIterator first,$/;"	f	signature:(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last, Distance*, T*)
__partial_sum	stl_numeric.h	/^OutputIterator __partial_sum(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, T*)
__partial_sum	stl_numeric.h	/^OutputIterator __partial_sum(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, T*, BinaryOperation binary_op)
__pop_heap	stl_heap.h	/^inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, RandomAccessIterator result, T value, Compare comp, Distance*)
__pop_heap	stl_heap.h	/^inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, RandomAccessIterator result, T value, Distance*)
__pop_heap_aux	stl_heap.h	/^inline void __pop_heap_aux(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, T*)
__pop_heap_aux	stl_heap.h	/^inline void __pop_heap_aux(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, T*, Compare comp)
__push_heap	stl_heap.h	/^void __push_heap(RandomAccessIterator first, Distance holeIndex,$/;"	f	signature:(RandomAccessIterator first, Distance holeIndex, Distance topIndex, T value)
__push_heap	stl_heap.h	/^void __push_heap(RandomAccessIterator first, Distance holeIndex,$/;"	f	signature:(RandomAccessIterator first, Distance holeIndex, Distance topIndex, T value, Compare comp)
__push_heap_aux	stl_heap.h	/^inline void __push_heap_aux(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Compare comp, Distance*, T*)
__push_heap_aux	stl_heap.h	/^inline void __push_heap_aux(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Distance*, T*)
__random_sample	stl_algo.h	/^RandomAccessIterator __random_sample(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, RandomAccessIterator out, RandomNumberGenerator& rand, const Distance n)
__random_sample	stl_algo.h	/^RandomAccessIterator __random_sample(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, RandomAccessIterator out, const Distance n)
__random_shuffle	stl_algo.h	/^void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Distance*)
__rb_tree_base_iterator	stl_tree.h	/^struct __rb_tree_base_iterator$/;"	s
__rb_tree_base_iterator::base_ptr	stl_tree.h	/^  typedef __rb_tree_node_base::base_ptr base_ptr;$/;"	t	struct:__rb_tree_base_iterator	access:public
__rb_tree_base_iterator::decrement	stl_tree.h	/^  void decrement()$/;"	f	struct:__rb_tree_base_iterator	access:public	signature:()
__rb_tree_base_iterator::difference_type	stl_tree.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__rb_tree_base_iterator	access:public
__rb_tree_base_iterator::increment	stl_tree.h	/^  void increment()$/;"	f	struct:__rb_tree_base_iterator	access:public	signature:()
__rb_tree_base_iterator::iterator_category	stl_tree.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:__rb_tree_base_iterator	access:public
__rb_tree_base_iterator::node	stl_tree.h	/^  base_ptr node;$/;"	m	struct:__rb_tree_base_iterator	access:public
__rb_tree_black	stl_tree.h	/^const __rb_tree_color_type __rb_tree_black = true;$/;"	v
__rb_tree_color_type	stl_tree.h	/^typedef bool __rb_tree_color_type;$/;"	t
__rb_tree_iterator	stl_tree.h	/^  __rb_tree_iterator() {}$/;"	f	struct:__rb_tree_iterator	access:public	signature:()
__rb_tree_iterator	stl_tree.h	/^  __rb_tree_iterator(const iterator& it) { node = it.node; }$/;"	f	struct:__rb_tree_iterator	access:public	signature:(const iterator& it)
__rb_tree_iterator	stl_tree.h	/^  __rb_tree_iterator(link_type x) { node = x; }$/;"	f	struct:__rb_tree_iterator	access:public	signature:(link_type x)
__rb_tree_iterator	stl_tree.h	/^struct __rb_tree_iterator : public __rb_tree_base_iterator$/;"	s	inherits:__rb_tree_base_iterator
__rb_tree_iterator::__rb_tree_iterator	stl_tree.h	/^  __rb_tree_iterator() {}$/;"	f	struct:__rb_tree_iterator	access:public	signature:()
__rb_tree_iterator::__rb_tree_iterator	stl_tree.h	/^  __rb_tree_iterator(const iterator& it) { node = it.node; }$/;"	f	struct:__rb_tree_iterator	access:public	signature:(const iterator& it)
__rb_tree_iterator::__rb_tree_iterator	stl_tree.h	/^  __rb_tree_iterator(link_type x) { node = x; }$/;"	f	struct:__rb_tree_iterator	access:public	signature:(link_type x)
__rb_tree_iterator::const_iterator	stl_tree.h	/^  typedef __rb_tree_iterator<Value, const Value&, const Value*> const_iterator;$/;"	t	struct:__rb_tree_iterator	access:public
__rb_tree_iterator::iterator	stl_tree.h	/^  typedef __rb_tree_iterator<Value, Value&, Value*>             iterator;$/;"	t	struct:__rb_tree_iterator	access:public
__rb_tree_iterator::link_type	stl_tree.h	/^  typedef __rb_tree_node<Value>* link_type;$/;"	t	struct:__rb_tree_iterator	access:public
__rb_tree_iterator::operator *	stl_tree.h	/^  reference operator*() const { return link_type(node)->value_field; }$/;"	f	struct:__rb_tree_iterator	access:public	signature:() const
__rb_tree_iterator::operator ++	stl_tree.h	/^  self operator++(int) {$/;"	f	struct:__rb_tree_iterator	access:public	signature:(int)
__rb_tree_iterator::operator ++	stl_tree.h	/^  self& operator++() { increment(); return *this; }$/;"	f	struct:__rb_tree_iterator	access:public	signature:()
__rb_tree_iterator::operator --	stl_tree.h	/^  self operator--(int) {$/;"	f	struct:__rb_tree_iterator	access:public	signature:(int)
__rb_tree_iterator::operator --	stl_tree.h	/^  self& operator--() { decrement(); return *this; }$/;"	f	struct:__rb_tree_iterator	access:public	signature:()
__rb_tree_iterator::operator ->	stl_tree.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__rb_tree_iterator	access:public	signature:() const
__rb_tree_iterator::pointer	stl_tree.h	/^  typedef Ptr pointer;$/;"	t	struct:__rb_tree_iterator	access:public
__rb_tree_iterator::reference	stl_tree.h	/^  typedef Ref reference;$/;"	t	struct:__rb_tree_iterator	access:public
__rb_tree_iterator::self	stl_tree.h	/^  typedef __rb_tree_iterator<Value, Ref, Ptr>                   self;$/;"	t	struct:__rb_tree_iterator	access:public
__rb_tree_iterator::value_type	stl_tree.h	/^  typedef Value value_type;$/;"	t	struct:__rb_tree_iterator	access:public
__rb_tree_node	stl_tree.h	/^struct __rb_tree_node : public __rb_tree_node_base$/;"	s	inherits:__rb_tree_node_base
__rb_tree_node::link_type	stl_tree.h	/^  typedef __rb_tree_node<Value>* link_type;$/;"	t	struct:__rb_tree_node	access:public
__rb_tree_node::value_field	stl_tree.h	/^  Value value_field;$/;"	m	struct:__rb_tree_node	access:public
__rb_tree_node_base	stl_tree.h	/^struct __rb_tree_node_base$/;"	s
__rb_tree_node_base::base_ptr	stl_tree.h	/^  typedef __rb_tree_node_base* base_ptr;$/;"	t	struct:__rb_tree_node_base	access:public
__rb_tree_node_base::color	stl_tree.h	/^  color_type color; $/;"	m	struct:__rb_tree_node_base	access:public
__rb_tree_node_base::color_type	stl_tree.h	/^  typedef __rb_tree_color_type color_type;$/;"	t	struct:__rb_tree_node_base	access:public
__rb_tree_node_base::left	stl_tree.h	/^  base_ptr left;$/;"	m	struct:__rb_tree_node_base	access:public
__rb_tree_node_base::maximum	stl_tree.h	/^  static base_ptr maximum(base_ptr x)$/;"	f	struct:__rb_tree_node_base	access:public	signature:(base_ptr x)
__rb_tree_node_base::minimum	stl_tree.h	/^  static base_ptr minimum(base_ptr x)$/;"	f	struct:__rb_tree_node_base	access:public	signature:(base_ptr x)
__rb_tree_node_base::parent	stl_tree.h	/^  base_ptr parent;$/;"	m	struct:__rb_tree_node_base	access:public
__rb_tree_node_base::right	stl_tree.h	/^  base_ptr right;$/;"	m	struct:__rb_tree_node_base	access:public
__rb_tree_rebalance	stl_tree.h	/^__rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*& root)$/;"	f	signature:(__rb_tree_node_base* x, __rb_tree_node_base*& root)
__rb_tree_rebalance_for_erase	stl_tree.h	/^__rb_tree_rebalance_for_erase(__rb_tree_node_base* z,$/;"	f	signature:(__rb_tree_node_base* z, __rb_tree_node_base*& root, __rb_tree_node_base*& leftmost, __rb_tree_node_base*& rightmost)
__rb_tree_red	stl_tree.h	/^const __rb_tree_color_type __rb_tree_red = false;$/;"	v
__rb_tree_rotate_left	stl_tree.h	/^__rb_tree_rotate_left(__rb_tree_node_base* x, __rb_tree_node_base*& root)$/;"	f	signature:(__rb_tree_node_base* x, __rb_tree_node_base*& root)
__rb_tree_rotate_right	stl_tree.h	/^__rb_tree_rotate_right(__rb_tree_node_base* x, __rb_tree_node_base*& root)$/;"	f	signature:(__rb_tree_node_base* x, __rb_tree_node_base*& root)
__rb_verify	stl_tree.h	/^  bool __rb_verify() const;$/;"	p	class:rb_tree	access:public	signature:() const
__rb_verify	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__rb_verify() const$/;"	f	class:rb_tree	signature:() const
__reverse	stl_algo.h	/^void __reverse(BidirectionalIterator first, BidirectionalIterator last, $/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator last, bidirectional_iterator_tag)
__reverse	stl_algo.h	/^void __reverse(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag)
__rope_RopeBase	stl_rope.h	/^struct __rope_RopeBase {$/;"	s
__rope_RopeBase::CAlloc	stl_rope.h	/^    typedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;$/;"	t	struct:__rope_RopeBase	access:public
__rope_RopeBase::DataAlloc	stl_rope.h	/^    typedef simple_alloc<charT, Alloc> DataAlloc;$/;"	t	struct:__rope_RopeBase	access:public
__rope_RopeBase::FAlloc	stl_rope.h	/^    typedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;$/;"	t	struct:__rope_RopeBase	access:public
__rope_RopeBase::LAlloc	stl_rope.h	/^    typedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;$/;"	t	struct:__rope_RopeBase	access:public
__rope_RopeBase::SAlloc	stl_rope.h	/^    typedef simple_alloc<__rope_RopeSubstring<charT,Alloc>, Alloc> SAlloc;$/;"	t	struct:__rope_RopeBase	access:public
__rope_RopeBase::alloc_granularity	stl_rope.h	/^    enum { alloc_granularity = 8 };$/;"	e	enum:__rope_RopeBase::__anon10
__rope_RopeBase::c_string	stl_rope.h	/^    __GC_CONST charT * c_string;$/;"	m	struct:__rope_RopeBase	access:public
__rope_RopeBase::concat	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon9
__rope_RopeBase::decr_refcount	stl_rope.h	/^	    size_t decr_refcount ()$/;"	f	struct:__rope_RopeBase	access:public	signature:()
__rope_RopeBase::decr_refcount	stl_rope.h	/^            size_t decr_refcount ()$/;"	f	struct:__rope_RopeBase	access:public	signature:()
__rope_RopeBase::depth	stl_rope.h	/^    unsigned char depth;$/;"	m	struct:__rope_RopeBase	access:public
__rope_RopeBase::fn_finalization_proc	ropeimpl.h	/^void __rope_RopeBase<charT,Alloc>::fn_finalization_proc(void * tree, void *)$/;"	f	class:__rope_RopeBase	signature:(void * tree, void *)
__rope_RopeBase::fn_finalization_proc	stl_rope.h	/^	  static void fn_finalization_proc(void * tree, void *);$/;"	p	struct:__rope_RopeBase	access:public	signature:(void * tree, void *)
__rope_RopeBase::free_c_string	ropeimpl.h	/^inline void __rope_RopeBase<charT,Alloc>::free_c_string()$/;"	f	class:__rope_RopeBase	signature:()
__rope_RopeBase::free_c_string	stl_rope.h	/^	  void free_c_string();$/;"	p	struct:__rope_RopeBase	access:public	signature:()
__rope_RopeBase::free_if_unref	stl_rope.h	/^	  static void free_if_unref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase	access:public	signature:(__rope_RopeBase* t)
__rope_RopeBase::free_if_unref	stl_rope.h	/^	  static void free_if_unref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase	access:public	signature:(__rope_RopeBase* t)
__rope_RopeBase::free_string	ropeimpl.h	/^inline void __rope_RopeBase<charT,Alloc>::free_string(charT* s, size_t n)$/;"	f	class:__rope_RopeBase	signature:(charT* s, size_t n)
__rope_RopeBase::free_string	stl_rope.h	/^	static void free_string(charT *, size_t len);$/;"	p	struct:__rope_RopeBase	access:public	signature:(charT *, size_t len)
__rope_RopeBase::free_tree	ropeimpl.h	/^void __rope_RopeBase<charT,Alloc>::free_tree()$/;"	f	class:__rope_RopeBase	signature:()
__rope_RopeBase::free_tree	stl_rope.h	/^	  void free_tree();$/;"	p	struct:__rope_RopeBase	access:public	signature:()
__rope_RopeBase::function	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon9
__rope_RopeBase::incr_refcount	stl_rope.h	/^	    void incr_refcount ()$/;"	f	struct:__rope_RopeBase	access:public	signature:()
__rope_RopeBase::incr_refcount	stl_rope.h	/^	void incr_refcount () {}$/;"	f	struct:__rope_RopeBase	access:public	signature:()
__rope_RopeBase::incr_refcount	stl_rope.h	/^            void incr_refcount ()$/;"	f	struct:__rope_RopeBase	access:public	signature:()
__rope_RopeBase::init_refcount_lock	stl_rope.h	/^	    void init_refcount_lock() {$/;"	f	struct:__rope_RopeBase	access:public	signature:()
__rope_RopeBase::init_refcount_lock	stl_rope.h	/^	    void init_refcount_lock() {}$/;"	f	struct:__rope_RopeBase	access:public	signature:()
__rope_RopeBase::is_balanced	stl_rope.h	/^    bool is_balanced:8;$/;"	m	struct:__rope_RopeBase	access:public
__rope_RopeBase::leaf	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon9
__rope_RopeBase::max_rope_depth	stl_rope.h	/^    enum { max_rope_depth = 45 };$/;"	e	enum:__rope_RopeBase::__anon8
__rope_RopeBase::my_rope	stl_rope.h	/^    typedef rope<charT,Alloc> my_rope;$/;"	t	struct:__rope_RopeBase	access:public
__rope_RopeBase::ref	stl_rope.h	/^	  static void ref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase	access:public	signature:(__rope_RopeBase* t)
__rope_RopeBase::ref	stl_rope.h	/^	  static void ref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase	access:public	signature:(__rope_RopeBase* t)
__rope_RopeBase::ref_nonnil	stl_rope.h	/^	  void ref_nonnil() {}$/;"	f	struct:__rope_RopeBase	access:public	signature:()
__rope_RopeBase::ref_nonnil	stl_rope.h	/^	  void ref_nonnil()$/;"	f	struct:__rope_RopeBase	access:public	signature:()
__rope_RopeBase::refcount	stl_rope.h	/^	    long refcount;  	\/\/ InterlockedIncrement wants a long *$/;"	m	struct:__rope_RopeBase	access:public
__rope_RopeBase::refcount	stl_rope.h	/^	    size_t refcount;$/;"	m	struct:__rope_RopeBase	access:public
__rope_RopeBase::refcount_lock	stl_rope.h	/^	    pthread_mutex_t refcount_lock;$/;"	m	struct:__rope_RopeBase	access:public
__rope_RopeBase::rounded_up_size	stl_rope.h	/^    static size_t rounded_up_size(size_t n) {$/;"	f	struct:__rope_RopeBase	access:public	signature:(size_t n)
__rope_RopeBase::size	stl_rope.h	/^    size_t size;$/;"	m	struct:__rope_RopeBase	access:public
__rope_RopeBase::substringfn	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon9
__rope_RopeBase::tag	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	m	struct:__rope_RopeBase	typeref:enum:__rope_RopeBase::__anon9	access:public
__rope_RopeBase::unref	stl_rope.h	/^	  static void unref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase	access:public	signature:(__rope_RopeBase* t)
__rope_RopeBase::unref	stl_rope.h	/^	  static void unref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase	access:public	signature:(__rope_RopeBase* t)
__rope_RopeBase::unref_nonnil	stl_rope.h	/^	  void unref_nonnil() {}$/;"	f	struct:__rope_RopeBase	access:public	signature:()
__rope_RopeBase::unref_nonnil	stl_rope.h	/^	  void unref_nonnil()$/;"	f	struct:__rope_RopeBase	access:public	signature:()
__rope_RopeConcatenation	stl_rope.h	/^struct __rope_RopeConcatenation : public __rope_RopeBase<charT,Alloc> {$/;"	s	inherits:__rope_RopeBase
__rope_RopeConcatenation::left	stl_rope.h	/^    __rope_RopeBase<charT,Alloc>* left;$/;"	m	struct:__rope_RopeConcatenation	access:public
__rope_RopeConcatenation::right	stl_rope.h	/^    __rope_RopeBase<charT,Alloc>* right;$/;"	m	struct:__rope_RopeConcatenation	access:public
__rope_RopeFunction	stl_rope.h	/^struct __rope_RopeFunction : public __rope_RopeBase<charT,Alloc> {$/;"	s	inherits:__rope_RopeBase
__rope_RopeFunction::delete_when_done	stl_rope.h	/^      bool delete_when_done;	\/\/ Char_producer is owned by the$/;"	m	struct:__rope_RopeFunction	access:public
__rope_RopeFunction::fn	stl_rope.h	/^    char_producer<charT>* fn;$/;"	m	struct:__rope_RopeFunction	access:public
__rope_RopeLeaf	stl_rope.h	/^struct __rope_RopeLeaf : public __rope_RopeBase<charT,Alloc> {$/;"	s	inherits:__rope_RopeBase
__rope_RopeLeaf::data	stl_rope.h	/^    __GC_CONST charT* data;     \/* Not necessarily 0 terminated. *\/$/;"	m	struct:__rope_RopeLeaf	access:public
__rope_RopeSubstring	stl_rope.h	/^    __rope_RopeSubstring(__rope_RopeBase<charT,Alloc> * b, size_t s, size_t l) :$/;"	f	struct:__rope_RopeSubstring	access:public	signature:(__rope_RopeBase<charT,Alloc> * b, size_t s, size_t l)
__rope_RopeSubstring	stl_rope.h	/^struct __rope_RopeSubstring: public __rope_RopeFunction<charT,Alloc>,$/;"	s	inherits:__rope_RopeFunction,char_producer
__rope_RopeSubstring::__rope_RopeSubstring	stl_rope.h	/^    __rope_RopeSubstring(__rope_RopeBase<charT,Alloc> * b, size_t s, size_t l) :$/;"	f	struct:__rope_RopeSubstring	access:public	signature:(__rope_RopeBase<charT,Alloc> * b, size_t s, size_t l)
__rope_RopeSubstring::base	stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * base;	\/\/ not 0$/;"	m	struct:__rope_RopeSubstring	access:public
__rope_RopeSubstring::operator ()	stl_rope.h	/^    virtual void operator()(size_t start_pos, size_t req_len,$/;"	f	struct:__rope_RopeSubstring	access:public	signature:(size_t start_pos, size_t req_len, charT *buffer)
__rope_RopeSubstring::start	stl_rope.h	/^    size_t start;$/;"	m	struct:__rope_RopeSubstring	access:public
__rope_RopeSubstring::~__rope_RopeSubstring	stl_rope.h	/^    virtual ~__rope_RopeSubstring() {}$/;"	f	struct:__rope_RopeSubstring	access:public	signature:()
__rope_charT_ptr_proxy	stl_rope.h	/^    __rope_charT_ptr_proxy() {}$/;"	f	class:__rope_charT_ptr_proxy	access:public	signature:()
__rope_charT_ptr_proxy	stl_rope.h	/^    __rope_charT_ptr_proxy(charT * x) : root(0), pos(0) {$/;"	f	class:__rope_charT_ptr_proxy	access:public	signature:(charT * x)
__rope_charT_ptr_proxy	stl_rope.h	/^    __rope_charT_ptr_proxy(const __rope_charT_ptr_proxy & x) :$/;"	f	class:__rope_charT_ptr_proxy	access:public	signature:(const __rope_charT_ptr_proxy & x)
__rope_charT_ptr_proxy	stl_rope.h	/^    __rope_charT_ptr_proxy(const __rope_charT_ref_proxy<charT,Alloc> & x) :$/;"	f	class:__rope_charT_ptr_proxy	access:public	signature:(const __rope_charT_ref_proxy<charT,Alloc> & x)
__rope_charT_ptr_proxy	stl_rope.h	/^class __rope_charT_ptr_proxy {$/;"	c
__rope_charT_ptr_proxy::__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend bool operator== __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_charT_ptr_proxy	access:friend	signature:(const __rope_charT_ptr_proxy<charT,Alloc> & x, const __rope_charT_ptr_proxy<charT,Alloc> & y)
__rope_charT_ptr_proxy::__rope_charT_ptr_proxy	stl_rope.h	/^    __rope_charT_ptr_proxy() {}$/;"	f	class:__rope_charT_ptr_proxy	access:public	signature:()
__rope_charT_ptr_proxy::__rope_charT_ptr_proxy	stl_rope.h	/^    __rope_charT_ptr_proxy(charT * x) : root(0), pos(0) {$/;"	f	class:__rope_charT_ptr_proxy	access:public	signature:(charT * x)
__rope_charT_ptr_proxy::__rope_charT_ptr_proxy	stl_rope.h	/^    __rope_charT_ptr_proxy(const __rope_charT_ptr_proxy & x) :$/;"	f	class:__rope_charT_ptr_proxy	access:public	signature:(const __rope_charT_ptr_proxy & x)
__rope_charT_ptr_proxy::__rope_charT_ptr_proxy	stl_rope.h	/^    __rope_charT_ptr_proxy(const __rope_charT_ref_proxy<charT,Alloc> & x) :$/;"	f	class:__rope_charT_ptr_proxy	access:public	signature:(const __rope_charT_ref_proxy<charT,Alloc> & x)
__rope_charT_ptr_proxy::current	stl_rope.h	/^    charT current;$/;"	m	class:__rope_charT_ptr_proxy	access:private
__rope_charT_ptr_proxy::current_valid	stl_rope.h	/^    bool current_valid;$/;"	m	class:__rope_charT_ptr_proxy	access:private
__rope_charT_ptr_proxy::operator *	stl_rope.h	/^    __rope_charT_ref_proxy<charT,Alloc> operator *() const {$/;"	f	class:__rope_charT_ptr_proxy	access:public	signature:() const
__rope_charT_ptr_proxy::operator =	stl_rope.h	/^    __rope_charT_ptr_proxy& operator= (const __rope_charT_ptr_proxy& x) {$/;"	f	class:__rope_charT_ptr_proxy	access:public	signature:(const __rope_charT_ptr_proxy& x)
__rope_charT_ptr_proxy::pos	stl_rope.h	/^    size_t pos;$/;"	m	class:__rope_charT_ptr_proxy	access:private
__rope_charT_ptr_proxy::root	stl_rope.h	/^    rope<charT,Alloc> * root;     \/\/ The whole rope.$/;"	m	class:__rope_charT_ptr_proxy	access:private
__rope_charT_ref_proxy	stl_rope.h	/^    __rope_charT_ref_proxy(my_rope * r, size_t p) :$/;"	f	class:__rope_charT_ref_proxy	access:public	signature:(my_rope * r, size_t p)
__rope_charT_ref_proxy	stl_rope.h	/^    __rope_charT_ref_proxy(my_rope * r, size_t p,$/;"	f	class:__rope_charT_ref_proxy	access:public	signature:(my_rope * r, size_t p, charT c)
__rope_charT_ref_proxy	stl_rope.h	/^class __rope_charT_ref_proxy {$/;"	c
__rope_charT_ref_proxy::RopeBase	stl_rope.h	/^    typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:__rope_charT_ref_proxy	access:private
__rope_charT_ref_proxy::__rope_charT_ref_proxy	stl_rope.h	/^    __rope_charT_ref_proxy(my_rope * r, size_t p) :$/;"	f	class:__rope_charT_ref_proxy	access:public	signature:(my_rope * r, size_t p)
__rope_charT_ref_proxy::__rope_charT_ref_proxy	stl_rope.h	/^    __rope_charT_ref_proxy(my_rope * r, size_t p,$/;"	f	class:__rope_charT_ref_proxy	access:public	signature:(my_rope * r, size_t p, charT c)
__rope_charT_ref_proxy::current	stl_rope.h	/^    charT current;$/;"	m	class:__rope_charT_ref_proxy	access:private
__rope_charT_ref_proxy::current_valid	stl_rope.h	/^    bool current_valid;$/;"	m	class:__rope_charT_ref_proxy	access:private
__rope_charT_ref_proxy::my_rope	stl_rope.h	/^    typedef rope<charT,Alloc> my_rope;$/;"	t	class:__rope_charT_ref_proxy	access:private
__rope_charT_ref_proxy::operator &	ropeimpl.h	/^__rope_charT_ref_proxy<charT, Alloc>::operator& () const {$/;"	f	class:__rope_charT_ref_proxy	signature:() const
__rope_charT_ref_proxy::operator &	stl_rope.h	/^    __rope_charT_ptr_proxy<charT,Alloc> operator& () const;$/;"	p	class:__rope_charT_ref_proxy	access:public	signature:() const
__rope_charT_ref_proxy::operator =	ropeimpl.h	/^__rope_charT_ref_proxy<charT, Alloc>::operator= (charT c) {$/;"	f	class:__rope_charT_ref_proxy	signature:(charT c)
__rope_charT_ref_proxy::operator =	stl_rope.h	/^    __rope_charT_ref_proxy& operator= (charT c);$/;"	p	class:__rope_charT_ref_proxy	access:public	signature:(charT c)
__rope_charT_ref_proxy::operator =	stl_rope.h	/^    __rope_charT_ref_proxy& operator= (const __rope_charT_ref_proxy& c) {$/;"	f	class:__rope_charT_ref_proxy	access:public	signature:(const __rope_charT_ref_proxy& c)
__rope_charT_ref_proxy::operator charT	ropeimpl.h	/^inline __rope_charT_ref_proxy<charT, Alloc>::operator charT () const$/;"	f	class:__rope_charT_ref_proxy	signature:() const
__rope_charT_ref_proxy::operator charT	stl_rope.h	/^    operator charT () const;$/;"	p	class:__rope_charT_ref_proxy	access:public	signature:() const
__rope_charT_ref_proxy::pos	stl_rope.h	/^    size_t pos;$/;"	m	class:__rope_charT_ref_proxy	access:private
__rope_charT_ref_proxy::root	stl_rope.h	/^    my_rope * root;     \/\/ The whole rope.$/;"	m	class:__rope_charT_ref_proxy	access:private
__rope_charT_ref_proxy::self_destruct_ptr	stl_rope.h	/^	typedef __rope_RopeBase<charT,Alloc> * self_destruct_ptr;$/;"	t	class:__rope_charT_ref_proxy	access:private
__rope_charT_ref_proxy::self_destruct_ptr	stl_rope.h	/^    	typedef __rope_self_destruct_ptr<charT,Alloc> self_destruct_ptr;$/;"	t	class:__rope_charT_ref_proxy	access:private
__rope_char_consumer	stl_rope.h	/^class __rope_char_consumer {$/;"	c
__rope_char_consumer::operator ()	stl_rope.h	/^	virtual bool operator()(const charT* buffer, size_t len) = 0;$/;"	p	class:__rope_char_consumer	access:public	signature:(const charT* buffer, size_t len)
__rope_char_consumer::~__rope_char_consumer	stl_rope.h	/^	virtual ~__rope_char_consumer() {};$/;"	f	class:__rope_char_consumer	access:public	signature:()
__rope_const_iterator	ropeimpl.h	/^inline __rope_const_iterator<charT, Alloc>::__rope_const_iterator$/;"	f	class:__rope_const_iterator	signature:(const __rope_iterator<charT,Alloc> & x)
__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator() {};$/;"	f	class:__rope_const_iterator	access:public	signature:()
__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator(const RopeBase * root, size_t pos):$/;"	f	class:__rope_const_iterator	access:protected	signature:(const RopeBase * root, size_t pos)
__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator(const __rope_const_iterator & x) :$/;"	f	class:__rope_const_iterator	access:public	signature:(const __rope_const_iterator & x)
__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator(const __rope_iterator<charT,Alloc> & x);$/;"	p	class:__rope_const_iterator	access:public	signature:(const __rope_iterator<charT,Alloc> & x)
__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator(const rope<charT,Alloc> &r, size_t pos) :$/;"	f	class:__rope_const_iterator	access:public	signature:(const rope<charT,Alloc> &r, size_t pos)
__rope_const_iterator	stl_rope.h	/^class __rope_const_iterator : public __rope_iterator_base<charT,Alloc> {$/;"	c	inherits:__rope_iterator_base
__rope_const_iterator::__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend __rope_const_iterator<charT,Alloc> operator+ __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_const_iterator	access:friend	signature:(const __rope_const_iterator<charT,Alloc> & x, ptrdiff_t n)
__rope_const_iterator::__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend __rope_const_iterator<charT,Alloc> operator+ __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_const_iterator	access:friend	signature:(ptrdiff_t n, const __rope_const_iterator<charT,Alloc> & x)
__rope_const_iterator::__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend __rope_const_iterator<charT,Alloc> operator- __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_const_iterator	access:friend	signature:(const __rope_const_iterator<charT,Alloc> & x, ptrdiff_t n)
__rope_const_iterator::__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend bool operator< __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_const_iterator	access:friend	signature:(const __rope_const_iterator<charT,Alloc> & x, const __rope_const_iterator<charT,Alloc> & y)
__rope_const_iterator::__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend bool operator== __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_const_iterator	access:friend	signature:(const __rope_const_iterator<charT,Alloc> & x, const __rope_const_iterator<charT,Alloc> & y)
__rope_const_iterator::__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend ptrdiff_t operator- __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_const_iterator	access:friend	signature:(const __rope_const_iterator<charT,Alloc> & x, const __rope_const_iterator<charT,Alloc> & y)
__rope_const_iterator::__rope_const_iterator	ropeimpl.h	/^inline __rope_const_iterator<charT, Alloc>::__rope_const_iterator$/;"	f	class:__rope_const_iterator	signature:(const __rope_iterator<charT,Alloc> & x)
__rope_const_iterator::__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator() {};$/;"	f	class:__rope_const_iterator	access:public	signature:()
__rope_const_iterator::__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator(const RopeBase * root, size_t pos):$/;"	f	class:__rope_const_iterator	access:protected	signature:(const RopeBase * root, size_t pos)
__rope_const_iterator::__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator(const __rope_const_iterator & x) :$/;"	f	class:__rope_const_iterator	access:public	signature:(const __rope_const_iterator & x)
__rope_const_iterator::__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator(const __rope_iterator<charT,Alloc> & x);$/;"	p	class:__rope_const_iterator	access:public	signature:(const __rope_iterator<charT,Alloc> & x)
__rope_const_iterator::__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator(const rope<charT,Alloc> &r, size_t pos) :$/;"	f	class:__rope_const_iterator	access:public	signature:(const rope<charT,Alloc> &r, size_t pos)
__rope_const_iterator::operator *	stl_rope.h	/^    reference operator*() {$/;"	f	class:__rope_const_iterator	access:public	signature:()
__rope_const_iterator::operator ++	stl_rope.h	/^    __rope_const_iterator operator++(int) {$/;"	f	class:__rope_const_iterator	access:public	signature:(int)
__rope_const_iterator::operator ++	stl_rope.h	/^    __rope_const_iterator& operator++() {$/;"	f	class:__rope_const_iterator	access:public	signature:()
__rope_const_iterator::operator +=	stl_rope.h	/^    __rope_const_iterator& operator+=(ptrdiff_t n) {$/;"	f	class:__rope_const_iterator	access:public	signature:(ptrdiff_t n)
__rope_const_iterator::operator --	stl_rope.h	/^    __rope_const_iterator operator--(int) {$/;"	f	class:__rope_const_iterator	access:public	signature:(int)
__rope_const_iterator::operator --	stl_rope.h	/^    __rope_const_iterator& operator--() {$/;"	f	class:__rope_const_iterator	access:public	signature:()
__rope_const_iterator::operator -=	stl_rope.h	/^    __rope_const_iterator& operator-=(ptrdiff_t n) {$/;"	f	class:__rope_const_iterator	access:public	signature:(ptrdiff_t n)
__rope_const_iterator::operator =	stl_rope.h	/^    __rope_const_iterator& operator= (const __rope_const_iterator & x) {$/;"	f	class:__rope_const_iterator	access:public	signature:(const __rope_const_iterator & x)
__rope_const_iterator::operator []	stl_rope.h	/^    reference operator[](size_t n) {$/;"	f	class:__rope_const_iterator	access:public	signature:(size_t n)
__rope_const_iterator::pointer	stl_rope.h	/^    typedef const charT* pointer;$/;"	t	class:__rope_const_iterator	access:public
__rope_const_iterator::reference	stl_rope.h	/^    typedef charT reference;    \/\/ Really a value.  Returning a reference$/;"	t	class:__rope_const_iterator	access:public
__rope_fill	ropeimpl.h	/^inline void __rope_fill(ostream& o, size_t n)$/;"	f	signature:(ostream& o, size_t n)
__rope_find_char_char_consumer	ropeimpl.h	/^	__rope_find_char_char_consumer(charT p) : pattern(p), count(0) {}$/;"	f	class:__rope_find_char_char_consumer	access:public	signature:(charT p)
__rope_find_char_char_consumer	ropeimpl.h	/^class __rope_find_char_char_consumer : public __rope_char_consumer<charT> {$/;"	c	inherits:__rope_char_consumer
__rope_find_char_char_consumer::__rope_find_char_char_consumer	ropeimpl.h	/^	__rope_find_char_char_consumer(charT p) : pattern(p), count(0) {}$/;"	f	class:__rope_find_char_char_consumer	access:public	signature:(charT p)
__rope_find_char_char_consumer::count	ropeimpl.h	/^	size_t count;  \/\/ Number of nonmatching characters$/;"	m	class:__rope_find_char_char_consumer	access:public
__rope_find_char_char_consumer::operator ()	ropeimpl.h	/^	bool operator() (const charT* leaf, size_t n) {$/;"	f	class:__rope_find_char_char_consumer	access:public	signature:(const charT* leaf, size_t n)
__rope_find_char_char_consumer::pattern	ropeimpl.h	/^	charT pattern;$/;"	m	class:__rope_find_char_char_consumer	access:private
__rope_find_char_char_consumer::~__rope_find_char_char_consumer	ropeimpl.h	/^	~__rope_find_char_char_consumer() {}$/;"	f	class:__rope_find_char_char_consumer	access:public	signature:()
__rope_flatten_char_consumer	ropeimpl.h	/^	__rope_flatten_char_consumer(charT * buffer) {$/;"	f	class:__rope_flatten_char_consumer	access:public	signature:(charT * buffer)
__rope_flatten_char_consumer	ropeimpl.h	/^class __rope_flatten_char_consumer : public __rope_char_consumer<charT> {$/;"	c	inherits:__rope_char_consumer
__rope_flatten_char_consumer::__rope_flatten_char_consumer	ropeimpl.h	/^	__rope_flatten_char_consumer(charT * buffer) {$/;"	f	class:__rope_flatten_char_consumer	access:public	signature:(charT * buffer)
__rope_flatten_char_consumer::buf_ptr	ropeimpl.h	/^	charT * buf_ptr;$/;"	m	class:__rope_flatten_char_consumer	access:private
__rope_flatten_char_consumer::buffer	ropeimpl.h	/^	charT * buffer;$/;"	m	class:__rope_flatten_char_consumer	access:public
__rope_flatten_char_consumer::operator ()	ropeimpl.h	/^	bool operator() (const charT* leaf, size_t n) {$/;"	f	class:__rope_flatten_char_consumer	access:public	signature:(const charT* leaf, size_t n)
__rope_flatten_char_consumer::~__rope_flatten_char_consumer	ropeimpl.h	/^	~__rope_flatten_char_consumer() {}$/;"	f	class:__rope_flatten_char_consumer	access:public	signature:()
__rope_insert_char_consumer	ropeimpl.h	/^	__rope_insert_char_consumer(insert_ostream & writer) : o(writer) {};$/;"	f	class:__rope_insert_char_consumer	access:public	signature:(insert_ostream & writer)
__rope_insert_char_consumer	ropeimpl.h	/^class __rope_insert_char_consumer : public __rope_char_consumer<charT> {$/;"	c	inherits:__rope_char_consumer
__rope_insert_char_consumer::__rope_insert_char_consumer	ropeimpl.h	/^	__rope_insert_char_consumer(insert_ostream & writer) : o(writer) {};$/;"	f	class:__rope_insert_char_consumer	access:public	signature:(insert_ostream & writer)
__rope_insert_char_consumer::buffer	ropeimpl.h	/^	charT * buffer;$/;"	m	class:__rope_insert_char_consumer	access:public
__rope_insert_char_consumer::insert_ostream	ropeimpl.h	/^	typedef ostream insert_ostream;$/;"	t	class:__rope_insert_char_consumer	access:private
__rope_insert_char_consumer::o	ropeimpl.h	/^	insert_ostream & o;$/;"	m	class:__rope_insert_char_consumer	access:private
__rope_insert_char_consumer::operator ()	ropeimpl.h	/^	bool operator() (const charT* leaf, size_t n);$/;"	p	class:__rope_insert_char_consumer	access:public	signature:(const charT* leaf, size_t n)
__rope_insert_char_consumer::operator ()	ropeimpl.h	/^bool __rope_insert_char_consumer<charT>::operator()$/;"	f	class:__rope_insert_char_consumer	signature:(const charT * leaf, size_t n)
__rope_insert_char_consumer::operator ()	ropeimpl.h	/^inline bool __rope_insert_char_consumer<char>::operator()$/;"	f	class:__rope_insert_char_consumer	signature:(const char * leaf, size_t n)
__rope_insert_char_consumer::operator ()	ropeimpl.h	/^inline bool __rope_insert_char_consumer<wchar_t>::operator()$/;"	f	class:__rope_insert_char_consumer	signature:(const wchar_t * leaf, size_t n)
__rope_insert_char_consumer::~__rope_insert_char_consumer	ropeimpl.h	/^	~__rope_insert_char_consumer() { };$/;"	f	class:__rope_insert_char_consumer	access:public	signature:()
__rope_is_simple	ropeimpl.h	/^inline bool __rope_is_simple(char *) { return true; }$/;"	f	signature:(char *)
__rope_is_simple	ropeimpl.h	/^inline bool __rope_is_simple(wchar_t *) { return true; }$/;"	f	signature:(wchar_t *)
__rope_is_simple	ropeimpl.h	/^template <class charT> inline bool __rope_is_simple(charT *) { return false; }$/;"	f	signature:(charT *)
__rope_iterator	ropeimpl.h	/^inline __rope_iterator<charT,Alloc>::__rope_iterator$/;"	f	class:__rope_iterator	signature:(rope<charT,Alloc>& r, size_t pos)
__rope_iterator	stl_rope.h	/^    __rope_iterator() {$/;"	f	class:__rope_iterator	access:public	signature:()
__rope_iterator	stl_rope.h	/^    __rope_iterator(const __rope_iterator & x) :$/;"	f	class:__rope_iterator	access:public	signature:(const __rope_iterator & x)
__rope_iterator	stl_rope.h	/^    __rope_iterator(rope<charT,Alloc> * r, size_t pos):$/;"	f	class:__rope_iterator	access:protected	signature:(rope<charT,Alloc> * r, size_t pos)
__rope_iterator	stl_rope.h	/^    __rope_iterator(rope<charT,Alloc>& r, size_t pos);$/;"	p	class:__rope_iterator	access:public	signature:(rope<charT,Alloc>& r, size_t pos)
__rope_iterator	stl_rope.h	/^class __rope_iterator : public __rope_iterator_base<charT,Alloc> {$/;"	c	inherits:__rope_iterator_base
__rope_iterator::__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend __rope_iterator<charT,Alloc> operator+ __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_iterator	access:friend	signature:(const __rope_iterator<charT,Alloc> & x, ptrdiff_t n)
__rope_iterator::__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend __rope_iterator<charT,Alloc> operator+ __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_iterator	access:friend	signature:(ptrdiff_t n, const __rope_iterator<charT,Alloc> & x)
__rope_iterator::__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend __rope_iterator<charT,Alloc> operator- __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_iterator	access:friend	signature:(const __rope_iterator<charT,Alloc> & x, ptrdiff_t n)
__rope_iterator::__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend bool operator< __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_iterator	access:friend	signature:(const __rope_iterator<charT,Alloc> & x, const __rope_iterator<charT,Alloc> & y)
__rope_iterator::__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend bool operator== __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_iterator	access:friend	signature:(const __rope_iterator<charT,Alloc> & x, const __rope_iterator<charT,Alloc> & y)
__rope_iterator::__STL_NULL_TMPL_ARGS	stl_rope.h	/^    friend ptrdiff_t operator- __STL_NULL_TMPL_ARGS$/;"	p	class:__rope_iterator	access:friend	signature:(const __rope_iterator<charT,Alloc> & x, const __rope_iterator<charT,Alloc> & y)
__rope_iterator::__rope_iterator	ropeimpl.h	/^inline __rope_iterator<charT,Alloc>::__rope_iterator$/;"	f	class:__rope_iterator	signature:(rope<charT,Alloc>& r, size_t pos)
__rope_iterator::__rope_iterator	stl_rope.h	/^    __rope_iterator() {$/;"	f	class:__rope_iterator	access:public	signature:()
__rope_iterator::__rope_iterator	stl_rope.h	/^    __rope_iterator(const __rope_iterator & x) :$/;"	f	class:__rope_iterator	access:public	signature:(const __rope_iterator & x)
__rope_iterator::__rope_iterator	stl_rope.h	/^    __rope_iterator(rope<charT,Alloc> * r, size_t pos):$/;"	f	class:__rope_iterator	access:protected	signature:(rope<charT,Alloc> * r, size_t pos)
__rope_iterator::__rope_iterator	stl_rope.h	/^    __rope_iterator(rope<charT,Alloc>& r, size_t pos);$/;"	p	class:__rope_iterator	access:public	signature:(rope<charT,Alloc>& r, size_t pos)
__rope_iterator::check	ropeimpl.h	/^void __rope_iterator<charT,Alloc>::check() {$/;"	f	class:__rope_iterator	signature:()
__rope_iterator::check	stl_rope.h	/^    void check();$/;"	p	class:__rope_iterator	access:protected	signature:()
__rope_iterator::container	stl_rope.h	/^    rope<charT,Alloc>& container() { return *root_rope; }$/;"	f	class:__rope_iterator	access:public	signature:()
__rope_iterator::operator *	stl_rope.h	/^    reference operator*() {$/;"	f	class:__rope_iterator	access:public	signature:()
__rope_iterator::operator ++	stl_rope.h	/^    __rope_iterator operator++(int) {$/;"	f	class:__rope_iterator	access:public	signature:(int)
__rope_iterator::operator ++	stl_rope.h	/^    __rope_iterator& operator++() {$/;"	f	class:__rope_iterator	access:public	signature:()
__rope_iterator::operator +=	stl_rope.h	/^    __rope_iterator& operator+=(difference_type n) {$/;"	f	class:__rope_iterator	access:public	signature:(difference_type n)
__rope_iterator::operator --	stl_rope.h	/^    __rope_iterator operator--(int) {$/;"	f	class:__rope_iterator	access:public	signature:(int)
__rope_iterator::operator --	stl_rope.h	/^    __rope_iterator& operator--() {$/;"	f	class:__rope_iterator	access:public	signature:()
__rope_iterator::operator -=	stl_rope.h	/^    __rope_iterator& operator-=(difference_type n) {$/;"	f	class:__rope_iterator	access:public	signature:(difference_type n)
__rope_iterator::operator =	stl_rope.h	/^    __rope_iterator& operator= (const __rope_iterator & x) {$/;"	f	class:__rope_iterator	access:public	signature:(const __rope_iterator & x)
__rope_iterator::operator []	stl_rope.h	/^    reference operator[](ptrdiff_t n) {$/;"	f	class:__rope_iterator	access:public	signature:(ptrdiff_t n)
__rope_iterator::pointer	stl_rope.h	/^    typedef __rope_charT_ref_proxy<charT,Alloc>* pointer;$/;"	t	class:__rope_iterator	access:public
__rope_iterator::reference	stl_rope.h	/^    typedef __rope_charT_ref_proxy<charT,Alloc>  reference;$/;"	t	class:__rope_iterator	access:public
__rope_iterator::root_rope	stl_rope.h	/^    rope<charT,Alloc> * root_rope;$/;"	m	class:__rope_iterator	access:protected
__rope_iterator::~__rope_iterator	stl_rope.h	/^    ~__rope_iterator() {$/;"	f	class:__rope_iterator	access:public	signature:()
__rope_iterator_base	stl_rope.h	/^    __rope_iterator_base() {}$/;"	f	class:__rope_iterator_base	access:protected	signature:()
__rope_iterator_base	stl_rope.h	/^    __rope_iterator_base(RopeBase * root, size_t pos):$/;"	f	class:__rope_iterator_base	access:protected	signature:(RopeBase * root, size_t pos)
__rope_iterator_base	stl_rope.h	/^    __rope_iterator_base(const __rope_iterator_base& x) {$/;"	f	class:__rope_iterator_base	access:protected	signature:(const __rope_iterator_base& x)
__rope_iterator_base	stl_rope.h	/^class __rope_iterator_base:$/;"	c	inherits:random_access_iterator
__rope_iterator_base::RopeBase	stl_rope.h	/^    typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:__rope_iterator_base	access:public
__rope_iterator_base::__rope_iterator_base	stl_rope.h	/^    __rope_iterator_base() {}$/;"	f	class:__rope_iterator_base	access:protected	signature:()
__rope_iterator_base::__rope_iterator_base	stl_rope.h	/^    __rope_iterator_base(RopeBase * root, size_t pos):$/;"	f	class:__rope_iterator_base	access:protected	signature:(RopeBase * root, size_t pos)
__rope_iterator_base::__rope_iterator_base	stl_rope.h	/^    __rope_iterator_base(const __rope_iterator_base& x) {$/;"	f	class:__rope_iterator_base	access:protected	signature:(const __rope_iterator_base& x)
__rope_iterator_base::buf_end	stl_rope.h	/^    __GC_CONST charT * buf_end;$/;"	m	class:__rope_iterator_base	access:protected
__rope_iterator_base::buf_ptr	stl_rope.h	/^    __GC_CONST charT * buf_ptr;$/;"	m	class:__rope_iterator_base	access:protected
__rope_iterator_base::buf_start	stl_rope.h	/^    __GC_CONST charT * buf_start;$/;"	m	class:__rope_iterator_base	access:protected
__rope_iterator_base::current_pos	stl_rope.h	/^    size_t current_pos;$/;"	m	class:__rope_iterator_base	access:protected
__rope_iterator_base::decr	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::decr(size_t n) {$/;"	f	class:__rope_iterator_base	signature:(size_t n)
__rope_iterator_base::decr	stl_rope.h	/^    void decr(size_t n);$/;"	p	class:__rope_iterator_base	access:protected	signature:(size_t n)
__rope_iterator_base::incr	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::incr(size_t n) {$/;"	f	class:__rope_iterator_base	signature:(size_t n)
__rope_iterator_base::incr	stl_rope.h	/^    void incr(size_t n);$/;"	p	class:__rope_iterator_base	access:protected	signature:(size_t n)
__rope_iterator_base::index	stl_rope.h	/^    size_t index() const { return current_pos; }$/;"	f	class:__rope_iterator_base	access:public	signature:() const
__rope_iterator_base::iterator_buf_len	stl_rope.h	/^    enum { iterator_buf_len = 15 };$/;"	e	enum:__rope_iterator_base::__anon12
__rope_iterator_base::leaf_index	stl_rope.h	/^    int leaf_index;     \/\/ Last valid pos in path_end;$/;"	m	class:__rope_iterator_base	access:protected
__rope_iterator_base::leaf_pos	stl_rope.h	/^    size_t leaf_pos;    \/\/ Starting position for current leaf$/;"	m	class:__rope_iterator_base	access:protected
__rope_iterator_base::path_cache_len	stl_rope.h	/^    enum { path_cache_len = 4 }; \/\/ Must be <= 9.$/;"	e	enum:__rope_iterator_base::__anon11
__rope_iterator_base::path_directions	stl_rope.h	/^    unsigned char path_directions;$/;"	m	class:__rope_iterator_base	access:protected
__rope_iterator_base::path_end	stl_rope.h	/^    const RopeBase * path_end[path_cache_len];$/;"	m	class:__rope_iterator_base	access:protected
__rope_iterator_base::root	stl_rope.h	/^    RopeBase * root;     \/\/ The whole rope.$/;"	m	class:__rope_iterator_base	access:protected
__rope_iterator_base::setbuf	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setbuf$/;"	f	class:__rope_iterator_base	signature:(__rope_iterator_base<charT,Alloc> &x)
__rope_iterator_base::setbuf	stl_rope.h	/^    static void setbuf(__rope_iterator_base &x);$/;"	p	class:__rope_iterator_base	access:protected	signature:(__rope_iterator_base &x)
__rope_iterator_base::setcache	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setcache$/;"	f	class:__rope_iterator_base	signature:(__rope_iterator_base<charT,Alloc> &x)
__rope_iterator_base::setcache	stl_rope.h	/^    static void setcache(__rope_iterator_base &x);$/;"	p	class:__rope_iterator_base	access:protected	signature:(__rope_iterator_base &x)
__rope_iterator_base::setcache_for_incr	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setcache_for_incr$/;"	f	class:__rope_iterator_base	signature:(__rope_iterator_base<charT,Alloc> &x)
__rope_iterator_base::setcache_for_incr	stl_rope.h	/^    static void setcache_for_incr(__rope_iterator_base &x);$/;"	p	class:__rope_iterator_base	access:protected	signature:(__rope_iterator_base &x)
__rope_iterator_base::tmp_buf	stl_rope.h	/^    charT tmp_buf[iterator_buf_len];$/;"	m	class:__rope_iterator_base	access:protected
__rope_rotate	ropeimpl.h	/^__rope_rotate(__rope_iterator<charT,Alloc> first,$/;"	f	signature:(__rope_iterator<charT,Alloc> first, __rope_iterator<charT,Alloc> middle, __rope_iterator<charT,Alloc> last)
__rope_self_destruct_ptr	stl_rope.h	/^	__rope_self_destruct_ptr() : ptr(0) {};$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:()
__rope_self_destruct_ptr	stl_rope.h	/^	__rope_self_destruct_ptr() {};$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:()
__rope_self_destruct_ptr	stl_rope.h	/^    __rope_self_destruct_ptr(__rope_RopeBase<charT,Alloc> * p) : ptr(p) {}$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:(__rope_RopeBase<charT,Alloc> * p)
__rope_self_destruct_ptr	stl_rope.h	/^  struct __rope_self_destruct_ptr {$/;"	s
__rope_self_destruct_ptr::__rope_self_destruct_ptr	stl_rope.h	/^	__rope_self_destruct_ptr() : ptr(0) {};$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:()
__rope_self_destruct_ptr::__rope_self_destruct_ptr	stl_rope.h	/^	__rope_self_destruct_ptr() {};$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:()
__rope_self_destruct_ptr::__rope_self_destruct_ptr	stl_rope.h	/^    __rope_self_destruct_ptr(__rope_RopeBase<charT,Alloc> * p) : ptr(p) {}$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:(__rope_RopeBase<charT,Alloc> * p)
__rope_self_destruct_ptr::operator *	stl_rope.h	/^    __rope_RopeBase<charT,Alloc> & operator*() { return *ptr; }$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:()
__rope_self_destruct_ptr::operator ->	stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * operator->() { return ptr; }$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:()
__rope_self_destruct_ptr::operator =	stl_rope.h	/^    __rope_self_destruct_ptr & operator= (__rope_RopeBase<charT,Alloc> * x)$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:(__rope_RopeBase<charT,Alloc> * x)
__rope_self_destruct_ptr::operator __rope_RopeBase<charT,Alloc> *	stl_rope.h	/^    operator __rope_RopeBase<charT,Alloc> *() { return ptr; }$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:()
__rope_self_destruct_ptr::ptr	stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * ptr;$/;"	m	struct:__rope_self_destruct_ptr	access:public
__rope_self_destruct_ptr::~__rope_self_destruct_ptr	stl_rope.h	/^    ~__rope_self_destruct_ptr() { __rope_RopeBase<charT,Alloc>::unref(ptr); }$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:()
__rotate	stl_algo.h	/^void __rotate(BidirectionalIterator first, BidirectionalIterator middle,$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Distance*, bidirectional_iterator_tag)
__rotate	stl_algo.h	/^void __rotate(ForwardIterator first, ForwardIterator middle,$/;"	f	signature:(ForwardIterator first, ForwardIterator middle, ForwardIterator last, Distance*, forward_iterator_tag)
__rotate	stl_algo.h	/^void __rotate(RandomAccessIterator first, RandomAccessIterator middle,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Distance*, random_access_iterator_tag)
__rotate_adaptive	stl_algo.h	/^BidirectionalIterator1 __rotate_adaptive(BidirectionalIterator1 first,$/;"	f	signature:(BidirectionalIterator1 first, BidirectionalIterator1 middle, BidirectionalIterator1 last, Distance len1, Distance len2, BidirectionalIterator2 buffer, Distance buffer_size)
__rotate_cycle	stl_algo.h	/^void __rotate_cycle(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, RandomAccessIterator initial, Distance shift, T*)
__search	stl_algo.h	/^ForwardIterator1 __search(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f	signature:(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate binary_pred, Distance1*, Distance2*)
__search	stl_algo.h	/^ForwardIterator1 __search(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f	signature:(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, Distance1*, Distance2*)
__slist_iterator	stl_slist.h	/^  __slist_iterator() : __slist_iterator_base(0) {}$/;"	f	struct:__slist_iterator	access:public	signature:()
__slist_iterator	stl_slist.h	/^  __slist_iterator(const iterator& x) : __slist_iterator_base(x.node) {}$/;"	f	struct:__slist_iterator	access:public	signature:(const iterator& x)
__slist_iterator	stl_slist.h	/^  __slist_iterator(list_node* x) : __slist_iterator_base(x) {}$/;"	f	struct:__slist_iterator	access:public	signature:(list_node* x)
__slist_iterator	stl_slist.h	/^struct __slist_iterator : public __slist_iterator_base$/;"	s	inherits:__slist_iterator_base
__slist_iterator::__slist_iterator	stl_slist.h	/^  __slist_iterator() : __slist_iterator_base(0) {}$/;"	f	struct:__slist_iterator	access:public	signature:()
__slist_iterator::__slist_iterator	stl_slist.h	/^  __slist_iterator(const iterator& x) : __slist_iterator_base(x.node) {}$/;"	f	struct:__slist_iterator	access:public	signature:(const iterator& x)
__slist_iterator::__slist_iterator	stl_slist.h	/^  __slist_iterator(list_node* x) : __slist_iterator_base(x) {}$/;"	f	struct:__slist_iterator	access:public	signature:(list_node* x)
__slist_iterator::const_iterator	stl_slist.h	/^  typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:__slist_iterator	access:public
__slist_iterator::iterator	stl_slist.h	/^  typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	struct:__slist_iterator	access:public
__slist_iterator::list_node	stl_slist.h	/^  typedef __slist_node<T> list_node;$/;"	t	struct:__slist_iterator	access:public
__slist_iterator::operator *	stl_slist.h	/^  reference operator*() const { return ((list_node*) node)->data; }$/;"	f	struct:__slist_iterator	access:public	signature:() const
__slist_iterator::operator ++	stl_slist.h	/^  self operator++(int)$/;"	f	struct:__slist_iterator	access:public	signature:(int)
__slist_iterator::operator ++	stl_slist.h	/^  self& operator++()$/;"	f	struct:__slist_iterator	access:public	signature:()
__slist_iterator::operator ->	stl_slist.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__slist_iterator	access:public	signature:() const
__slist_iterator::pointer	stl_slist.h	/^  typedef Ptr pointer;$/;"	t	struct:__slist_iterator	access:public
__slist_iterator::reference	stl_slist.h	/^  typedef Ref reference;$/;"	t	struct:__slist_iterator	access:public
__slist_iterator::self	stl_slist.h	/^  typedef __slist_iterator<T, Ref, Ptr>           self;$/;"	t	struct:__slist_iterator	access:public
__slist_iterator::value_type	stl_slist.h	/^  typedef T value_type;$/;"	t	struct:__slist_iterator	access:public
__slist_iterator_base	stl_slist.h	/^  __slist_iterator_base(__slist_node_base* x) : node(x) {}$/;"	f	struct:__slist_iterator_base	access:public	signature:(__slist_node_base* x)
__slist_iterator_base	stl_slist.h	/^struct __slist_iterator_base$/;"	s
__slist_iterator_base::__slist_iterator_base	stl_slist.h	/^  __slist_iterator_base(__slist_node_base* x) : node(x) {}$/;"	f	struct:__slist_iterator_base	access:public	signature:(__slist_node_base* x)
__slist_iterator_base::difference_type	stl_slist.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__slist_iterator_base	access:public
__slist_iterator_base::incr	stl_slist.h	/^  void incr() { node = node->next; }$/;"	f	struct:__slist_iterator_base	access:public	signature:()
__slist_iterator_base::iterator_category	stl_slist.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__slist_iterator_base	access:public
__slist_iterator_base::node	stl_slist.h	/^  __slist_node_base* node;$/;"	m	struct:__slist_iterator_base	access:public
__slist_iterator_base::operator !=	stl_slist.h	/^  bool operator!=(const __slist_iterator_base& x) const {$/;"	f	struct:__slist_iterator_base	access:public	signature:(const __slist_iterator_base& x) const
__slist_iterator_base::operator ==	stl_slist.h	/^  bool operator==(const __slist_iterator_base& x) const {$/;"	f	struct:__slist_iterator_base	access:public	signature:(const __slist_iterator_base& x) const
__slist_iterator_base::size_type	stl_slist.h	/^  typedef size_t size_type;$/;"	t	struct:__slist_iterator_base	access:public
__slist_make_link	stl_slist.h	/^inline __slist_node_base* __slist_make_link(__slist_node_base* prev_node,$/;"	f	signature:(__slist_node_base* prev_node, __slist_node_base* new_node)
__slist_node	stl_slist.h	/^struct __slist_node : public __slist_node_base$/;"	s	inherits:__slist_node_base
__slist_node::data	stl_slist.h	/^  T data;$/;"	m	struct:__slist_node	access:public
__slist_node_base	stl_slist.h	/^struct __slist_node_base$/;"	s
__slist_node_base::next	stl_slist.h	/^  __slist_node_base* next;$/;"	m	struct:__slist_node_base	access:public
__slist_previous	stl_slist.h	/^inline __slist_node_base* __slist_previous(__slist_node_base* head,$/;"	f	signature:(__slist_node_base* head, const __slist_node_base* node)
__slist_previous	stl_slist.h	/^inline const __slist_node_base* __slist_previous(const __slist_node_base* head,$/;"	f	signature:(const __slist_node_base* head, const __slist_node_base* node)
__slist_reverse	stl_slist.h	/^inline __slist_node_base* __slist_reverse(__slist_node_base* node)$/;"	f	signature:(__slist_node_base* node)
__slist_size	stl_slist.h	/^inline size_t __slist_size(__slist_node_base* node)$/;"	f	signature:(__slist_node_base* node)
__slist_splice_after	stl_slist.h	/^inline void __slist_splice_after(__slist_node_base* pos,$/;"	f	signature:(__slist_node_base* pos, __slist_node_base* before_first, __slist_node_base* before_last)
__stable_partition_adaptive	stl_algo.h	/^ForwardIterator __stable_partition_adaptive(ForwardIterator first,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, Predicate pred, Distance len, Pointer buffer, Distance buffer_size)
__stable_partition_aux	stl_algo.h	/^inline ForwardIterator __stable_partition_aux(ForwardIterator first,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, Predicate pred, T*, Distance*)
__stable_sort_adaptive	stl_algo.h	/^void __stable_sort_adaptive(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Pointer buffer, Distance buffer_size)
__stable_sort_adaptive	stl_algo.h	/^void __stable_sort_adaptive(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Pointer buffer, Distance buffer_size, Compare comp)
__stable_sort_aux	stl_algo.h	/^inline void __stable_sort_aux(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, T*, Distance*)
__stable_sort_aux	stl_algo.h	/^inline void __stable_sort_aux(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, T*, Distance*, Compare comp)
__stl_assert	stl_config.h	232;"	d
__stl_assert	stl_config.h	236;"	d
__stl_chunk_size	stl_algo.h	/^const int __stl_chunk_size = 7;$/;"	v
__stl_hash_string	stl_hash_fun.h	/^inline size_t __stl_hash_string(const char* s)$/;"	f	signature:(const char* s)
__stl_next_prime	stl_hashtable.h	/^inline unsigned long __stl_next_prime(unsigned long n)$/;"	f	signature:(unsigned long n)
__stl_num_primes	stl_hashtable.h	/^static const int __stl_num_primes = 28;$/;"	v
__stl_prime_list	stl_hashtable.h	/^static const unsigned long __stl_prime_list[__stl_num_primes] =$/;"	v
__stl_threshold	stl_algo.h	/^const int __stl_threshold = 16;$/;"	v
__test_and_set	stl_alloc.h	590;"	d
__true_type	type_traits.h	/^struct __true_type {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<char> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<double> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<float> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<int> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<long double> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<long> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<short> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<signed char> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<unsigned char> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<unsigned int> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<unsigned long> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<unsigned short> {$/;"	s
__type_traits	type_traits.h	/^struct __type_traits { $/;"	s
__type_traits	type_traits.h	/^struct __type_traits<T*> {$/;"	s
__type_traits	type_traits.h	/^struct __type_traits<char*> {$/;"	s
__type_traits	type_traits.h	/^struct __type_traits<signed char*> {$/;"	s
__type_traits	type_traits.h	/^struct __type_traits<unsigned char*> {$/;"	s
__type_traits::has_trivial_assignment_operator	type_traits.h	/^   typedef __false_type    has_trivial_assignment_operator;$/;"	t	struct:__type_traits	access:public
__type_traits::has_trivial_assignment_operator	type_traits.h	/^   typedef __true_type    has_trivial_assignment_operator;$/;"	t	struct:__type_traits	access:public
__type_traits::has_trivial_copy_constructor	type_traits.h	/^   typedef __false_type    has_trivial_copy_constructor;$/;"	t	struct:__type_traits	access:public
__type_traits::has_trivial_copy_constructor	type_traits.h	/^   typedef __true_type    has_trivial_copy_constructor;$/;"	t	struct:__type_traits	access:public
__type_traits::has_trivial_default_constructor	type_traits.h	/^   typedef __false_type    has_trivial_default_constructor;$/;"	t	struct:__type_traits	access:public
__type_traits::has_trivial_default_constructor	type_traits.h	/^   typedef __true_type    has_trivial_default_constructor;$/;"	t	struct:__type_traits	access:public
__type_traits::has_trivial_destructor	type_traits.h	/^   typedef __false_type    has_trivial_destructor;$/;"	t	struct:__type_traits	access:public
__type_traits::has_trivial_destructor	type_traits.h	/^   typedef __true_type    has_trivial_destructor;$/;"	t	struct:__type_traits	access:public
__type_traits::is_POD_type	type_traits.h	/^   typedef __false_type    is_POD_type;$/;"	t	struct:__type_traits	access:public
__type_traits::is_POD_type	type_traits.h	/^   typedef __true_type    is_POD_type;$/;"	t	struct:__type_traits	access:public
__type_traits::this_dummy_member_must_be_first	type_traits.h	/^   typedef __true_type     this_dummy_member_must_be_first;$/;"	t	struct:__type_traits	access:public
__unguarded_insertion_sort	stl_algo.h	/^inline void __unguarded_insertion_sort(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last)
__unguarded_insertion_sort	stl_algo.h	/^inline void __unguarded_insertion_sort(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
__unguarded_insertion_sort_aux	stl_algo.h	/^void __unguarded_insertion_sort_aux(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, T*)
__unguarded_insertion_sort_aux	stl_algo.h	/^void __unguarded_insertion_sort_aux(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, T*, Compare comp)
__unguarded_linear_insert	stl_algo.h	/^void __unguarded_linear_insert(RandomAccessIterator last, T value) {$/;"	f	signature:(RandomAccessIterator last, T value)
__unguarded_linear_insert	stl_algo.h	/^void __unguarded_linear_insert(RandomAccessIterator last, T value, $/;"	f	signature:(RandomAccessIterator last, T value, Compare comp)
__unguarded_partition	stl_algo.h	/^RandomAccessIterator __unguarded_partition(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, T pivot)
__unguarded_partition	stl_algo.h	/^RandomAccessIterator __unguarded_partition(RandomAccessIterator first, $/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, T pivot, Compare comp)
__uninitialized_copy	stl_uninitialized.h	/^__uninitialized_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, ForwardIterator result, T*)
__uninitialized_copy_aux	stl_uninitialized.h	/^__uninitialized_copy_aux(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, ForwardIterator result, __false_type)
__uninitialized_copy_aux	stl_uninitialized.h	/^__uninitialized_copy_aux(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, ForwardIterator result, __true_type)
__uninitialized_copy_copy	stl_uninitialized.h	/^__uninitialized_copy_copy(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, ForwardIterator result)
__uninitialized_copy_fill	stl_uninitialized.h	/^__uninitialized_copy_fill(InputIterator first1, InputIterator last1,$/;"	f	signature:(InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, const T& x)
__uninitialized_copy_n	stl_uninitialized.h	/^__uninitialized_copy_n(InputIterator first, Size count,$/;"	f	signature:(InputIterator first, Size count, ForwardIterator result, input_iterator_tag)
__uninitialized_copy_n	stl_uninitialized.h	/^__uninitialized_copy_n(RandomAccessIterator first, Size count,$/;"	f	signature:(RandomAccessIterator first, Size count, ForwardIterator result, random_access_iterator_tag)
__uninitialized_fill	stl_uninitialized.h	/^inline void __uninitialized_fill(ForwardIterator first, ForwardIterator last, $/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& x, T1*)
__uninitialized_fill_aux	stl_uninitialized.h	/^__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, $/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& x, __false_type)
__uninitialized_fill_aux	stl_uninitialized.h	/^__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, $/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& x, __true_type)
__uninitialized_fill_copy	stl_uninitialized.h	/^__uninitialized_fill_copy(ForwardIterator result, ForwardIterator mid,$/;"	f	signature:(ForwardIterator result, ForwardIterator mid, const T& x, InputIterator first, InputIterator last)
__uninitialized_fill_n	stl_uninitialized.h	/^inline ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n,$/;"	f	signature:(ForwardIterator first, Size n, const T& x, T1*)
__uninitialized_fill_n_aux	stl_uninitialized.h	/^__uninitialized_fill_n_aux(ForwardIterator first, Size n,$/;"	f	signature:(ForwardIterator first, Size n, const T& x, __false_type)
__uninitialized_fill_n_aux	stl_uninitialized.h	/^__uninitialized_fill_n_aux(ForwardIterator first, Size n,$/;"	f	signature:(ForwardIterator first, Size n, const T& x, __true_type)
__unique_copy	stl_algo.h	/^ForwardIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, ForwardIterator result, BinaryPredicate binary_pred, forward_iterator_tag)
__unique_copy	stl_algo.h	/^ForwardIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, ForwardIterator result, forward_iterator_tag)
__unique_copy	stl_algo.h	/^OutputIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate binary_pred, T*)
__unique_copy	stl_algo.h	/^OutputIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, T*)
__unique_copy	stl_algo.h	/^inline OutputIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate binary_pred, output_iterator_tag)
__unique_copy	stl_algo.h	/^inline OutputIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, output_iterator_tag)
__unlock	stl_alloc.h	/^    static inline void __unlock(volatile unsigned long *);$/;"	p	class:__default_alloc_template	access:private	signature:(volatile unsigned long *)
__unlock	stl_alloc.h	/^__default_alloc_template<threads, inst>::__unlock(volatile unsigned long *lock)$/;"	f	class:__default_alloc_template	signature:(volatile unsigned long *lock)
__upper_bound	stl_algo.h	/^ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value, Compare comp, Distance*, forward_iterator_tag)
__upper_bound	stl_algo.h	/^ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value, Distance*, forward_iterator_tag)
__upper_bound	stl_algo.h	/^RandomAccessIterator __upper_bound(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, const T& value, Compare comp, Distance*, random_access_iterator_tag)
__upper_bound	stl_algo.h	/^RandomAccessIterator __upper_bound(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, const T& value, Distance*, random_access_iterator_tag)
_insert_after	stl_slist.h	/^  list_node* _insert_after(list_node_base* pos, const value_type& x) {$/;"	f	class:slist	access:private	signature:(list_node_base* pos, const value_type& x)
_insert_after_fill	stl_slist.h	/^  void _insert_after_fill(list_node_base* pos,$/;"	f	class:slist	access:private	signature:(list_node_base* pos, size_type n, const value_type& x)
_insert_after_range	stl_slist.h	/^  void _insert_after_range(list_node_base* pos, InIter first, InIter last) {$/;"	f	class:slist	access:private	signature:(list_node_base* pos, InIter first, InIter last)
_insert_after_range	stl_slist.h	/^  void _insert_after_range(list_node_base* pos,$/;"	f	class:slist	access:private	signature:(list_node_base* pos, const value_type* first, const value_type* last)
_insert_after_range	stl_slist.h	/^  void _insert_after_range(list_node_base* pos,$/;"	f	class:slist	access:private	signature:(list_node_base* pos, const_iterator first, const_iterator last)
accumulate	stl_numeric.h	/^T accumulate(InputIterator first, InputIterator last, T init) {$/;"	f	signature:(InputIterator first, InputIterator last, T init)
accumulate	stl_numeric.h	/^T accumulate(InputIterator first, InputIterator last, T init,$/;"	f	signature:(InputIterator first, InputIterator last, T init, BinaryOperation binary_op)
add_leaf_to_forest	ropeimpl.h	/^rope<charT,Alloc>::add_leaf_to_forest(RopeBase *r, RopeBase **forest)$/;"	f	class:rope	signature:(RopeBase *r, RopeBase **forest)
add_leaf_to_forest	stl_rope.h	/^	static void add_leaf_to_forest(RopeBase *r, RopeBase **forest);$/;"	p	class:rope	access:protected	signature:(RopeBase *r, RopeBase **forest)
add_to_forest	ropeimpl.h	/^rope<charT,Alloc>::add_to_forest(RopeBase *r, RopeBase **forest)$/;"	f	class:rope	signature:(RopeBase *r, RopeBase **forest)
add_to_forest	stl_rope.h	/^	static void add_to_forest(RopeBase *r, RopeBase **forest);$/;"	p	class:rope	access:protected	signature:(RopeBase *r, RopeBase **forest)
address	defalloc.h	/^    pointer address(reference x) { return (pointer)&x; }$/;"	f	class:allocator	access:public	signature:(reference x)
adjacent_difference	stl_numeric.h	/^OutputIterator adjacent_difference(InputIterator first, InputIterator last, $/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result)
adjacent_difference	stl_numeric.h	/^OutputIterator adjacent_difference(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op)
adjacent_find	stl_algo.h	/^ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last) {$/;"	f	signature:(ForwardIterator first, ForwardIterator last)
adjacent_find	stl_algo.h	/^ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred)
advance	stl_iterator.h	/^inline void advance(InputIterator& i, Distance n) {$/;"	f	signature:(InputIterator& i, Distance n)
alloc	stl_alloc.h	/^typedef __default_alloc_template<__NODE_ALLOCATOR_THREADS, 0> alloc;$/;"	t
alloc	stl_alloc.h	/^typedef malloc_alloc alloc;$/;"	t
alloc_copy	stl_rope.h	/^	static charT * alloc_copy(const charT *s, size_t size)$/;"	f	class:rope	access:protected	signature:(const charT *s, size_t size)
alloc_granularity	stl_rope.h	/^    enum { alloc_granularity = 8 };$/;"	e	enum:__rope_RopeBase::__anon10
allocate	defalloc.h	/^    pointer allocate(size_type n) { $/;"	f	class:allocator	access:public	signature:(size_type n)
allocate	defalloc.h	/^inline T* allocate(ptrdiff_t size, T*) {$/;"	f	signature:(ptrdiff_t size, T*)
allocate	stl_alloc.h	/^    static T *allocate(size_t n)$/;"	f	class:simple_alloc	access:public	signature:(size_t n)
allocate	stl_alloc.h	/^    static T *allocate(void)$/;"	f	class:simple_alloc	access:public	signature:(void)
allocate	stl_alloc.h	/^  static void * allocate(size_t n)$/;"	f	class:__default_alloc_template	access:public	signature:(size_t n)
allocate	stl_alloc.h	/^static void * allocate(size_t n)$/;"	f	class:__malloc_alloc_template	access:public	signature:(size_t n)
allocate	stl_alloc.h	/^static void * allocate(size_t n)$/;"	f	class:debug_alloc	access:public	signature:(size_t n)
allocate_and_copy	stl_vector.h	/^  iterator allocate_and_copy(size_type n,$/;"	f	class:vector	access:protected	signature:(size_type n, ForwardIterator first, ForwardIterator last)
allocate_and_copy	stl_vector.h	/^  iterator allocate_and_copy(size_type n,$/;"	f	class:vector	access:protected	signature:(size_type n, const_iterator first, const_iterator last)
allocate_and_fill	stl_vector.h	/^  iterator allocate_and_fill(size_type n, const T& x) {$/;"	f	class:vector	access:protected	signature:(size_type n, const T& x)
allocate_buffer	stl_tempbuf.h	/^  void allocate_buffer() {$/;"	f	class:temporary_buffer	access:private	signature:()
allocate_node	stl_deque.h	/^  pointer allocate_node() { return data_allocator::allocate(buffer_size()); }$/;"	f	class:__deque_iterator::deque	access:protected	signature:()
allocated_capacity	stl_rope.h	/^	static size_t allocated_capacity(size_t n) {$/;"	f	class:rope	access:protected	signature:(size_t n)
allocator	defalloc.h	/^class allocator {$/;"	c
allocator	defalloc.h	/^class allocator<void> {$/;"	c
allocator::address	defalloc.h	/^    pointer address(reference x) { return (pointer)&x; }$/;"	f	class:allocator	access:public	signature:(reference x)
allocator::allocate	defalloc.h	/^    pointer allocate(size_type n) { $/;"	f	class:allocator	access:public	signature:(size_type n)
allocator::const_address	defalloc.h	/^    const_pointer const_address(const_reference x) { $/;"	f	class:allocator	access:public	signature:(const_reference x)
allocator::const_pointer	defalloc.h	/^    typedef const T* const_pointer;$/;"	t	class:allocator	access:public
allocator::const_reference	defalloc.h	/^    typedef const T& const_reference;$/;"	t	class:allocator	access:public
allocator::deallocate	defalloc.h	/^    void deallocate(pointer p) { ::deallocate(p); }$/;"	f	class:allocator	access:public	signature:(pointer p)
allocator::difference_type	defalloc.h	/^    typedef ptrdiff_t difference_type;$/;"	t	class:allocator	access:public
allocator::init_page_size	defalloc.h	/^    size_type init_page_size() { $/;"	f	class:allocator	access:public	signature:()
allocator::max_size	defalloc.h	/^    size_type max_size() const { $/;"	f	class:allocator	access:public	signature:() const
allocator::pointer	defalloc.h	/^    typedef T* pointer;$/;"	t	class:allocator	access:public
allocator::pointer	defalloc.h	/^    typedef void* pointer;$/;"	t	class:allocator	access:public
allocator::reference	defalloc.h	/^    typedef T& reference;$/;"	t	class:allocator	access:public
allocator::size_type	defalloc.h	/^    typedef size_t size_type;$/;"	t	class:allocator	access:public
allocator::value_type	defalloc.h	/^    typedef T value_type;$/;"	t	class:allocator	access:public
append	stl_rope.h	/^	rope& append() { return append(charT()); }$/;"	f	class:rope	access:public	signature:()
append	stl_rope.h	/^	rope& append(charT c) {$/;"	f	class:rope	access:public	signature:(charT c)
append	stl_rope.h	/^	rope& append(const charT* c_string) {$/;"	f	class:rope	access:public	signature:(const charT* c_string)
append	stl_rope.h	/^	rope& append(const charT* iter, size_t n) {$/;"	f	class:rope	access:public	signature:(const charT* iter, size_t n)
append	stl_rope.h	/^	rope& append(const charT* s, const charT* e) {$/;"	f	class:rope	access:public	signature:(const charT* s, const charT* e)
append	stl_rope.h	/^	rope& append(const rope& y) {$/;"	f	class:rope	access:public	signature:(const rope& y)
append	stl_rope.h	/^	rope& append(const_iterator s, const_iterator e) {$/;"	f	class:rope	access:public	signature:(const_iterator s, const_iterator e)
append	stl_rope.h	/^	rope& append(size_t n, charT c) {$/;"	f	class:rope	access:public	signature:(size_t n, charT c)
append	stl_rope.h	/^	void append(value_type *s, size_t len)$/;"	f	class:sequence_buffer	access:public	signature:(value_type *s, size_t len)
apply_to_pieces	ropeimpl.h	/^bool rope<charT, Alloc>::apply_to_pieces($/;"	f	class:rope	signature:( __rope_char_consumer<charT>& c, const RopeBase * r, size_t begin, size_t end)
apply_to_pieces	stl_rope.h	/^	static bool apply_to_pieces($/;"	p	class:rope	access:protected	signature:( __rope_char_consumer<charT>& c, const RopeBase * r, size_t begin, size_t end)
apply_to_pieces	stl_rope.h	/^	void apply_to_pieces( size_t begin, size_t end,$/;"	f	class:rope	access:public	signature:( size_t begin, size_t end, __rope_char_consumer<charT>& c) const
argument_type	stl_function.h	/^    typedef Arg argument_type;$/;"	t	struct:unary_function	access:public
at	stl_rope.h	/^	    reference at(size_type pos) {$/;"	f	class:rope	access:public	signature:(size_type pos)
at	stl_rope.h	/^	charT at(size_type pos) const {$/;"	f	class:rope	access:public	signature:(size_type pos) const
atomic_swap	stl_rope.h	/^	    static cstrptr atomic_swap(cstrptr *p, cstrptr q) {$/;"	f	class:rope	access:protected	signature:(cstrptr *p, cstrptr q)
back	stl_bvector.h	/^  const_reference back() const { return *(end() - 1); }$/;"	f	class:vector	access:public	signature:() const
back	stl_bvector.h	/^  reference back() { return *(end() - 1); }$/;"	f	class:vector	access:public	signature:()
back	stl_deque.h	/^  const_reference back() const {$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
back	stl_deque.h	/^  reference back() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
back	stl_list.h	/^  const_reference back() const { return *(--end()); }$/;"	f	class:list	access:public	signature:() const
back	stl_list.h	/^  reference back() { return *(--end()); }$/;"	f	class:list	access:public	signature:()
back	stl_queue.h	/^  const_reference back() const { return c.back(); }$/;"	f	class:queue	access:public	signature:() const
back	stl_queue.h	/^  reference back() { return c.back(); }$/;"	f	class:queue	access:public	signature:()
back	stl_rope.h	/^	charT back() const$/;"	f	class:rope	access:public	signature:() const
back	stl_vector.h	/^  const_reference back() const { return *(end() - 1); }$/;"	f	class:vector	access:public	signature:() const
back	stl_vector.h	/^  reference back() { return *(end() - 1); }$/;"	f	class:vector	access:public	signature:()
back_insert_iterator	stl_iterator.h	/^  explicit back_insert_iterator(Container& x) : container(&x) {}$/;"	f	class:back_insert_iterator	access:public	signature:(Container& x)
back_insert_iterator	stl_iterator.h	/^class back_insert_iterator {$/;"	c
back_insert_iterator::back_insert_iterator	stl_iterator.h	/^  explicit back_insert_iterator(Container& x) : container(&x) {}$/;"	f	class:back_insert_iterator	access:public	signature:(Container& x)
back_insert_iterator::container	stl_iterator.h	/^  Container* container;$/;"	m	class:back_insert_iterator	access:protected
back_insert_iterator::difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:back_insert_iterator	access:public
back_insert_iterator::iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:back_insert_iterator	access:public
back_insert_iterator::operator *	stl_iterator.h	/^  back_insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:back_insert_iterator	access:public	signature:()
back_insert_iterator::operator ++	stl_iterator.h	/^  back_insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:back_insert_iterator	access:public	signature:()
back_insert_iterator::operator ++	stl_iterator.h	/^  back_insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:back_insert_iterator	access:public	signature:(int)
back_insert_iterator::operator =	stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:back_insert_iterator	access:public	signature:(const typename Container::value_type& value)
back_insert_iterator::pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:back_insert_iterator	access:public
back_insert_iterator::reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	class:back_insert_iterator	access:public
back_insert_iterator::value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:back_insert_iterator	access:public
back_inserter	stl_iterator.h	/^inline back_insert_iterator<Container> back_inserter(Container& x) {$/;"	f	signature:(Container& x)
balance	ropeimpl.h	/^rope<charT,Alloc>::balance(RopeBase *r)$/;"	f	class:rope	signature:(RopeBase *r)
balance	stl_rope.h	/^	static RopeBase * balance(RopeBase * r);$/;"	p	class:rope	access:protected	signature:(RopeBase * r)
balance	stl_rope.h	/^	void balance()$/;"	f	class:rope	access:public	signature:()
base	stl_iterator.h	/^  BidirectionalIterator base() const { return current; }$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:() const
base	stl_iterator.h	/^  RandomAccessIterator base() const { return current; }$/;"	f	class:reverse_iterator	access:public	signature:() const
base	stl_iterator.h	/^  iterator_type base() const { return current; }$/;"	f	class:reverse_iterator	access:public	signature:() const
base	stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * base;	\/\/ not 0$/;"	m	struct:__rope_RopeSubstring	access:public
base_ptr	stl_tree.h	/^  typedef __rb_tree_node_base* base_ptr;$/;"	t	class:rb_tree	access:protected
base_ptr	stl_tree.h	/^  typedef __rb_tree_node_base* base_ptr;$/;"	t	struct:__rb_tree_node_base	access:public
base_ptr	stl_tree.h	/^  typedef __rb_tree_node_base::base_ptr base_ptr;$/;"	t	struct:__rb_tree_base_iterator	access:public
begin	stl_bvector.h	/^  const_iterator begin() const { return start; }$/;"	f	class:vector	access:public	signature:() const
begin	stl_bvector.h	/^  iterator begin() { return start; }$/;"	f	class:vector	access:public	signature:()
begin	stl_deque.h	/^  const_iterator begin() const { return start; }$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
begin	stl_deque.h	/^  iterator begin() { return start; }$/;"	f	class:__deque_iterator::deque	access:public	signature:()
begin	stl_hash_map.h	/^  const_iterator begin() const { return rep.begin(); }$/;"	f	class:hash_map	access:public	signature:() const
begin	stl_hash_map.h	/^  const_iterator begin() const { return rep.begin(); }$/;"	f	class:hash_multimap	access:public	signature:() const
begin	stl_hash_map.h	/^  iterator begin() { return rep.begin(); }$/;"	f	class:hash_map	access:public	signature:()
begin	stl_hash_map.h	/^  iterator begin() { return rep.begin(); }$/;"	f	class:hash_multimap	access:public	signature:()
begin	stl_hash_set.h	/^  iterator begin() const { return rep.begin(); }$/;"	f	class:hash_multiset	access:public	signature:() const
begin	stl_hash_set.h	/^  iterator begin() const { return rep.begin(); }$/;"	f	class:hash_set	access:public	signature:() const
begin	stl_hashtable.h	/^  const_iterator begin() const$/;"	f	class:hashtable	access:public	signature:() const
begin	stl_hashtable.h	/^  iterator begin()$/;"	f	class:hashtable	access:public	signature:()
begin	stl_list.h	/^  const_iterator begin() const { return (link_type)((*node).next); }$/;"	f	class:list	access:public	signature:() const
begin	stl_list.h	/^  iterator begin() { return (link_type)((*node).next); }$/;"	f	class:list	access:public	signature:()
begin	stl_map.h	/^  const_iterator begin() const { return t.begin(); }$/;"	f	class:map	access:public	signature:() const
begin	stl_map.h	/^  iterator begin() { return t.begin(); }$/;"	f	class:map	access:public	signature:()
begin	stl_multimap.h	/^  const_iterator begin() const { return t.begin(); }$/;"	f	class:multimap	access:public	signature:() const
begin	stl_multimap.h	/^  iterator begin() { return t.begin(); }$/;"	f	class:multimap	access:public	signature:()
begin	stl_multiset.h	/^  iterator begin() const { return t.begin(); }$/;"	f	class:multiset	access:public	signature:() const
begin	stl_rope.h	/^	    const_iterator begin() { return const_begin(); }$/;"	f	class:rope	access:public	signature:()
begin	stl_rope.h	/^	    iterator begin() { return mutable_begin(); }$/;"	f	class:rope	access:public	signature:()
begin	stl_rope.h	/^	const_iterator begin() const {$/;"	f	class:rope	access:public	signature:() const
begin	stl_set.h	/^  iterator begin() const { return t.begin(); }$/;"	f	class:set	access:public	signature:() const
begin	stl_slist.h	/^  const_iterator begin() const { return const_iterator((list_node*)head.next);}$/;"	f	class:slist	access:public	signature:() const
begin	stl_slist.h	/^  iterator begin() { return iterator((list_node*)head.next); }$/;"	f	class:slist	access:public	signature:()
begin	stl_tempbuf.h	/^  T* begin() { return buffer; }$/;"	f	class:temporary_buffer	access:public	signature:()
begin	stl_tree.h	/^  const_iterator begin() const { return leftmost(); }$/;"	f	class:rb_tree	access:public	signature:() const
begin	stl_tree.h	/^  iterator begin() { return leftmost(); }$/;"	f	class:rb_tree	access:public	signature:()
begin	stl_vector.h	/^  const_iterator begin() const { return start; }$/;"	f	class:vector	access:public	signature:() const
begin	stl_vector.h	/^  iterator begin() { return start; }$/;"	f	class:vector	access:public	signature:()
bidirectional_iterator	stl_iterator.h	/^template <class T, class Distance> struct bidirectional_iterator {$/;"	s
bidirectional_iterator::difference_type	stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	struct:bidirectional_iterator	access:public
bidirectional_iterator::iterator_category	stl_iterator.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:bidirectional_iterator	access:public
bidirectional_iterator::pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:bidirectional_iterator	access:public
bidirectional_iterator::reference	stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:bidirectional_iterator	access:public
bidirectional_iterator::value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:bidirectional_iterator	access:public
bidirectional_iterator_tag	stl_iterator.h	/^struct bidirectional_iterator_tag : public forward_iterator_tag {};$/;"	s	inherits:forward_iterator_tag
binary_compose	stl_function.h	/^  binary_compose(const Operation1& x, const Operation2& y, $/;"	f	class:binary_compose	access:public	signature:(const Operation1& x, const Operation2& y, const Operation3& z)
binary_compose	stl_function.h	/^class binary_compose$/;"	c	inherits:unary_function
binary_compose::binary_compose	stl_function.h	/^  binary_compose(const Operation1& x, const Operation2& y, $/;"	f	class:binary_compose	access:public	signature:(const Operation1& x, const Operation2& y, const Operation3& z)
binary_compose::op1	stl_function.h	/^  Operation1 op1;$/;"	m	class:binary_compose	access:protected
binary_compose::op2	stl_function.h	/^  Operation2 op2;$/;"	m	class:binary_compose	access:protected
binary_compose::op3	stl_function.h	/^  Operation3 op3;$/;"	m	class:binary_compose	access:protected
binary_compose::operator ()	stl_function.h	/^  operator()(const typename Operation2::argument_type& x) const {$/;"	f	class:binary_compose	access:public	signature:(const typename Operation2::argument_type& x) const
binary_function	stl_function.h	/^struct binary_function {$/;"	s
binary_function::first_argument_type	stl_function.h	/^    typedef Arg1 first_argument_type;$/;"	t	struct:binary_function	access:public
binary_function::result_type	stl_function.h	/^    typedef Result result_type;$/;"	t	struct:binary_function	access:public
binary_function::second_argument_type	stl_function.h	/^    typedef Arg2 second_argument_type;$/;"	t	struct:binary_function	access:public
binary_negate	stl_function.h	/^  explicit binary_negate(const Predicate& x) : pred(x) {}$/;"	f	class:binary_negate	access:public	signature:(const Predicate& x)
binary_negate	stl_function.h	/^class binary_negate $/;"	c	inherits:binary_function
binary_negate::binary_negate	stl_function.h	/^  explicit binary_negate(const Predicate& x) : pred(x) {}$/;"	f	class:binary_negate	access:public	signature:(const Predicate& x)
binary_negate::operator ()	stl_function.h	/^  bool operator()(const typename Predicate::first_argument_type& x, $/;"	f	class:binary_negate	access:public	signature:(const typename Predicate::first_argument_type& x, const typename Predicate::second_argument_type& y) const
binary_negate::pred	stl_function.h	/^  Predicate pred;$/;"	m	class:binary_negate	access:protected
binary_search	stl_algo.h	/^bool binary_search(ForwardIterator first, ForwardIterator last, const T& value,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value, Compare comp)
binary_search	stl_algo.h	/^bool binary_search(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value)
bind1st	stl_function.h	/^inline binder1st<Operation> bind1st(const Operation& op, const T& x) {$/;"	f	signature:(const Operation& op, const T& x)
bind2nd	stl_function.h	/^inline binder2nd<Operation> bind2nd(const Operation& op, const T& x) {$/;"	f	signature:(const Operation& op, const T& x)
binder1st	stl_function.h	/^  binder1st(const Operation& x,$/;"	f	class:binder1st	access:public	signature:(const Operation& x, const typename Operation::first_argument_type& y)
binder1st	stl_function.h	/^class binder1st$/;"	c	inherits:unary_function
binder1st::binder1st	stl_function.h	/^  binder1st(const Operation& x,$/;"	f	class:binder1st	access:public	signature:(const Operation& x, const typename Operation::first_argument_type& y)
binder1st::op	stl_function.h	/^  Operation op;$/;"	m	class:binder1st	access:protected
binder1st::operator ()	stl_function.h	/^  operator()(const typename Operation::second_argument_type& x) const {$/;"	f	class:binder1st	access:public	signature:(const typename Operation::second_argument_type& x) const
binder1st::value	stl_function.h	/^  typename Operation::first_argument_type value;$/;"	m	class:binder1st	access:protected
binder2nd	stl_function.h	/^  binder2nd(const Operation& x,$/;"	f	class:binder2nd	access:public	signature:(const Operation& x, const typename Operation::second_argument_type& y)
binder2nd	stl_function.h	/^class binder2nd$/;"	c	inherits:unary_function
binder2nd::binder2nd	stl_function.h	/^  binder2nd(const Operation& x,$/;"	f	class:binder2nd	access:public	signature:(const Operation& x, const typename Operation::second_argument_type& y)
binder2nd::op	stl_function.h	/^  Operation op;$/;"	m	class:binder2nd	access:protected
binder2nd::operator ()	stl_function.h	/^  operator()(const typename Operation::first_argument_type& x) const {$/;"	f	class:binder2nd	access:public	signature:(const typename Operation::first_argument_type& x) const
binder2nd::value	stl_function.h	/^  typename Operation::second_argument_type value;$/;"	m	class:binder2nd	access:protected
bit_alloc	stl_bvector.h	/^  unsigned int* bit_alloc(size_type n) {$/;"	f	class:vector	access:protected	signature:(size_type n)
bit_vector	stl_bvector.h	/^typedef vector<bool, alloc> bit_vector;$/;"	t
bkt_num	stl_hashtable.h	/^  size_type bkt_num(const value_type& obj) const$/;"	f	class:hashtable	access:private	signature:(const value_type& obj) const
bkt_num	stl_hashtable.h	/^  size_type bkt_num(const value_type& obj, size_t n) const$/;"	f	class:hashtable	access:private	signature:(const value_type& obj, size_t n) const
bkt_num_key	stl_hashtable.h	/^  size_type bkt_num_key(const key_type& key) const$/;"	f	class:hashtable	access:private	signature:(const key_type& key) const
bkt_num_key	stl_hashtable.h	/^  size_type bkt_num_key(const key_type& key, size_t n) const$/;"	f	class:hashtable	access:private	signature:(const key_type& key, size_t n) const
bool	stl_config.h	/^    typedef int bool;$/;"	t
bucket_count	stl_hash_map.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_map	access:public	signature:() const
bucket_count	stl_hash_map.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_multimap	access:public	signature:() const
bucket_count	stl_hash_set.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_multiset	access:public	signature:() const
bucket_count	stl_hash_set.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_set	access:public	signature:() const
bucket_count	stl_hashtable.h	/^  size_type bucket_count() const { return buckets.size(); }$/;"	f	class:hashtable	access:public	signature:() const
buckets	stl_hashtable.h	/^  vector<node*,Alloc> buckets;$/;"	m	class:hashtable	access:private
buf_count	stl_rope.h	/^	size_t buf_count;$/;"	m	class:sequence_buffer	access:protected
buf_end	stl_rope.h	/^    __GC_CONST charT * buf_end;$/;"	m	class:__rope_iterator_base	access:protected
buf_ptr	ropeimpl.h	/^	charT * buf_ptr;$/;"	m	class:__rope_flatten_char_consumer	access:private
buf_ptr	stl_rope.h	/^    __GC_CONST charT * buf_ptr;$/;"	m	class:__rope_iterator_base	access:protected
buf_start	stl_rope.h	/^    __GC_CONST charT * buf_start;$/;"	m	class:__rope_iterator_base	access:protected
buffer	ropeimpl.h	/^	charT * buffer;$/;"	m	class:__rope_flatten_char_consumer	access:public
buffer	ropeimpl.h	/^	charT * buffer;$/;"	m	class:__rope_insert_char_consumer	access:public
buffer	stl_rope.h	/^	value_type buffer[buf_sz];$/;"	m	class:sequence_buffer	access:protected
buffer	stl_tempbuf.h	/^  T* buffer;$/;"	m	class:temporary_buffer	access:private
buffer_size	stl_deque.h	/^  static size_t buffer_size() {return __deque_buf_size(0, sizeof(T)); }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:()
buffer_size	stl_deque.h	/^  static size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T)); }$/;"	f	struct:__deque_iterator	access:public	signature:()
buffer_size	stl_deque.h	/^  static size_type buffer_size() {$/;"	f	class:__deque_iterator::deque	access:protected	signature:()
bump_down	stl_bvector.h	/^  void bump_down() {$/;"	f	struct:__bit_const_iterator	access:public	signature:()
bump_down	stl_bvector.h	/^  void bump_down() {$/;"	f	struct:__bit_iterator	access:public	signature:()
bump_up	stl_bvector.h	/^  void bump_up() {$/;"	f	struct:__bit_const_iterator	access:public	signature:()
bump_up	stl_bvector.h	/^  void bump_up() {$/;"	f	struct:__bit_iterator	access:public	signature:()
c	stl_queue.h	/^  Sequence c;$/;"	m	class:priority_queue	access:protected
c	stl_queue.h	/^  Sequence c;$/;"	m	class:queue	access:protected
c	stl_stack.h	/^  Sequence c;$/;"	m	class:stack	access:protected
c_str	ropeimpl.h	/^const charT * rope<charT,Alloc>::c_str() const {$/;"	f	class:rope	signature:() const
c_str	stl_rope.h	/^	const charT * c_str() const;$/;"	p	class:rope	access:public	signature:() const
c_string	stl_rope.h	/^    __GC_CONST charT * c_string;$/;"	m	struct:__rope_RopeBase	access:public
capacity	stl_bvector.h	/^  size_type capacity() const {$/;"	f	class:vector	access:public	signature:() const
capacity	stl_rope.h	/^	    size_type capacity() const {$/;"	f	class:rope	access:public	signature:() const
capacity	stl_vector.h	/^  size_type capacity() const { return size_type(end_of_storage - begin()); }$/;"	f	class:vector	access:public	signature:() const
char_producer	stl_rope.h	/^class char_producer {$/;"	c
char_producer::operator ()	stl_rope.h	/^	virtual void operator()(size_t start_pos, size_t len, charT* buffer)$/;"	p	class:char_producer	access:public	signature:(size_t start_pos, size_t len, charT* buffer)
char_producer::~char_producer	stl_rope.h	/^	virtual ~char_producer() {};$/;"	f	class:char_producer	access:public	signature:()
char_ptr_len	ropeimpl.h	/^inline size_t rope<charT,Alloc>::char_ptr_len(const charT *s)$/;"	f	class:rope	signature:(const charT *s)
char_ptr_len	stl_rope.h	/^	static size_t char_ptr_len(const charT * s);$/;"	p	class:rope	access:protected	signature:(const charT * s)
check	ropeimpl.h	/^void __rope_iterator<charT,Alloc>::check() {$/;"	f	class:__rope_iterator	signature:()
check	stl_rope.h	/^    void check();$/;"	p	class:__rope_iterator	access:protected	signature:()
chunk_alloc	stl_alloc.h	/^  static char *chunk_alloc(size_t size, int &nobjs);$/;"	p	class:__default_alloc_template	access:private	signature:(size_t size, int &nobjs)
chunk_alloc	stl_alloc.h	/^__default_alloc_template<threads, inst>::chunk_alloc(size_t size, int& nobjs)$/;"	f	class:__default_alloc_template	signature:(size_t size, int& nobjs)
clear	stl_bvector.h	/^  void clear() { erase(begin(), end()); }$/;"	f	class:vector	access:public	signature:()
clear	stl_deque.h	/^  void clear(); $/;"	p	class:__deque_iterator::deque	access:public	signature:()
clear	stl_deque.h	/^void deque<T, Alloc, BufSize>::clear() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
clear	stl_hash_map.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_map	access:public	signature:()
clear	stl_hash_map.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_multimap	access:public	signature:()
clear	stl_hash_set.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_multiset	access:public	signature:()
clear	stl_hash_set.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_set	access:public	signature:()
clear	stl_hashtable.h	/^  void clear();$/;"	p	class:hashtable	access:public	signature:()
clear	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::clear()$/;"	f	class:hashtable	signature:()
clear	stl_list.h	/^  void clear();$/;"	p	class:list	access:public	signature:()
clear	stl_list.h	/^void list<T, Alloc>::clear()$/;"	f	class:list	signature:()
clear	stl_map.h	/^  void clear() { t.clear(); }$/;"	f	class:map	access:public	signature:()
clear	stl_multimap.h	/^  void clear() { t.clear(); }$/;"	f	class:multimap	access:public	signature:()
clear	stl_multiset.h	/^  void clear() { t.clear(); }$/;"	f	class:multiset	access:public	signature:()
clear	stl_set.h	/^  void clear() { t.clear(); }$/;"	f	class:set	access:public	signature:()
clear	stl_slist.h	/^  void clear() { erase_after(&head, 0); }$/;"	f	class:slist	access:public	signature:()
clear	stl_tree.h	/^  void clear() {$/;"	f	class:rb_tree	access:public	signature:()
clear	stl_vector.h	/^  void clear() { erase(begin(), end()); }$/;"	f	class:vector	access:public	signature:()
client_data	stl_alloc.h	/^        char client_data[1];    \/* The client sees this.        *\/$/;"	m	union:__default_alloc_template::obj	access:public
clone_node	stl_tree.h	/^  link_type clone_node(link_type x) {$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
color	stl_tree.h	/^  color_type color; $/;"	m	struct:__rb_tree_node_base	access:public
color	stl_tree.h	/^  static color_type& color(base_ptr x) { return (color_type&)(link_type(x)->color); }$/;"	f	class:rb_tree	access:protected	signature:(base_ptr x)
color	stl_tree.h	/^  static color_type& color(link_type x) { return (color_type&)(x->color); }$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
color_type	stl_tree.h	/^  typedef __rb_tree_color_type color_type;$/;"	t	class:rb_tree	access:protected
color_type	stl_tree.h	/^  typedef __rb_tree_color_type color_type;$/;"	t	struct:__rb_tree_node_base	access:public
comp	stl_map.h	/^    Compare comp;$/;"	m	class:map::value_compare	access:protected
comp	stl_multimap.h	/^    Compare comp;$/;"	m	class:multimap::value_compare	access:protected
comp	stl_queue.h	/^  Compare comp;$/;"	m	class:priority_queue	access:protected
compare	ropeimpl.h	/^rope<charT,Alloc>::compare (const RopeBase *left, const RopeBase *right)$/;"	f	class:rope	signature:(const RopeBase *left, const RopeBase *right)
compare	stl_rope.h	/^	int compare(const rope &y) const {$/;"	f	class:rope	access:public	signature:(const rope &y) const
compare	stl_rope.h	/^	static int compare(const RopeBase *x, const RopeBase *y);$/;"	p	class:rope	access:protected	signature:(const RopeBase *x, const RopeBase *y)
compose1	stl_function.h	/^inline unary_compose<Operation1, Operation2> compose1(const Operation1& op1, $/;"	f	signature:(const Operation1& op1, const Operation2& op2)
compose2	stl_function.h	/^compose2(const Operation1& op1, const Operation2& op2, const Operation3& op3) {$/;"	f	signature:(const Operation1& op1, const Operation2& op2, const Operation3& op3)
concat	ropeimpl.h	/^rope<charT,Alloc>::concat(RopeBase * left, RopeBase * right)$/;"	f	class:rope	signature:(RopeBase * left, RopeBase * right)
concat	stl_rope.h	/^	static RopeBase * concat(RopeBase *left, RopeBase *right);$/;"	p	class:rope	access:protected	signature:(RopeBase *left, RopeBase *right)
concat	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon9
concat_and_set_balanced	stl_rope.h	/^	static RopeBase * concat_and_set_balanced(RopeBase *left,$/;"	f	class:rope	access:protected	signature:(RopeBase *left, RopeBase *right)
concat_char_iter	ropeimpl.h	/^rope<charT,Alloc>::RopeBase * rope<charT,Alloc>::concat_char_iter$/;"	f	class:rope	signature:(RopeBase * r, const charT *s, size_t slen)
concat_char_iter	stl_rope.h	/^	static RopeBase * concat_char_iter(RopeBase * r,$/;"	p	class:rope	access:protected	signature:(RopeBase * r, const charT *iter, size_t slen)
concat_fn	stl_rope.h	/^	struct concat_fn$/;"	s	class:rope	inherits:binary_function	access:protected
const_address	defalloc.h	/^    const_pointer const_address(const_reference x) { $/;"	f	class:allocator	access:public	signature:(const_reference x)
const_begin	stl_rope.h	/^	const_iterator const_begin() const {$/;"	f	class:rope	access:public	signature:() const
const_end	stl_rope.h	/^	const_iterator const_end() const {$/;"	f	class:rope	access:public	signature:() const
const_iterator	stl_bvector.h	/^  typedef __bit_const_iterator          const_iterator;$/;"	t	class:vector	access:public
const_iterator	stl_bvector.h	/^  typedef __bit_const_iterator const_iterator;$/;"	t	struct:__bit_const_iterator	access:public
const_iterator	stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T&, BufSiz>  const_iterator;$/;"	t	class:__deque_iterator::deque	access:public
const_iterator	stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T*, BufSiz> const_iterator;$/;"	t	struct:__deque_iterator	access:public
const_iterator	stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T*>          const_iterator;$/;"	t	class:__deque_iterator::deque	access:public
const_iterator	stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
const_iterator	stl_hash_map.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_map	access:public
const_iterator	stl_hash_map.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_multimap	access:public
const_iterator	stl_hash_set.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_multiset	access:public
const_iterator	stl_hash_set.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_set	access:public
const_iterator	stl_hashtable.h	/^          const_iterator;$/;"	t	struct:__hashtable_const_iterator	access:public
const_iterator	stl_hashtable.h	/^          const_iterator;$/;"	t	struct:__hashtable_iterator	access:public
const_iterator	stl_hashtable.h	/^  const_iterator;$/;"	t	class:hashtable	access:public
const_iterator	stl_list.h	/^  typedef __list_iterator<T, const T&, const T*> const_iterator;$/;"	t	class:list	access:public
const_iterator	stl_list.h	/^  typedef __list_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:__list_iterator	access:public
const_iterator	stl_map.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:map	access:public
const_iterator	stl_multimap.h	/^  typedef typename rep_type::const_iterator const_iterator; $/;"	t	class:multimap	access:public
const_iterator	stl_multiset.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:multiset	access:public
const_iterator	stl_rope.h	/^	typedef __rope_const_iterator<charT,Alloc> const_iterator;$/;"	t	class:rope	access:public
const_iterator	stl_set.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:set	access:public
const_iterator	stl_slist.h	/^  typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	class:slist	access:public
const_iterator	stl_slist.h	/^  typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:__slist_iterator	access:public
const_iterator	stl_tree.h	/^          const_iterator;$/;"	t	class:rb_tree	access:public
const_iterator	stl_tree.h	/^  typedef __rb_tree_iterator<Value, const Value&, const Value*> const_iterator;$/;"	t	struct:__rb_tree_iterator	access:public
const_iterator	stl_vector.h	/^  typedef const value_type* const_iterator;$/;"	t	class:vector	access:public
const_mem_fun1_ref_t	stl_function.h	/^  explicit const_mem_fun1_ref_t(void (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_ref_t	access:public	signature:(void (T::*pf)(A) const)
const_mem_fun1_ref_t	stl_function.h	/^class const_mem_fun1_ref_t : public binary_function<T, A, S> {$/;"	c	inherits:binary_function
const_mem_fun1_ref_t	stl_function.h	/^class const_mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {$/;"	c	inherits:binary_function
const_mem_fun1_ref_t::S	stl_function.h	/^  explicit const_mem_fun1_ref_t(S (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_ref_t	access:public	signature:(T::*pf) const
const_mem_fun1_ref_t::const_mem_fun1_ref_t	stl_function.h	/^  explicit const_mem_fun1_ref_t(void (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_ref_t	access:public	signature:(void (T::*pf)(A) const)
const_mem_fun1_ref_t::f	stl_function.h	/^  S (T::*f)(A) const;$/;"	m	class:const_mem_fun1_ref_t	access:private
const_mem_fun1_ref_t::f	stl_function.h	/^  void (T::*f)(A) const;$/;"	m	class:const_mem_fun1_ref_t	access:private
const_mem_fun1_ref_t::operator ()	stl_function.h	/^  S operator()(const T& r, A x) const { return (r.*f)(x); }$/;"	f	class:const_mem_fun1_ref_t	access:public	signature:(const T& r, A x) const
const_mem_fun1_ref_t::operator ()	stl_function.h	/^  void operator()(const T& r, A x) const { (r.*f)(x); }$/;"	f	class:const_mem_fun1_ref_t	access:public	signature:(const T& r, A x) const
const_mem_fun1_t	stl_function.h	/^  explicit const_mem_fun1_t(void (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_t	access:public	signature:(void (T::*pf)(A) const)
const_mem_fun1_t	stl_function.h	/^class const_mem_fun1_t : public binary_function<const T*, A, S> {$/;"	c	inherits:binary_function
const_mem_fun1_t	stl_function.h	/^class const_mem_fun1_t<void, T, A> : public binary_function<const T*, A, void> {$/;"	c	inherits:binary_function
const_mem_fun1_t::S	stl_function.h	/^  explicit const_mem_fun1_t(S (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_t	access:public	signature:(T::*pf) const
const_mem_fun1_t::const_mem_fun1_t	stl_function.h	/^  explicit const_mem_fun1_t(void (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_t	access:public	signature:(void (T::*pf)(A) const)
const_mem_fun1_t::f	stl_function.h	/^  S (T::*f)(A) const;$/;"	m	class:const_mem_fun1_t	access:private
const_mem_fun1_t::f	stl_function.h	/^  void (T::*f)(A) const;$/;"	m	class:const_mem_fun1_t	access:private
const_mem_fun1_t::operator ()	stl_function.h	/^  S operator()(const T* p, A x) const { return (p->*f)(x); }$/;"	f	class:const_mem_fun1_t	access:public	signature:(const T* p, A x) const
const_mem_fun1_t::operator ()	stl_function.h	/^  void operator()(const T* p, A x) const { (p->*f)(x); }$/;"	f	class:const_mem_fun1_t	access:public	signature:(const T* p, A x) const
const_mem_fun_ref_t	stl_function.h	/^  explicit const_mem_fun_ref_t(void (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_ref_t	access:public	signature:(void (T::*pf)() const)
const_mem_fun_ref_t	stl_function.h	/^class const_mem_fun_ref_t : public unary_function<T, S> {$/;"	c	inherits:unary_function
const_mem_fun_ref_t	stl_function.h	/^class const_mem_fun_ref_t<void, T> : public unary_function<T, void> {$/;"	c	inherits:unary_function
const_mem_fun_ref_t::S	stl_function.h	/^  explicit const_mem_fun_ref_t(S (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_ref_t	access:public	signature:(T::*pf) const
const_mem_fun_ref_t::const_mem_fun_ref_t	stl_function.h	/^  explicit const_mem_fun_ref_t(void (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_ref_t	access:public	signature:(void (T::*pf)() const)
const_mem_fun_ref_t::f	stl_function.h	/^  S (T::*f)() const;$/;"	m	class:const_mem_fun_ref_t	access:private
const_mem_fun_ref_t::f	stl_function.h	/^  void (T::*f)() const;$/;"	m	class:const_mem_fun_ref_t	access:private
const_mem_fun_ref_t::operator ()	stl_function.h	/^  S operator()(const T& r) const { return (r.*f)(); }$/;"	f	class:const_mem_fun_ref_t	access:public	signature:(const T& r) const
const_mem_fun_ref_t::operator ()	stl_function.h	/^  void operator()(const T& r) const { (r.*f)(); }$/;"	f	class:const_mem_fun_ref_t	access:public	signature:(const T& r) const
const_mem_fun_t	stl_function.h	/^  explicit const_mem_fun_t(void (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_t	access:public	signature:(void (T::*pf)() const)
const_mem_fun_t	stl_function.h	/^class const_mem_fun_t : public unary_function<const T*, S> {$/;"	c	inherits:unary_function
const_mem_fun_t	stl_function.h	/^class const_mem_fun_t<void, T> : public unary_function<const T*, void> {$/;"	c	inherits:unary_function
const_mem_fun_t::S	stl_function.h	/^  explicit const_mem_fun_t(S (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_t	access:public	signature:(T::*pf) const
const_mem_fun_t::const_mem_fun_t	stl_function.h	/^  explicit const_mem_fun_t(void (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_t	access:public	signature:(void (T::*pf)() const)
const_mem_fun_t::f	stl_function.h	/^  S (T::*f)() const;$/;"	m	class:const_mem_fun_t	access:private
const_mem_fun_t::f	stl_function.h	/^  void (T::*f)() const;$/;"	m	class:const_mem_fun_t	access:private
const_mem_fun_t::operator ()	stl_function.h	/^  S operator()(const T* p) const { return (p->*f)(); }$/;"	f	class:const_mem_fun_t	access:public	signature:(const T* p) const
const_mem_fun_t::operator ()	stl_function.h	/^  void operator()(const T* p) const { (p->*f)(); }$/;"	f	class:const_mem_fun_t	access:public	signature:(const T* p) const
const_pointer	defalloc.h	/^    typedef const T* const_pointer;$/;"	t	class:allocator	access:public
const_pointer	stl_bvector.h	/^  typedef const bool* const_pointer;$/;"	t	class:vector	access:public
const_pointer	stl_deque.h	/^  typedef const value_type* const_pointer;$/;"	t	class:__deque_iterator::deque	access:public
const_pointer	stl_hash_map.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_map	access:public
const_pointer	stl_hash_map.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_multimap	access:public
const_pointer	stl_hash_set.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_multiset	access:public
const_pointer	stl_hash_set.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_set	access:public
const_pointer	stl_hashtable.h	/^  typedef const value_type* const_pointer;$/;"	t	class:hashtable	access:public
const_pointer	stl_list.h	/^  typedef const value_type* const_pointer;$/;"	t	class:list	access:public
const_pointer	stl_map.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:map	access:public
const_pointer	stl_multimap.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:multimap	access:public
const_pointer	stl_multiset.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:multiset	access:public
const_pointer	stl_rope.h	/^	typedef const charT* const_pointer;$/;"	t	class:rope	access:public
const_pointer	stl_set.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:set	access:public
const_pointer	stl_slist.h	/^  typedef const value_type* const_pointer;$/;"	t	class:slist	access:public
const_pointer	stl_tree.h	/^  typedef const value_type* const_pointer;$/;"	t	class:rb_tree	access:public
const_pointer	stl_vector.h	/^  typedef const value_type* const_pointer;$/;"	t	class:vector	access:public
const_rbegin	stl_rope.h	/^	const_reverse_iterator const_rbegin() const {$/;"	f	class:rope	access:public	signature:() const
const_reference	defalloc.h	/^    typedef const T& const_reference;$/;"	t	class:allocator	access:public
const_reference	stl_bvector.h	/^  typedef bool                 const_reference;$/;"	t	struct:__bit_const_iterator	access:public
const_reference	stl_bvector.h	/^  typedef bool const_reference;$/;"	t	class:vector	access:public
const_reference	stl_deque.h	/^  typedef const value_type& const_reference;$/;"	t	class:__deque_iterator::deque	access:public
const_reference	stl_hash_map.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_map	access:public
const_reference	stl_hash_map.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_multimap	access:public
const_reference	stl_hash_set.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_multiset	access:public
const_reference	stl_hash_set.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_set	access:public
const_reference	stl_hashtable.h	/^  typedef const value_type& const_reference;$/;"	t	class:hashtable	access:public
const_reference	stl_list.h	/^  typedef const value_type& const_reference;$/;"	t	class:list	access:public
const_reference	stl_map.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:map	access:public
const_reference	stl_multimap.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:multimap	access:public
const_reference	stl_multiset.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:multiset	access:public
const_reference	stl_queue.h	/^  typedef typename Sequence::const_reference const_reference;$/;"	t	class:priority_queue	access:public
const_reference	stl_queue.h	/^  typedef typename Sequence::const_reference const_reference;$/;"	t	class:queue	access:public
const_reference	stl_rope.h	/^	typedef charT const_reference;$/;"	t	class:rope	access:public
const_reference	stl_set.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:set	access:public
const_reference	stl_slist.h	/^  typedef const value_type& const_reference;$/;"	t	class:slist	access:public
const_reference	stl_stack.h	/^  typedef typename Sequence::const_reference const_reference;$/;"	t	class:stack	access:public
const_reference	stl_tree.h	/^  typedef const value_type& const_reference;$/;"	t	class:rb_tree	access:public
const_reference	stl_vector.h	/^  typedef const value_type& const_reference;$/;"	t	class:vector	access:public
const_rend	stl_rope.h	/^	const_reverse_iterator const_rend() const {$/;"	f	class:rope	access:public	signature:() const
const_reverse_iterator	stl_bvector.h	/^                           difference_type> const_reverse_iterator;$/;"	t	class:vector	access:public
const_reverse_iterator	stl_bvector.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:vector	access:public
const_reverse_iterator	stl_deque.h	/^          const_reverse_iterator;$/;"	t	class:__deque_iterator::deque	access:public
const_reverse_iterator	stl_deque.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:__deque_iterator::deque	access:public
const_reverse_iterator	stl_list.h	/^  const_reverse_iterator;$/;"	t	class:list	access:public
const_reverse_iterator	stl_list.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:list	access:public
const_reverse_iterator	stl_map.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:map	access:public
const_reverse_iterator	stl_multimap.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:multimap	access:public
const_reverse_iterator	stl_multiset.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:multiset	access:public
const_reverse_iterator	stl_rope.h	/^				 difference_type>  const_reverse_iterator;$/;"	t	class:rope	access:public
const_reverse_iterator	stl_rope.h	/^        typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:rope	access:public
const_reverse_iterator	stl_set.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:set	access:public
const_reverse_iterator	stl_tree.h	/^          const_reverse_iterator;$/;"	t	class:rb_tree	access:public
const_reverse_iterator	stl_tree.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:rb_tree	access:public
const_reverse_iterator	stl_vector.h	/^                           difference_type>  const_reverse_iterator;$/;"	t	class:vector	access:public
const_reverse_iterator	stl_vector.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:vector	access:public
constant0	stl_function.h	/^inline constant_void_fun<Result> constant0(const Result& val)$/;"	f	signature:(const Result& val)
constant1	stl_function.h	/^inline constant_unary_fun<Result,Result> constant1(const Result& val)$/;"	f	signature:(const Result& val)
constant2	stl_function.h	/^inline constant_binary_fun<Result,Result,Result> constant2(const Result& val)$/;"	f	signature:(const Result& val)
constant_binary_fun	stl_function.h	/^  constant_binary_fun(const Result& v) : val(v) {}$/;"	f	struct:constant_binary_fun	access:public	signature:(const Result& v)
constant_binary_fun	stl_function.h	/^struct constant_binary_fun : public binary_function<Arg1, Arg2, Result> {$/;"	s	inherits:binary_function
constant_binary_fun::constant_binary_fun	stl_function.h	/^  constant_binary_fun(const Result& v) : val(v) {}$/;"	f	struct:constant_binary_fun	access:public	signature:(const Result& v)
constant_binary_fun::operator ()	stl_function.h	/^  const Result& operator()(const Arg1&, const Arg2&) const {$/;"	f	struct:constant_binary_fun	access:public	signature:(const Arg1&, const Arg2&) const
constant_binary_fun::val	stl_function.h	/^  Result val;$/;"	m	struct:constant_binary_fun	access:public
constant_unary_fun	stl_function.h	/^  constant_unary_fun(const Result& v) : val(v) {}$/;"	f	struct:constant_unary_fun	access:public	signature:(const Result& v)
constant_unary_fun	stl_function.h	/^struct constant_unary_fun : public unary_function<Argument, Result> {$/;"	s	inherits:unary_function
constant_unary_fun::constant_unary_fun	stl_function.h	/^  constant_unary_fun(const Result& v) : val(v) {}$/;"	f	struct:constant_unary_fun	access:public	signature:(const Result& v)
constant_unary_fun::operator ()	stl_function.h	/^  const Result& operator()(const Argument&) const { return val; }$/;"	f	struct:constant_unary_fun	access:public	signature:(const Argument&) const
constant_unary_fun::val	stl_function.h	/^  Result val;$/;"	m	struct:constant_unary_fun	access:public
constant_void_fun	stl_function.h	/^  constant_void_fun(const result_type& v) : val(v) {}$/;"	f	struct:constant_void_fun	access:public	signature:(const result_type& v)
constant_void_fun	stl_function.h	/^struct constant_void_fun$/;"	s
constant_void_fun::constant_void_fun	stl_function.h	/^  constant_void_fun(const result_type& v) : val(v) {}$/;"	f	struct:constant_void_fun	access:public	signature:(const result_type& v)
constant_void_fun::operator ()	stl_function.h	/^  const result_type& operator()() const { return val; }$/;"	f	struct:constant_void_fun	access:public	signature:() const
constant_void_fun::result_type	stl_function.h	/^  typedef Result result_type;$/;"	t	struct:constant_void_fun	access:public
constant_void_fun::val	stl_function.h	/^  result_type val;$/;"	m	struct:constant_void_fun	access:public
construct	stl_construct.h	/^inline void construct(T1* p, const T2& value) {$/;"	f	signature:(T1* p, const T2& value)
container	stl_iterator.h	/^  Container* container;$/;"	m	class:back_insert_iterator	access:protected
container	stl_iterator.h	/^  Container* container;$/;"	m	class:front_insert_iterator	access:protected
container	stl_iterator.h	/^  Container* container;$/;"	m	class:insert_iterator	access:protected
container	stl_rope.h	/^    rope<charT,Alloc>& container() { return *root_rope; }$/;"	f	class:__rope_iterator	access:public	signature:()
copy	stl_algobase.h	/^inline OutputIterator copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result)
copy	stl_algobase.h	/^inline char* copy(const char* first, const char* last, char* result) {$/;"	f	signature:(const char* first, const char* last, char* result)
copy	stl_algobase.h	/^inline wchar_t* copy(const wchar_t* first, const wchar_t* last,$/;"	f	signature:(const wchar_t* first, const wchar_t* last, wchar_t* result)
copy	stl_rope.h	/^	      size_type copy(charT *buffer, size_type n, size_type pos = 0)$/;"	f	class:rope	access:public	signature:(charT *buffer, size_type n, size_type pos = 0) const
copy	stl_rope.h	/^	size_type copy(size_type pos, size_type n, charT *buffer) const {$/;"	f	class:rope	access:public	signature:(size_type pos, size_type n, charT *buffer) const
copy	stl_rope.h	/^	void copy(charT * buffer) const {$/;"	f	class:rope	access:public	signature:(charT * buffer) const
copy_backward	stl_algobase.h	/^inline BidirectionalIterator2 copy_backward(BidirectionalIterator1 first, $/;"	f	signature:(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 result)
copy_from	stl_hashtable.h	/^  void copy_from(const hashtable& ht);$/;"	p	class:hashtable	access:private	signature:(const hashtable& ht)
copy_from	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::copy_from(const hashtable& ht)$/;"	f	class:hashtable	signature:(const hashtable& ht)
copy_max	stl_rope.h	/^	enum { copy_max = 23 };$/;"	e	enum:rope::__anon13
copy_n	stl_algobase.h	/^copy_n(InputIterator first, Size count,$/;"	f	signature:(InputIterator first, Size count, OutputIterator result)
count	ropeimpl.h	/^	size_t count;  \/\/ Number of nonmatching characters$/;"	m	class:__rope_find_char_char_consumer	access:public
count	stl_algo.h	/^count(InputIterator first, InputIterator last, const T& value) {$/;"	f	signature:(InputIterator first, InputIterator last, const T& value)
count	stl_algo.h	/^void count(InputIterator first, InputIterator last, const T& value,$/;"	f	signature:(InputIterator first, InputIterator last, const T& value, Size& n)
count	stl_hash_map.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_map	access:public	signature:(const key_type& key) const
count	stl_hash_map.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_multimap	access:public	signature:(const key_type& key) const
count	stl_hash_set.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_multiset	access:public	signature:(const key_type& key) const
count	stl_hash_set.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_set	access:public	signature:(const key_type& key) const
count	stl_hashtable.h	/^  size_type count(const key_type& key) const$/;"	f	class:hashtable	access:public	signature:(const key_type& key) const
count	stl_map.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:map	access:public	signature:(const key_type& x) const
count	stl_multimap.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:multimap	access:public	signature:(const key_type& x) const
count	stl_multiset.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:multiset	access:public	signature:(const key_type& x) const
count	stl_set.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:set	access:public	signature:(const key_type& x) const
count	stl_tree.h	/^  size_type count(const key_type& x) const;$/;"	p	class:rb_tree	access:public	signature:(const key_type& x) const
count	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::count(const Key& k) const {$/;"	f	class:rb_tree	signature:(const Key& k) const
count_if	stl_algo.h	/^count_if(InputIterator first, InputIterator last, Predicate pred) {$/;"	f	signature:(InputIterator first, InputIterator last, Predicate pred)
count_if	stl_algo.h	/^void count_if(InputIterator first, InputIterator last, Predicate pred,$/;"	f	signature:(InputIterator first, InputIterator last, Predicate pred, Size& n)
create_map_and_nodes	stl_deque.h	/^  void create_map_and_nodes(size_type num_elements);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(size_type num_elements)
create_map_and_nodes	stl_deque.h	/^void deque<T, Alloc, BufSize>::create_map_and_nodes(size_type num_elements) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type num_elements)
create_node	stl_list.h	/^  link_type create_node(const T& x) {$/;"	f	class:list	access:protected	signature:(const T& x)
create_node	stl_slist.h	/^  static list_node* create_node(const value_type& x) {$/;"	f	class:slist	access:private	signature:(const value_type& x)
create_node	stl_tree.h	/^  link_type create_node(const value_type& x) {$/;"	f	class:rb_tree	access:protected	signature:(const value_type& x)
crope	stl_rope.h	/^typedef rope<char, __ALLOC> crope;$/;"	t
cstrptr	stl_rope.h	/^	typedef __GC_CONST charT * cstrptr;$/;"	t	class:rope	access:protected
cur	stl_deque.h	/^  T* cur;$/;"	m	struct:__deque_iterator::__deque_iterator	access:public
cur	stl_hashtable.h	/^  const node* cur;$/;"	m	struct:__hashtable_const_iterator	access:public
cur	stl_hashtable.h	/^  node* cur;$/;"	m	struct:__hashtable_iterator	access:public
current	stl_iterator.h	/^  BidirectionalIterator current;$/;"	m	class:reverse_bidirectional_iterator	access:protected
current	stl_iterator.h	/^  Iterator current;$/;"	m	class:reverse_iterator	access:protected
current	stl_iterator.h	/^  RandomAccessIterator current;$/;"	m	class:reverse_iterator	access:protected
current	stl_rope.h	/^    charT current;$/;"	m	class:__rope_charT_ptr_proxy	access:private
current	stl_rope.h	/^    charT current;$/;"	m	class:__rope_charT_ref_proxy	access:private
current_pos	stl_rope.h	/^    size_t current_pos;$/;"	m	class:__rope_iterator_base	access:protected
current_valid	stl_rope.h	/^    bool current_valid;$/;"	m	class:__rope_charT_ptr_proxy	access:private
current_valid	stl_rope.h	/^    bool current_valid;$/;"	m	class:__rope_charT_ref_proxy	access:private
data	stl_list.h	/^  T data;$/;"	m	struct:__list_node	access:public
data	stl_rope.h	/^    __GC_CONST charT* data;     \/* Not necessarily 0 terminated. *\/$/;"	m	struct:__rope_RopeLeaf	access:public
data	stl_slist.h	/^  T data;$/;"	m	struct:__slist_node	access:public
data_allocator	stl_bvector.h	/^  typedef simple_alloc<unsigned int, Alloc> data_allocator;$/;"	t	class:vector	access:private
data_allocator	stl_deque.h	/^  typedef simple_alloc<value_type, Alloc> data_allocator;$/;"	t	class:__deque_iterator::deque	access:protected
data_allocator	stl_vector.h	/^  typedef simple_alloc<value_type, Alloc> data_allocator;$/;"	t	class:vector	access:protected
data_type	stl_hash_map.h	/^  typedef T data_type;$/;"	t	class:hash_map	access:public
data_type	stl_hash_map.h	/^  typedef T data_type;$/;"	t	class:hash_multimap	access:public
data_type	stl_map.h	/^  typedef T data_type;$/;"	t	class:map	access:public
data_type	stl_multimap.h	/^  typedef T data_type;$/;"	t	class:multimap	access:public
deallocate	defalloc.h	/^    void deallocate(pointer p) { ::deallocate(p); }$/;"	f	class:allocator	access:public	signature:(pointer p)
deallocate	defalloc.h	/^inline void deallocate(T* buffer) {$/;"	f	signature:(T* buffer)
deallocate	stl_alloc.h	/^    static void deallocate(T *p)$/;"	f	class:simple_alloc	access:public	signature:(T *p)
deallocate	stl_alloc.h	/^    static void deallocate(T *p, size_t n)$/;"	f	class:simple_alloc	access:public	signature:(T *p, size_t n)
deallocate	stl_alloc.h	/^  static void deallocate(void *p, size_t n)$/;"	f	class:__default_alloc_template	access:public	signature:(void *p, size_t n)
deallocate	stl_alloc.h	/^static void deallocate(void *p, size_t \/* n *\/)$/;"	f	class:__malloc_alloc_template	access:public	signature:(void *p, size_t )
deallocate	stl_alloc.h	/^static void deallocate(void *p, size_t n)$/;"	f	class:debug_alloc	access:public	signature:(void *p, size_t n)
deallocate	stl_bvector.h	/^  void deallocate() {$/;"	f	class:vector	access:protected	signature:()
deallocate	stl_vector.h	/^  void deallocate() {$/;"	f	class:vector	access:protected	signature:()
deallocate_node	stl_deque.h	/^  void deallocate_node(pointer n) {$/;"	f	class:__deque_iterator::deque	access:protected	signature:(pointer n)
debug_alloc	stl_alloc.h	/^class debug_alloc {$/;"	c
debug_alloc::allocate	stl_alloc.h	/^static void * allocate(size_t n)$/;"	f	class:debug_alloc	access:public	signature:(size_t n)
debug_alloc::deallocate	stl_alloc.h	/^static void deallocate(void *p, size_t n)$/;"	f	class:debug_alloc	access:public	signature:(void *p, size_t n)
debug_alloc::extra	stl_alloc.h	/^enum {extra = 8};       \/\/ Size of space used to store size.  Note$/;"	e	enum:debug_alloc::__anon1
debug_alloc::reallocate	stl_alloc.h	/^static void * reallocate(void *p, size_t old_sz, size_t new_sz)$/;"	f	class:debug_alloc	access:public	signature:(void *p, size_t old_sz, size_t new_sz)
decr	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::decr(size_t n) {$/;"	f	class:__rope_iterator_base	signature:(size_t n)
decr	stl_rope.h	/^    void decr(size_t n);$/;"	p	class:__rope_iterator_base	access:protected	signature:(size_t n)
decr_refcount	stl_rope.h	/^	    size_t decr_refcount ()$/;"	f	struct:__rope_RopeBase	access:public	signature:()
decr_refcount	stl_rope.h	/^            size_t decr_refcount ()$/;"	f	struct:__rope_RopeBase	access:public	signature:()
decrement	stl_tree.h	/^  void decrement()$/;"	f	struct:__rb_tree_base_iterator	access:public	signature:()
delete_c_str	stl_rope.h	/^	void delete_c_str () {$/;"	f	class:rope	access:public	signature:()
delete_node	stl_hashtable.h	/^  void delete_node(node* n)$/;"	f	class:hashtable	access:private	signature:(node* n)
delete_when_done	stl_rope.h	/^      bool delete_when_done;	\/\/ Char_producer is owned by the$/;"	m	struct:__rope_RopeFunction	access:public
depth	stl_rope.h	/^    unsigned char depth;$/;"	m	struct:__rope_RopeBase	access:public
deque	stl_deque.h	/^  deque()$/;"	f	class:__deque_iterator::deque	access:public	signature:()
deque	stl_deque.h	/^  deque(InputIterator first, InputIterator last)$/;"	f	class:__deque_iterator::deque	access:public	signature:(InputIterator first, InputIterator last)
deque	stl_deque.h	/^  deque(const deque& x)$/;"	f	class:__deque_iterator::deque	access:public	signature:(const deque& x)
deque	stl_deque.h	/^  deque(const value_type* first, const value_type* last)$/;"	f	class:__deque_iterator::deque	access:public	signature:(const value_type* first, const value_type* last)
deque	stl_deque.h	/^  deque(const_iterator first, const_iterator last)$/;"	f	class:__deque_iterator::deque	access:public	signature:(const_iterator first, const_iterator last)
deque	stl_deque.h	/^  deque(int n, const value_type& value)$/;"	f	class:__deque_iterator::deque	access:public	signature:(int n, const value_type& value)
deque	stl_deque.h	/^  deque(long n, const value_type& value)$/;"	f	class:__deque_iterator::deque	access:public	signature:(long n, const value_type& value)
deque	stl_deque.h	/^  deque(size_type n, const value_type& value)$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type n, const value_type& value)
deque	stl_deque.h	/^  explicit deque(size_type n)$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type n)
deque	stl_deque.h	/^class deque {$/;"	c	struct:__deque_iterator	access:public
destr_concat_char_iter	ropeimpl.h	/^::destr_concat_char_iter$/;"	f	class:rope	signature:(RopeBase * r, const charT *s, size_t slen)
destr_concat_char_iter	stl_rope.h	/^	static RopeBase * destr_concat_char_iter(RopeBase * r,$/;"	f	class:rope	access:protected	signature:(RopeBase * r, const charT *iter, size_t slen)
destr_leaf_concat_char_iter	ropeimpl.h	/^rope<charT,Alloc>::destr_leaf_concat_char_iter$/;"	f	class:rope	signature:(RopeLeaf * r, const charT * iter, size_t len)
destr_leaf_concat_char_iter	stl_rope.h	/^	  static RopeLeaf * destr_leaf_concat_char_iter$/;"	p	class:rope	access:protected	signature:(RopeLeaf * r, const charT * iter, size_t slen)
destroy	stl_construct.h	/^inline void destroy(ForwardIterator first, ForwardIterator last) {$/;"	f	signature:(ForwardIterator first, ForwardIterator last)
destroy	stl_construct.h	/^inline void destroy(T* pointer) {$/;"	f	signature:(T* pointer)
destroy	stl_construct.h	/^inline void destroy(char*, char*) {}$/;"	f	signature:(char*, char*)
destroy	stl_construct.h	/^inline void destroy(wchar_t*, wchar_t*) {}$/;"	f	signature:(wchar_t*, wchar_t*)
destroy_map_and_nodes	stl_deque.h	/^  void destroy_map_and_nodes();$/;"	p	class:__deque_iterator::deque	access:protected	signature:()
destroy_map_and_nodes	stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_map_and_nodes() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
destroy_node	stl_list.h	/^  void destroy_node(link_type p) {$/;"	f	class:list	access:protected	signature:(link_type p)
destroy_node	stl_slist.h	/^  static void destroy_node(list_node* node) {$/;"	f	class:slist	access:private	signature:(list_node* node)
destroy_node	stl_tree.h	/^  void destroy_node(link_type p) {$/;"	f	class:rb_tree	access:protected	signature:(link_type p)
destroy_nodes_at_back	stl_deque.h	/^  void destroy_nodes_at_back(iterator after_finish);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator after_finish)
destroy_nodes_at_back	stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_nodes_at_back(iterator after_finish) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator after_finish)
destroy_nodes_at_front	stl_deque.h	/^  void destroy_nodes_at_front(iterator before_start);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator before_start)
destroy_nodes_at_front	stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_nodes_at_front(iterator before_start) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator before_start)
difference_type	defalloc.h	/^    typedef ptrdiff_t difference_type;$/;"	t	class:allocator	access:public
difference_type	stl_bvector.h	/^  typedef ptrdiff_t difference_type; $/;"	t	class:vector	access:public
difference_type	stl_deque.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:__deque_iterator::deque	access:public
difference_type	stl_deque.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
difference_type	stl_hash_map.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_map	access:public
difference_type	stl_hash_map.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_multimap	access:public
difference_type	stl_hash_set.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_multiset	access:public
difference_type	stl_hash_set.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_set	access:public
difference_type	stl_hashtable.h	/^  typedef ptrdiff_t         difference_type;$/;"	t	class:hashtable	access:public
difference_type	stl_hashtable.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__hashtable_const_iterator	access:public
difference_type	stl_hashtable.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__hashtable_iterator	access:public
difference_type	stl_iterator.h	/^          difference_type;$/;"	t	class:reverse_iterator	access:public
difference_type	stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	class:reverse_bidirectional_iterator	access:public
difference_type	stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	class:reverse_iterator	access:public
difference_type	stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	struct:bidirectional_iterator	access:public
difference_type	stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	struct:random_access_iterator	access:public
difference_type	stl_iterator.h	/^  typedef Distance             difference_type;$/;"	t	struct:forward_iterator	access:public
difference_type	stl_iterator.h	/^  typedef Distance           difference_type;$/;"	t	class:istream_iterator	access:public
difference_type	stl_iterator.h	/^  typedef Distance           difference_type;$/;"	t	struct:input_iterator	access:public
difference_type	stl_iterator.h	/^  typedef Distance  difference_type;$/;"	t	struct:iterator	access:public
difference_type	stl_iterator.h	/^  typedef ptrdiff_t                  difference_type;$/;"	t	struct:iterator_traits	access:public
difference_type	stl_iterator.h	/^  typedef typename Iterator::difference_type   difference_type;$/;"	t	struct:iterator_traits	access:public
difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:back_insert_iterator	access:public
difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:front_insert_iterator	access:public
difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:insert_iterator	access:public
difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:ostream_iterator	access:public
difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	struct:output_iterator	access:public
difference_type	stl_list.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:list	access:public
difference_type	stl_list.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__list_iterator	access:public
difference_type	stl_map.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:map	access:public
difference_type	stl_multimap.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:multimap	access:public
difference_type	stl_multiset.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:multiset	access:public
difference_type	stl_raw_storage_iter.h	/^  typedef void                difference_type;$/;"	t	class:raw_storage_iterator	access:public
difference_type	stl_rope.h	/^	typedef ptrdiff_t difference_type;$/;"	t	class:rope	access:public
difference_type	stl_set.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:set	access:public
difference_type	stl_slist.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:slist	access:public
difference_type	stl_slist.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__slist_iterator_base	access:public
difference_type	stl_tree.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:rb_tree	access:public
difference_type	stl_tree.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__rb_tree_base_iterator	access:public
difference_type	stl_vector.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:vector	access:public
distance	stl_iterator.h	/^distance(InputIterator first, InputIterator last) {$/;"	f	signature:(InputIterator first, InputIterator last)
distance	stl_iterator.h	/^inline void distance(InputIterator first, InputIterator last, Distance& n) {$/;"	f	signature:(InputIterator first, InputIterator last, Distance& n)
distance_type	stl_deque.h	/^inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {$/;"	f	struct:__deque_iterator	access:public	signature:(const __deque_iterator<T, Ref, Ptr, BufSiz>&)
distance_type	stl_deque.h	/^inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr>&) {$/;"	f	struct:__deque_iterator	access:public	signature:(const __deque_iterator<T, Ref, Ptr>&)
distance_type	stl_hashtable.h	/^distance_type(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f	signature:(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)
distance_type	stl_hashtable.h	/^distance_type(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f	signature:(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)
distance_type	stl_iterator.h	/^distance_type(const Iterator&) {$/;"	f	signature:(const Iterator&)
distance_type	stl_iterator.h	/^distance_type(const bidirectional_iterator<T, Distance>&) {$/;"	f	signature:(const bidirectional_iterator<T, Distance>&)
distance_type	stl_iterator.h	/^distance_type(const random_access_iterator<T, Distance>&) {$/;"	f	signature:(const random_access_iterator<T, Distance>&)
distance_type	stl_iterator.h	/^distance_type(const reverse_bidirectional_iterator<BidirectionalIterator, T,$/;"	f	signature:(const reverse_bidirectional_iterator<BidirectionalIterator, T, Reference, Distance>&)
distance_type	stl_iterator.h	/^inline Distance* distance_type(const forward_iterator<T, Distance>&) {$/;"	f	signature:(const forward_iterator<T, Distance>&)
distance_type	stl_iterator.h	/^inline Distance* distance_type(const input_iterator<T, Distance>&) {$/;"	f	signature:(const input_iterator<T, Distance>&)
distance_type	stl_iterator.h	/^inline Distance* distance_type(const istream_iterator<T, Distance>&) {$/;"	f	signature:(const istream_iterator<T, Distance>&)
distance_type	stl_iterator.h	/^inline Distance* distance_type(const reverse_iterator<RandomAccessIterator, T,$/;"	f	signature:(const reverse_iterator<RandomAccessIterator, T, Reference, Distance>&)
distance_type	stl_iterator.h	/^inline ptrdiff_t* distance_type(const T*) { return (ptrdiff_t*)(0); }$/;"	f	signature:(const T*)
distance_type	stl_list.h	/^distance_type(const __list_iterator<T, Ref, Ptr>&) {$/;"	f	signature:(const __list_iterator<T, Ref, Ptr>&)
distance_type	stl_slist.h	/^distance_type(const __slist_iterator_base&)$/;"	f	signature:(const __slist_iterator_base&)
distance_type	stl_tree.h	/^distance_type(const __rb_tree_base_iterator&) {$/;"	f	signature:(const __rb_tree_base_iterator&)
divides	stl_function.h	/^struct divides : public binary_function<T, T, T> {$/;"	s	inherits:binary_function
divides::operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x \/ y; }$/;"	f	struct:divides	access:public	signature:(const T& x, const T& y) const
dump	ropeimpl.h	/^rope<charT,Alloc>::dump(RopeBase * r, int indent)$/;"	f	class:rope	signature:(RopeBase * r, int indent)
dump	stl_rope.h	/^	static void dump(RopeBase * r, int indent = 0);$/;"	p	class:rope	access:protected	signature:(RopeBase * r, int indent = 0)
dump	stl_rope.h	/^	void dump() {$/;"	f	class:rope	access:public	signature:()
elems_in_bucket	stl_hash_map.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_map	access:public	signature:(size_type n) const
elems_in_bucket	stl_hash_map.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_multimap	access:public	signature:(size_type n) const
elems_in_bucket	stl_hash_set.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_multiset	access:public	signature:(size_type n) const
elems_in_bucket	stl_hash_set.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_set	access:public	signature:(size_type n) const
elems_in_bucket	stl_hashtable.h	/^  size_type elems_in_bucket(size_type bucket) const$/;"	f	class:hashtable	access:public	signature:(size_type bucket) const
empty	stl_bvector.h	/^  bool empty() const { return begin() == end(); }$/;"	f	class:vector	access:public	signature:() const
empty	stl_deque.h	/^  bool empty() const { return finish == start; }$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
empty	stl_hash_map.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_map	access:public	signature:() const
empty	stl_hash_map.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_multimap	access:public	signature:() const
empty	stl_hash_set.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_multiset	access:public	signature:() const
empty	stl_hash_set.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_set	access:public	signature:() const
empty	stl_hashtable.h	/^  bool empty() const { return size() == 0; }$/;"	f	class:hashtable	access:public	signature:() const
empty	stl_list.h	/^  bool empty() const { return node->next == node; }$/;"	f	class:list	access:public	signature:() const
empty	stl_map.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:map	access:public	signature:() const
empty	stl_multimap.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:multimap	access:public	signature:() const
empty	stl_multiset.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:multiset	access:public	signature:() const
empty	stl_queue.h	/^  bool empty() const { return c.empty(); }$/;"	f	class:priority_queue	access:public	signature:() const
empty	stl_queue.h	/^  bool empty() const { return c.empty(); }$/;"	f	class:queue	access:public	signature:() const
empty	stl_rope.h	/^	bool empty() const { return 0 == tree_ptr; }$/;"	f	class:rope	access:public	signature:() const
empty	stl_set.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:set	access:public	signature:() const
empty	stl_slist.h	/^  bool empty() const { return head.next == 0; }$/;"	f	class:slist	access:public	signature:() const
empty	stl_stack.h	/^  bool empty() const { return c.empty(); }$/;"	f	class:stack	access:public	signature:() const
empty	stl_tree.h	/^  bool empty() const { return node_count == 0; }$/;"	f	class:rb_tree	access:public	signature:() const
empty	stl_vector.h	/^  bool empty() const { return begin() == end(); }$/;"	f	class:vector	access:public	signature:() const
empty_c_str	ropeimpl.h	/^template<class charT, class Alloc> charT rope<charT,Alloc>::empty_c_str[1];$/;"	m	class:rope
empty_c_str	stl_rope.h	/^	static charT empty_c_str[1];$/;"	m	class:rope	access:protected
empty_initialize	stl_list.h	/^  void empty_initialize() { $/;"	f	class:list	access:protected	signature:()
end	stl_bvector.h	/^  const_iterator end() const { return finish; }$/;"	f	class:vector	access:public	signature:() const
end	stl_bvector.h	/^  iterator end() { return finish; }$/;"	f	class:vector	access:public	signature:()
end	stl_deque.h	/^  const_iterator end() const { return finish; }$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
end	stl_deque.h	/^  iterator end() { return finish; }$/;"	f	class:__deque_iterator::deque	access:public	signature:()
end	stl_hash_map.h	/^  const_iterator end() const { return rep.end(); }$/;"	f	class:hash_map	access:public	signature:() const
end	stl_hash_map.h	/^  const_iterator end() const { return rep.end(); }$/;"	f	class:hash_multimap	access:public	signature:() const
end	stl_hash_map.h	/^  iterator end() { return rep.end(); }$/;"	f	class:hash_map	access:public	signature:()
end	stl_hash_map.h	/^  iterator end() { return rep.end(); }$/;"	f	class:hash_multimap	access:public	signature:()
end	stl_hash_set.h	/^  iterator end() const { return rep.end(); }$/;"	f	class:hash_multiset	access:public	signature:() const
end	stl_hash_set.h	/^  iterator end() const { return rep.end(); }$/;"	f	class:hash_set	access:public	signature:() const
end	stl_hashtable.h	/^  const_iterator end() const { return const_iterator(0, this); }$/;"	f	class:hashtable	access:public	signature:() const
end	stl_hashtable.h	/^  iterator end() { return iterator(0, this); }$/;"	f	class:hashtable	access:public	signature:()
end	stl_list.h	/^  const_iterator end() const { return node; }$/;"	f	class:list	access:public	signature:() const
end	stl_list.h	/^  iterator end() { return node; }$/;"	f	class:list	access:public	signature:()
end	stl_map.h	/^  const_iterator end() const { return t.end(); }$/;"	f	class:map	access:public	signature:() const
end	stl_map.h	/^  iterator end() { return t.end(); }$/;"	f	class:map	access:public	signature:()
end	stl_multimap.h	/^  const_iterator end() const { return t.end(); }$/;"	f	class:multimap	access:public	signature:() const
end	stl_multimap.h	/^  iterator end() { return t.end(); }$/;"	f	class:multimap	access:public	signature:()
end	stl_multiset.h	/^  iterator end() const { return t.end(); }$/;"	f	class:multiset	access:public	signature:() const
end	stl_rope.h	/^	    const_iterator end() { return const_end(); }$/;"	f	class:rope	access:public	signature:()
end	stl_rope.h	/^	    iterator end() { return mutable_end(); }$/;"	f	class:rope	access:public	signature:()
end	stl_rope.h	/^	const_iterator end() const {$/;"	f	class:rope	access:public	signature:() const
end	stl_set.h	/^  iterator end() const { return t.end(); }$/;"	f	class:set	access:public	signature:() const
end	stl_slist.h	/^  const_iterator end() const { return const_iterator(0); }$/;"	f	class:slist	access:public	signature:() const
end	stl_slist.h	/^  iterator end() { return iterator(0); }$/;"	f	class:slist	access:public	signature:()
end	stl_tempbuf.h	/^  T* end() { return buffer + len; }$/;"	f	class:temporary_buffer	access:public	signature:()
end	stl_tree.h	/^  const_iterator end() const { return header; }$/;"	f	class:rb_tree	access:public	signature:() const
end	stl_tree.h	/^  iterator end() { return header; }$/;"	f	class:rb_tree	access:public	signature:()
end	stl_vector.h	/^  const_iterator end() const { return finish; }$/;"	f	class:vector	access:public	signature:() const
end	stl_vector.h	/^  iterator end() { return finish; }$/;"	f	class:vector	access:public	signature:()
end_free	stl_alloc.h	/^  static char *end_free;$/;"	m	class:__default_alloc_template	access:private
end_free	stl_alloc.h	/^char *__default_alloc_template<threads, inst>::end_free = 0;$/;"	m	class:__default_alloc_template
end_marker	stl_iterator.h	/^  bool end_marker;$/;"	m	class:istream_iterator	access:protected
end_of_storage	stl_bvector.h	/^  unsigned int* end_of_storage;$/;"	m	class:vector	access:protected
end_of_storage	stl_vector.h	/^  iterator end_of_storage;$/;"	m	class:vector	access:protected
equal	stl_algobase.h	/^inline bool equal(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
equal	stl_algobase.h	/^inline bool equal(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred)
equal_range	stl_algo.h	/^equal_range(ForwardIterator first, ForwardIterator last, const T& value) {$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value)
equal_range	stl_algo.h	/^equal_range(ForwardIterator first, ForwardIterator last, const T& value,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value, Compare comp)
equal_range	stl_hash_map.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& key) const$/;"	f	class:hash_map	access:public	signature:(const key_type& key) const
equal_range	stl_hash_map.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& key) const$/;"	f	class:hash_multimap	access:public	signature:(const key_type& key) const
equal_range	stl_hash_map.h	/^  pair<iterator, iterator> equal_range(const key_type& key)$/;"	f	class:hash_map	access:public	signature:(const key_type& key)
equal_range	stl_hash_map.h	/^  pair<iterator, iterator> equal_range(const key_type& key)$/;"	f	class:hash_multimap	access:public	signature:(const key_type& key)
equal_range	stl_hash_set.h	/^  pair<iterator, iterator> equal_range(const key_type& key) const$/;"	f	class:hash_multiset	access:public	signature:(const key_type& key) const
equal_range	stl_hash_set.h	/^  pair<iterator, iterator> equal_range(const key_type& key) const$/;"	f	class:hash_set	access:public	signature:(const key_type& key) const
equal_range	stl_hashtable.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& key) const;$/;"	p	class:hashtable	access:public	signature:(const key_type& key) const
equal_range	stl_hashtable.h	/^  pair<iterator, iterator> equal_range(const key_type& key);$/;"	p	class:hashtable	access:public	signature:(const key_type& key)
equal_range	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key) const$/;"	f	class:hashtable	signature:(const key_type& key) const
equal_range	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key)$/;"	f	class:hashtable	signature:(const key_type& key)
equal_range	stl_map.h	/^  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {$/;"	f	class:map	access:public	signature:(const key_type& x) const
equal_range	stl_map.h	/^  pair<iterator,iterator> equal_range(const key_type& x) {$/;"	f	class:map	access:public	signature:(const key_type& x)
equal_range	stl_multimap.h	/^   pair<iterator,iterator> equal_range(const key_type& x) {$/;"	f	class:multimap	access:public	signature:(const key_type& x)
equal_range	stl_multimap.h	/^  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {$/;"	f	class:multimap	access:public	signature:(const key_type& x) const
equal_range	stl_multiset.h	/^  pair<iterator,iterator> equal_range(const key_type& x) const {$/;"	f	class:multiset	access:public	signature:(const key_type& x) const
equal_range	stl_set.h	/^  pair<iterator,iterator> equal_range(const key_type& x) const {$/;"	f	class:set	access:public	signature:(const key_type& x) const
equal_range	stl_tree.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& x) const;$/;"	p	class:rb_tree	access:public	signature:(const key_type& x) const
equal_range	stl_tree.h	/^  pair<iterator,iterator> equal_range(const key_type& x);$/;"	p	class:rb_tree	access:public	signature:(const key_type& x)
equal_range	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::equal_range(const Key& k) {$/;"	f	class:rb_tree	signature:(const Key& k)
equal_range	stl_tree.h	/^rb_tree<Key, Value, KoV, Compare, Alloc>::equal_range(const Key& k) const {$/;"	f	class:rb_tree	signature:(const Key& k) const
equal_to	stl_function.h	/^struct equal_to : public binary_function<T, T, bool> {$/;"	s	inherits:binary_function
equal_to::operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x == y; }$/;"	f	struct:equal_to	access:public	signature:(const T& x, const T& y) const
equals	stl_hashtable.h	/^  key_equal equals;$/;"	m	class:hashtable	access:private
erase	stl_bvector.h	/^  iterator erase(iterator first, iterator last) {$/;"	f	class:vector	access:public	signature:(iterator first, iterator last)
erase	stl_bvector.h	/^  iterator erase(iterator position) {$/;"	f	class:vector	access:public	signature:(iterator position)
erase	stl_deque.h	/^  iterator erase(iterator first, iterator last);$/;"	p	class:__deque_iterator::deque	access:public	signature:(iterator first, iterator last)
erase	stl_deque.h	/^  iterator erase(iterator pos) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos)
erase	stl_deque.h	/^deque<T, Alloc, BufSize>::erase(iterator first, iterator last) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator first, iterator last)
erase	stl_hash_map.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_map	access:public	signature:(const key_type& key)
erase	stl_hash_map.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_multimap	access:public	signature:(const key_type& key)
erase	stl_hash_map.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_map	access:public	signature:(iterator f, iterator l)
erase	stl_hash_map.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_multimap	access:public	signature:(iterator f, iterator l)
erase	stl_hash_map.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_map	access:public	signature:(iterator it)
erase	stl_hash_map.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_multimap	access:public	signature:(iterator it)
erase	stl_hash_set.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_multiset	access:public	signature:(const key_type& key)
erase	stl_hash_set.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_set	access:public	signature:(const key_type& key)
erase	stl_hash_set.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_multiset	access:public	signature:(iterator f, iterator l)
erase	stl_hash_set.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_set	access:public	signature:(iterator f, iterator l)
erase	stl_hash_set.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_multiset	access:public	signature:(iterator it)
erase	stl_hash_set.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_set	access:public	signature:(iterator it)
erase	stl_hashtable.h	/^  size_type erase(const key_type& key);$/;"	p	class:hashtable	access:public	signature:(const key_type& key)
erase	stl_hashtable.h	/^  void erase(const const_iterator& it);$/;"	p	class:hashtable	access:public	signature:(const const_iterator& it)
erase	stl_hashtable.h	/^  void erase(const iterator& it);$/;"	p	class:hashtable	access:public	signature:(const iterator& it)
erase	stl_hashtable.h	/^  void erase(const_iterator first, const_iterator last);$/;"	p	class:hashtable	access:public	signature:(const_iterator first, const_iterator last)
erase	stl_hashtable.h	/^  void erase(iterator first, iterator last);$/;"	p	class:hashtable	access:public	signature:(iterator first, iterator last)
erase	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const const_iterator& it)$/;"	f	class:hashtable	signature:(const const_iterator& it)
erase	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const key_type& key)$/;"	f	class:hashtable	signature:(const key_type& key)
erase	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const_iterator first,$/;"	f	class:hashtable	signature:(const_iterator first, const_iterator last)
erase	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase(const iterator& it)$/;"	f	class:hashtable	signature:(const iterator& it)
erase	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase(iterator first, iterator last)$/;"	f	class:hashtable	signature:(iterator first, iterator last)
erase	stl_list.h	/^  iterator erase(iterator first, iterator last);$/;"	p	class:list	access:public	signature:(iterator first, iterator last)
erase	stl_list.h	/^  iterator erase(iterator position) {$/;"	f	class:list	access:public	signature:(iterator position)
erase	stl_list.h	/^list<T,Alloc>::iterator list<T, Alloc>::erase(iterator first, iterator last) {$/;"	f	class:list	signature:(iterator first, iterator last)
erase	stl_map.h	/^  size_type erase(const key_type& x) { return t.erase(x); }$/;"	f	class:map	access:public	signature:(const key_type& x)
erase	stl_map.h	/^  void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:map	access:public	signature:(iterator first, iterator last)
erase	stl_map.h	/^  void erase(iterator position) { t.erase(position); }$/;"	f	class:map	access:public	signature:(iterator position)
erase	stl_multimap.h	/^  size_type erase(const key_type& x) { return t.erase(x); }$/;"	f	class:multimap	access:public	signature:(const key_type& x)
erase	stl_multimap.h	/^  void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:multimap	access:public	signature:(iterator first, iterator last)
erase	stl_multimap.h	/^  void erase(iterator position) { t.erase(position); }$/;"	f	class:multimap	access:public	signature:(iterator position)
erase	stl_multiset.h	/^  size_type erase(const key_type& x) { $/;"	f	class:multiset	access:public	signature:(const key_type& x)
erase	stl_multiset.h	/^  void erase(iterator first, iterator last) { $/;"	f	class:multiset	access:public	signature:(iterator first, iterator last)
erase	stl_multiset.h	/^  void erase(iterator position) { $/;"	f	class:multiset	access:public	signature:(iterator position)
erase	stl_rope.h	/^	iterator erase(const iterator &p, const iterator &q) {$/;"	f	class:rope	access:public	signature:(const iterator &p, const iterator &q)
erase	stl_rope.h	/^	void erase(size_t p) {$/;"	f	class:rope	access:public	signature:(size_t p)
erase	stl_rope.h	/^	void erase(size_t p, size_t n) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n)
erase	stl_rope.h	/^        iterator erase(const iterator &p) {$/;"	f	class:rope	access:public	signature:(const iterator &p)
erase	stl_set.h	/^  size_type erase(const key_type& x) { $/;"	f	class:set	access:public	signature:(const key_type& x)
erase	stl_set.h	/^  void erase(iterator first, iterator last) { $/;"	f	class:set	access:public	signature:(iterator first, iterator last)
erase	stl_set.h	/^  void erase(iterator position) { $/;"	f	class:set	access:public	signature:(iterator position)
erase	stl_slist.h	/^  iterator erase(iterator first, iterator last) {$/;"	f	class:slist	access:public	signature:(iterator first, iterator last)
erase	stl_slist.h	/^  iterator erase(iterator pos) {$/;"	f	class:slist	access:public	signature:(iterator pos)
erase	stl_tree.h	/^  size_type erase(const key_type& x);$/;"	p	class:rb_tree	access:public	signature:(const key_type& x)
erase	stl_tree.h	/^  void erase(const key_type* first, const key_type* last);$/;"	p	class:rb_tree	access:public	signature:(const key_type* first, const key_type* last)
erase	stl_tree.h	/^  void erase(iterator first, iterator last);$/;"	p	class:rb_tree	access:public	signature:(iterator first, iterator last)
erase	stl_tree.h	/^  void erase(iterator position);$/;"	p	class:rb_tree	access:public	signature:(iterator position)
erase	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key& x) {$/;"	f	class:rb_tree	signature:(const Key& x)
erase	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator position) {$/;"	f	class:rb_tree	signature:(iterator position)
erase	stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key* first, $/;"	f	class:rb_tree	signature:(const Key* first, const Key* last)
erase	stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator first, $/;"	f	class:rb_tree	signature:(iterator first, iterator last)
erase	stl_vector.h	/^  iterator erase(iterator first, iterator last) {$/;"	f	class:vector	access:public	signature:(iterator first, iterator last)
erase	stl_vector.h	/^  iterator erase(iterator position) {$/;"	f	class:vector	access:public	signature:(iterator position)
erase_after	stl_slist.h	/^  iterator erase_after(iterator before_first, iterator last) {$/;"	f	class:slist	access:public	signature:(iterator before_first, iterator last)
erase_after	stl_slist.h	/^  iterator erase_after(iterator pos) {$/;"	f	class:slist	access:public	signature:(iterator pos)
erase_after	stl_slist.h	/^  list_node_base* erase_after(list_node_base* before_first,$/;"	f	class:slist	access:private	signature:(list_node_base* before_first, list_node_base* last_node)
erase_after	stl_slist.h	/^  list_node_base* erase_after(list_node_base* pos) {$/;"	f	class:slist	access:private	signature:(list_node_base* pos)
erase_bucket	stl_hashtable.h	/^  void erase_bucket(const size_type n, node* first, node* last);$/;"	p	class:hashtable	access:private	signature:(const size_type n, node* first, node* last)
erase_bucket	stl_hashtable.h	/^  void erase_bucket(const size_type n, node* last);$/;"	p	class:hashtable	access:private	signature:(const size_type n, node* last)
erase_bucket	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, node* last)$/;"	f	class:hashtable	signature:(const size_type n, node* last)
erase_bucket	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, $/;"	f	class:hashtable	signature:(const size_type n, node* first, node* last)
explicit	stl_config.h	181;"	d
extra	stl_alloc.h	/^enum {extra = 8};       \/\/ Size of space used to store size.  Note$/;"	e	enum:debug_alloc::__anon1
f	stl_function.h	/^  S (T::*f)() const;$/;"	m	class:const_mem_fun_ref_t	access:private
f	stl_function.h	/^  S (T::*f)() const;$/;"	m	class:const_mem_fun_t	access:private
f	stl_function.h	/^  S (T::*f)();$/;"	m	class:mem_fun_ref_t	access:private
f	stl_function.h	/^  S (T::*f)();$/;"	m	class:mem_fun_t	access:private
f	stl_function.h	/^  S (T::*f)(A) const;$/;"	m	class:const_mem_fun1_ref_t	access:private
f	stl_function.h	/^  S (T::*f)(A) const;$/;"	m	class:const_mem_fun1_t	access:private
f	stl_function.h	/^  S (T::*f)(A);$/;"	m	class:mem_fun1_ref_t	access:private
f	stl_function.h	/^  S (T::*f)(A);$/;"	m	class:mem_fun1_t	access:private
f	stl_function.h	/^  void (T::*f)() const;$/;"	m	class:const_mem_fun_ref_t	access:private
f	stl_function.h	/^  void (T::*f)() const;$/;"	m	class:const_mem_fun_t	access:private
f	stl_function.h	/^  void (T::*f)();$/;"	m	class:mem_fun_ref_t	access:private
f	stl_function.h	/^  void (T::*f)();$/;"	m	class:mem_fun_t	access:private
f	stl_function.h	/^  void (T::*f)(A) const;$/;"	m	class:const_mem_fun1_ref_t	access:private
f	stl_function.h	/^  void (T::*f)(A) const;$/;"	m	class:const_mem_fun1_t	access:private
f	stl_function.h	/^  void (T::*f)(A);$/;"	m	class:mem_fun1_ref_t	access:private
f	stl_function.h	/^  void (T::*f)(A);$/;"	m	class:mem_fun1_t	access:private
false	stl_config.h	173;"	d
fetch	ropeimpl.h	/^rope<charT,Alloc>::fetch(RopeBase *r, size_type i)$/;"	f	class:rope	signature:(RopeBase *r, size_type i)
fetch	stl_rope.h	/^	static charT fetch(RopeBase * r, size_type pos);$/;"	p	class:rope	access:protected	signature:(RopeBase * r, size_type pos)
fetch_ptr	ropeimpl.h	/^rope<charT,Alloc>::fetch_ptr(RopeBase *r, size_type i)$/;"	f	class:rope	signature:(RopeBase *r, size_type i)
fetch_ptr	stl_rope.h	/^	    static charT * fetch_ptr(RopeBase * r, size_type pos);$/;"	p	class:rope	access:protected	signature:(RopeBase * r, size_type pos)
fill	stl_algobase.h	/^void fill(ForwardIterator first, ForwardIterator last, const T& value) {$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value)
fill_initialize	stl_deque.h	/^  void fill_initialize(size_type n, const value_type& value);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(size_type n, const value_type& value)
fill_initialize	stl_deque.h	/^void deque<T, Alloc, BufSize>::fill_initialize(size_type n,$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type n, const value_type& value)
fill_initialize	stl_list.h	/^  void fill_initialize(size_type n, const T& value) {$/;"	f	class:list	access:protected	signature:(size_type n, const T& value)
fill_initialize	stl_slist.h	/^  void fill_initialize(size_type n, const value_type& x) {$/;"	f	class:slist	access:private	signature:(size_type n, const value_type& x)
fill_initialize	stl_vector.h	/^  void fill_initialize(size_type n, const T& value) {$/;"	f	class:vector	access:protected	signature:(size_type n, const T& value)
fill_n	stl_algobase.h	/^OutputIterator fill_n(OutputIterator first, Size n, const T& value) {$/;"	f	signature:(OutputIterator first, Size n, const T& value)
find	ropeimpl.h	/^rope<charT,Alloc>::find(charT pattern, size_t start) const$/;"	f	class:rope	signature:(charT pattern, size_t start) const
find	stl_algo.h	/^InputIterator find(InputIterator first, InputIterator last, const T& value) {$/;"	f	signature:(InputIterator first, InputIterator last, const T& value)
find	stl_hash_map.h	/^  const_iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_map	access:public	signature:(const key_type& key) const
find	stl_hash_map.h	/^  const_iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_multimap	access:public	signature:(const key_type& key) const
find	stl_hash_map.h	/^  iterator find(const key_type& key) { return rep.find(key); }$/;"	f	class:hash_map	access:public	signature:(const key_type& key)
find	stl_hash_map.h	/^  iterator find(const key_type& key) { return rep.find(key); }$/;"	f	class:hash_multimap	access:public	signature:(const key_type& key)
find	stl_hash_set.h	/^  iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_multiset	access:public	signature:(const key_type& key) const
find	stl_hash_set.h	/^  iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_set	access:public	signature:(const key_type& key) const
find	stl_hashtable.h	/^  const_iterator find(const key_type& key) const$/;"	f	class:hashtable	access:public	signature:(const key_type& key) const
find	stl_hashtable.h	/^  iterator find(const key_type& key) $/;"	f	class:hashtable	access:public	signature:(const key_type& key)
find	stl_map.h	/^  const_iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:map	access:public	signature:(const key_type& x) const
find	stl_map.h	/^  iterator find(const key_type& x) { return t.find(x); }$/;"	f	class:map	access:public	signature:(const key_type& x)
find	stl_multimap.h	/^  const_iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:multimap	access:public	signature:(const key_type& x) const
find	stl_multimap.h	/^  iterator find(const key_type& x) { return t.find(x); }$/;"	f	class:multimap	access:public	signature:(const key_type& x)
find	stl_multiset.h	/^  iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:multiset	access:public	signature:(const key_type& x) const
find	stl_rope.h	/^	size_type find(charT *s, size_type pos = 0) const {$/;"	f	class:rope	access:public	signature:(charT *s, size_type pos = 0) const
find	stl_rope.h	/^	size_type find(charT c, size_type pos = 0) const;$/;"	p	class:rope	access:public	signature:(charT c, size_type pos = 0) const
find	stl_set.h	/^  iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:set	access:public	signature:(const key_type& x) const
find	stl_tree.h	/^  const_iterator find(const key_type& x) const;$/;"	p	class:rb_tree	access:public	signature:(const key_type& x) const
find	stl_tree.h	/^  iterator find(const key_type& x);$/;"	p	class:rb_tree	access:public	signature:(const key_type& x)
find	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) const {$/;"	f	class:rb_tree	signature:(const Key& k) const
find	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) {$/;"	f	class:rb_tree	signature:(const Key& k)
find_end	stl_algo.h	/^find_end(ForwardIterator1 first1, ForwardIterator1 last1, $/;"	f	signature:(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
find_end	stl_algo.h	/^find_end(ForwardIterator1 first1, ForwardIterator1 last1, $/;"	f	signature:(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate comp)
find_first_of	stl_algo.h	/^InputIterator find_first_of(InputIterator first1, InputIterator last1,$/;"	f	signature:(InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)
find_first_of	stl_algo.h	/^InputIterator find_first_of(InputIterator first1, InputIterator last1,$/;"	f	signature:(InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate comp)
find_if	stl_algo.h	/^InputIterator find_if(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, Predicate pred)
find_or_insert	stl_hashtable.h	/^  reference find_or_insert(const value_type& obj);$/;"	p	class:hashtable	access:public	signature:(const value_type& obj)
find_or_insert	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::find_or_insert(const value_type& obj)$/;"	f	class:hashtable	signature:(const value_type& obj)
finish	stl_bvector.h	/^  iterator finish;$/;"	m	class:vector	access:protected
finish	stl_deque.h	/^  iterator finish;$/;"	m	class:__deque_iterator::deque	access:protected
finish	stl_vector.h	/^  iterator finish;$/;"	m	class:vector	access:protected
first	stl_deque.h	/^  T* first;$/;"	m	struct:__deque_iterator::__deque_iterator	access:public
first	stl_pair.h	/^  T1 first;$/;"	m	struct:pair	access:public
first_argument_type	stl_function.h	/^    typedef Arg1 first_argument_type;$/;"	t	struct:binary_function	access:public
first_type	stl_pair.h	/^  typedef T1 first_type;$/;"	t	struct:pair	access:public
flatten	ropeimpl.h	/^rope<charT,Alloc>::flatten(RopeBase * r, charT * buffer)$/;"	f	class:rope	signature:(RopeBase * r, charT * buffer)
flatten	ropeimpl.h	/^rope<charT,Alloc>::flatten(RopeBase * r,$/;"	f	class:rope	signature:(RopeBase * r, size_t start, size_t len, charT * buffer)
flatten	stl_rope.h	/^	static charT * flatten(RopeBase * r, charT * buffer);$/;"	p	class:rope	access:protected	signature:(RopeBase * r, charT * buffer)
flatten	stl_rope.h	/^	static charT * flatten(RopeBase * r,$/;"	p	class:rope	access:protected	signature:(RopeBase * r, size_t start, size_t len, charT * buffer)
flip	stl_bvector.h	/^  void flip() { *p ^= mask; }$/;"	f	struct:__bit_reference	access:public	signature:()
flush	stl_rope.h	/^	void flush() {$/;"	f	class:sequence_buffer	access:public	signature:()
fn	stl_rope.h	/^    char_producer<charT>* fn;$/;"	m	struct:__rope_RopeFunction	access:public
fn_finalization_proc	ropeimpl.h	/^void __rope_RopeBase<charT,Alloc>::fn_finalization_proc(void * tree, void *)$/;"	f	class:__rope_RopeBase	signature:(void * tree, void *)
fn_finalization_proc	stl_rope.h	/^	  static void fn_finalization_proc(void * tree, void *);$/;"	p	struct:__rope_RopeBase	access:public	signature:(void * tree, void *)
for_each	stl_algo.h	/^Function for_each(InputIterator first, InputIterator last, Function f) {$/;"	f	signature:(InputIterator first, InputIterator last, Function f)
forward_iterator	stl_iterator.h	/^template <class T, class Distance> struct forward_iterator {$/;"	s
forward_iterator::difference_type	stl_iterator.h	/^  typedef Distance             difference_type;$/;"	t	struct:forward_iterator	access:public
forward_iterator::iterator_category	stl_iterator.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:forward_iterator	access:public
forward_iterator::pointer	stl_iterator.h	/^  typedef T*                   pointer;$/;"	t	struct:forward_iterator	access:public
forward_iterator::reference	stl_iterator.h	/^  typedef T&                   reference;$/;"	t	struct:forward_iterator	access:public
forward_iterator::value_type	stl_iterator.h	/^  typedef T                    value_type;$/;"	t	struct:forward_iterator	access:public
forward_iterator_tag	stl_iterator.h	/^struct forward_iterator_tag : public input_iterator_tag {};$/;"	s	inherits:input_iterator_tag
free_c_string	ropeimpl.h	/^inline void __rope_RopeBase<charT,Alloc>::free_c_string()$/;"	f	class:__rope_RopeBase	signature:()
free_c_string	stl_rope.h	/^	  void free_c_string();$/;"	p	struct:__rope_RopeBase	access:public	signature:()
free_if_unref	stl_rope.h	/^	  static void free_if_unref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase	access:public	signature:(__rope_RopeBase* t)
free_if_unref	stl_rope.h	/^	  static void free_if_unref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase	access:public	signature:(__rope_RopeBase* t)
free_list	stl_alloc.h	/^    static obj * __VOLATILE free_list[]; $/;"	m	class:__default_alloc_template	access:private
free_list	stl_alloc.h	/^    static obj * __VOLATILE free_list[__NFREELISTS]; $/;"	m	class:__default_alloc_template	access:private
free_list	stl_alloc.h	/^__default_alloc_template<threads, inst> ::free_list[$/;"	m	class:__default_alloc_template
free_list_link	stl_alloc.h	/^        union obj * free_list_link;$/;"	m	union:__default_alloc_template::obj	typeref:union:__default_alloc_template::obj::obj	access:public
free_string	ropeimpl.h	/^inline void __rope_RopeBase<charT,Alloc>::free_string(charT* s, size_t n)$/;"	f	class:__rope_RopeBase	signature:(charT* s, size_t n)
free_string	stl_rope.h	/^	static void free_string(charT *, size_t len);$/;"	p	struct:__rope_RopeBase	access:public	signature:(charT *, size_t len)
free_tree	ropeimpl.h	/^void __rope_RopeBase<charT,Alloc>::free_tree()$/;"	f	class:__rope_RopeBase	signature:()
free_tree	stl_rope.h	/^	  void free_tree();$/;"	p	struct:__rope_RopeBase	access:public	signature:()
front	stl_bvector.h	/^  const_reference front() const { return *begin(); }$/;"	f	class:vector	access:public	signature:() const
front	stl_bvector.h	/^  reference front() { return *begin(); }$/;"	f	class:vector	access:public	signature:()
front	stl_deque.h	/^  const_reference front() const { return *start; }$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
front	stl_deque.h	/^  reference front() { return *start; }$/;"	f	class:__deque_iterator::deque	access:public	signature:()
front	stl_list.h	/^  const_reference front() const { return *begin(); }$/;"	f	class:list	access:public	signature:() const
front	stl_list.h	/^  reference front() { return *begin(); }$/;"	f	class:list	access:public	signature:()
front	stl_queue.h	/^  const_reference front() const { return c.front(); }$/;"	f	class:queue	access:public	signature:() const
front	stl_queue.h	/^  reference front() { return c.front(); }$/;"	f	class:queue	access:public	signature:()
front	stl_rope.h	/^	charT front() const$/;"	f	class:rope	access:public	signature:() const
front	stl_slist.h	/^  const_reference front() const { return ((list_node*) head.next)->data; }$/;"	f	class:slist	access:public	signature:() const
front	stl_slist.h	/^  reference front() { return ((list_node*) head.next)->data; }$/;"	f	class:slist	access:public	signature:()
front	stl_vector.h	/^  const_reference front() const { return *begin(); }$/;"	f	class:vector	access:public	signature:() const
front	stl_vector.h	/^  reference front() { return *begin(); }$/;"	f	class:vector	access:public	signature:()
front_insert_iterator	stl_iterator.h	/^  explicit front_insert_iterator(Container& x) : container(&x) {}$/;"	f	class:front_insert_iterator	access:public	signature:(Container& x)
front_insert_iterator	stl_iterator.h	/^class front_insert_iterator {$/;"	c
front_insert_iterator::container	stl_iterator.h	/^  Container* container;$/;"	m	class:front_insert_iterator	access:protected
front_insert_iterator::difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:front_insert_iterator	access:public
front_insert_iterator::front_insert_iterator	stl_iterator.h	/^  explicit front_insert_iterator(Container& x) : container(&x) {}$/;"	f	class:front_insert_iterator	access:public	signature:(Container& x)
front_insert_iterator::iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:front_insert_iterator	access:public
front_insert_iterator::operator *	stl_iterator.h	/^  front_insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:front_insert_iterator	access:public	signature:()
front_insert_iterator::operator ++	stl_iterator.h	/^  front_insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:front_insert_iterator	access:public	signature:()
front_insert_iterator::operator ++	stl_iterator.h	/^  front_insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:front_insert_iterator	access:public	signature:(int)
front_insert_iterator::operator =	stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:front_insert_iterator	access:public	signature:(const typename Container::value_type& value)
front_insert_iterator::pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:front_insert_iterator	access:public
front_insert_iterator::reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	class:front_insert_iterator	access:public
front_insert_iterator::value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:front_insert_iterator	access:public
front_inserter	stl_iterator.h	/^inline front_insert_iterator<Container> front_inserter(Container& x) {$/;"	f	signature:(Container& x)
function	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon9
generate	stl_algo.h	/^void generate(ForwardIterator first, ForwardIterator last, Generator gen) {$/;"	f	signature:(ForwardIterator first, ForwardIterator last, Generator gen)
generate_n	stl_algo.h	/^OutputIterator generate_n(OutputIterator first, Size n, Generator gen) {$/;"	f	signature:(OutputIterator first, Size n, Generator gen)
get_key	stl_hashtable.h	/^  ExtractKey get_key;$/;"	m	class:hashtable	access:private
get_node	stl_list.h	/^  link_type get_node() { return list_node_allocator::allocate(); }$/;"	f	class:list	access:protected	signature:()
get_node	stl_tree.h	/^  link_type get_node() { return rb_tree_node_allocator::allocate(); }$/;"	f	class:rb_tree	access:protected	signature:()
get_temporary_buffer	stl_tempbuf.h	/^pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t len, T*) {$/;"	f	signature:(ptrdiff_t len, T*)
greater	stl_function.h	/^struct greater : public binary_function<T, T, bool> {$/;"	s	inherits:binary_function
greater::operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x > y; }$/;"	f	struct:greater	access:public	signature:(const T& x, const T& y) const
greater_equal	stl_function.h	/^struct greater_equal : public binary_function<T, T, bool> {$/;"	s	inherits:binary_function
greater_equal::operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x >= y; }$/;"	f	struct:greater_equal	access:public	signature:(const T& x, const T& y) const
has_trivial_assignment_operator	type_traits.h	/^   typedef __false_type    has_trivial_assignment_operator;$/;"	t	struct:__type_traits	access:public
has_trivial_assignment_operator	type_traits.h	/^   typedef __true_type    has_trivial_assignment_operator;$/;"	t	struct:__type_traits	access:public
has_trivial_copy_constructor	type_traits.h	/^   typedef __false_type    has_trivial_copy_constructor;$/;"	t	struct:__type_traits	access:public
has_trivial_copy_constructor	type_traits.h	/^   typedef __true_type    has_trivial_copy_constructor;$/;"	t	struct:__type_traits	access:public
has_trivial_default_constructor	type_traits.h	/^   typedef __false_type    has_trivial_default_constructor;$/;"	t	struct:__type_traits	access:public
has_trivial_default_constructor	type_traits.h	/^   typedef __true_type    has_trivial_default_constructor;$/;"	t	struct:__type_traits	access:public
has_trivial_destructor	type_traits.h	/^   typedef __false_type    has_trivial_destructor;$/;"	t	struct:__type_traits	access:public
has_trivial_destructor	type_traits.h	/^   typedef __true_type    has_trivial_destructor;$/;"	t	struct:__type_traits	access:public
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<char*>$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<char> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<const char*>$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<int> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<long> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<short> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<signed char> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned char> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned int> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned long> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned short> {$/;"	s
hash	stl_hash_fun.h	/^template <class Key> struct hash { };$/;"	s
hash	stl_hashtable.h	/^  hasher hash;$/;"	m	class:hashtable	access:private
hash	stl_rope.h	/^__STL_TEMPLATE_NULL struct hash<crope>$/;"	s
hash	stl_rope.h	/^__STL_TEMPLATE_NULL struct hash<wrope>$/;"	s
hash::operator ()	stl_hash_fun.h	/^  size_t operator()(char x) const { return x; }$/;"	f	struct:hash	access:public	signature:(char x) const
hash::operator ()	stl_hash_fun.h	/^  size_t operator()(const char* s) const { return __stl_hash_string(s); }$/;"	f	struct:hash	access:public	signature:(const char* s) const
hash::operator ()	stl_hash_fun.h	/^  size_t operator()(int x) const { return x; }$/;"	f	struct:hash	access:public	signature:(int x) const
hash::operator ()	stl_hash_fun.h	/^  size_t operator()(long x) const { return x; }$/;"	f	struct:hash	access:public	signature:(long x) const
hash::operator ()	stl_hash_fun.h	/^  size_t operator()(short x) const { return x; }$/;"	f	struct:hash	access:public	signature:(short x) const
hash::operator ()	stl_hash_fun.h	/^  size_t operator()(unsigned char x) const { return x; }$/;"	f	struct:hash	access:public	signature:(unsigned char x) const
hash::operator ()	stl_hash_fun.h	/^  size_t operator()(unsigned int x) const { return x; }$/;"	f	struct:hash	access:public	signature:(unsigned int x) const
hash::operator ()	stl_hash_fun.h	/^  size_t operator()(unsigned long x) const { return x; }$/;"	f	struct:hash	access:public	signature:(unsigned long x) const
hash::operator ()	stl_hash_fun.h	/^  size_t operator()(unsigned short x) const { return x; }$/;"	f	struct:hash	access:public	signature:(unsigned short x) const
hash::operator ()	stl_rope.h	/^  size_t operator()(const crope& str) const$/;"	f	struct:hash	access:public	signature:(const crope& str) const
hash::operator ()	stl_rope.h	/^  size_t operator()(const wrope& str) const$/;"	f	struct:hash	access:public	signature:(const wrope& str) const
hash_funct	stl_hash_map.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_map	access:public	signature:() const
hash_funct	stl_hash_map.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_multimap	access:public	signature:() const
hash_funct	stl_hash_set.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_multiset	access:public	signature:() const
hash_funct	stl_hash_set.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_set	access:public	signature:() const
hash_funct	stl_hashtable.h	/^  hasher hash_funct() const { return hash; }$/;"	f	class:hashtable	access:public	signature:() const
hash_map	stl_hash_map.h	/^  explicit hash_map(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_map	access:public	signature:(size_type n)
hash_map	stl_hash_map.h	/^  hash_map() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_map	access:public	signature:()
hash_map	stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l)$/;"	f	class:hash_map	access:public	signature:(InputIterator f, InputIterator l)
hash_map	stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_map	access:public	signature:(InputIterator f, InputIterator l, size_type n)
hash_map	stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_map	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf)
hash_map	stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_map	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_map	stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l)$/;"	f	class:hash_map	access:public	signature:(const value_type* f, const value_type* l)
hash_map	stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_map	access:public	signature:(const value_type* f, const value_type* l, size_type n)
hash_map	stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_map	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf)
hash_map	stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_map	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf, const key_equal& eql)
hash_map	stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l)$/;"	f	class:hash_map	access:public	signature:(const_iterator f, const_iterator l)
hash_map	stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_map	access:public	signature:(const_iterator f, const_iterator l, size_type n)
hash_map	stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_map	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf)
hash_map	stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_map	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_map	stl_hash_map.h	/^  hash_map(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_map	access:public	signature:(size_type n, const hasher& hf)
hash_map	stl_hash_map.h	/^  hash_map(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_map	access:public	signature:(size_type n, const hasher& hf, const key_equal& eql)
hash_map	stl_hash_map.h	/^class hash_map$/;"	c
hash_map::__STL_NULL_TMPL_ARGS	stl_hash_map.h	/^  operator== __STL_NULL_TMPL_ARGS (const hash_map&, const hash_map&);$/;"	p	class:hash_map	access:friend	signature:(const hash_map&, const hash_map&)
hash_map::begin	stl_hash_map.h	/^  const_iterator begin() const { return rep.begin(); }$/;"	f	class:hash_map	access:public	signature:() const
hash_map::begin	stl_hash_map.h	/^  iterator begin() { return rep.begin(); }$/;"	f	class:hash_map	access:public	signature:()
hash_map::bucket_count	stl_hash_map.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_map	access:public	signature:() const
hash_map::clear	stl_hash_map.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_map	access:public	signature:()
hash_map::const_iterator	stl_hash_map.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_map	access:public
hash_map::const_pointer	stl_hash_map.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_map	access:public
hash_map::const_reference	stl_hash_map.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_map	access:public
hash_map::count	stl_hash_map.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_map	access:public	signature:(const key_type& key) const
hash_map::data_type	stl_hash_map.h	/^  typedef T data_type;$/;"	t	class:hash_map	access:public
hash_map::difference_type	stl_hash_map.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_map	access:public
hash_map::elems_in_bucket	stl_hash_map.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_map	access:public	signature:(size_type n) const
hash_map::empty	stl_hash_map.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_map	access:public	signature:() const
hash_map::end	stl_hash_map.h	/^  const_iterator end() const { return rep.end(); }$/;"	f	class:hash_map	access:public	signature:() const
hash_map::end	stl_hash_map.h	/^  iterator end() { return rep.end(); }$/;"	f	class:hash_map	access:public	signature:()
hash_map::equal_range	stl_hash_map.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& key) const$/;"	f	class:hash_map	access:public	signature:(const key_type& key) const
hash_map::equal_range	stl_hash_map.h	/^  pair<iterator, iterator> equal_range(const key_type& key)$/;"	f	class:hash_map	access:public	signature:(const key_type& key)
hash_map::erase	stl_hash_map.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_map	access:public	signature:(const key_type& key)
hash_map::erase	stl_hash_map.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_map	access:public	signature:(iterator f, iterator l)
hash_map::erase	stl_hash_map.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_map	access:public	signature:(iterator it)
hash_map::find	stl_hash_map.h	/^  const_iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_map	access:public	signature:(const key_type& key) const
hash_map::find	stl_hash_map.h	/^  iterator find(const key_type& key) { return rep.find(key); }$/;"	f	class:hash_map	access:public	signature:(const key_type& key)
hash_map::hash_funct	stl_hash_map.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_map	access:public	signature:() const
hash_map::hash_map	stl_hash_map.h	/^  explicit hash_map(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_map	access:public	signature:(size_type n)
hash_map::hash_map	stl_hash_map.h	/^  hash_map() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_map	access:public	signature:()
hash_map::hash_map	stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l)$/;"	f	class:hash_map	access:public	signature:(InputIterator f, InputIterator l)
hash_map::hash_map	stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_map	access:public	signature:(InputIterator f, InputIterator l, size_type n)
hash_map::hash_map	stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_map	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf)
hash_map::hash_map	stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_map	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_map::hash_map	stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l)$/;"	f	class:hash_map	access:public	signature:(const value_type* f, const value_type* l)
hash_map::hash_map	stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_map	access:public	signature:(const value_type* f, const value_type* l, size_type n)
hash_map::hash_map	stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_map	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf)
hash_map::hash_map	stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_map	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf, const key_equal& eql)
hash_map::hash_map	stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l)$/;"	f	class:hash_map	access:public	signature:(const_iterator f, const_iterator l)
hash_map::hash_map	stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_map	access:public	signature:(const_iterator f, const_iterator l, size_type n)
hash_map::hash_map	stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_map	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf)
hash_map::hash_map	stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_map	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_map::hash_map	stl_hash_map.h	/^  hash_map(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_map	access:public	signature:(size_type n, const hasher& hf)
hash_map::hash_map	stl_hash_map.h	/^  hash_map(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_map	access:public	signature:(size_type n, const hasher& hf, const key_equal& eql)
hash_map::hasher	stl_hash_map.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_map	access:public
hash_map::ht	stl_hash_map.h	/^                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;$/;"	t	class:hash_map	access:private
hash_map::insert	stl_hash_map.h	/^  pair<iterator, bool> insert(const value_type& obj)$/;"	f	class:hash_map	access:public	signature:(const value_type& obj)
hash_map::insert	stl_hash_map.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }$/;"	f	class:hash_map	access:public	signature:(InputIterator f, InputIterator l)
hash_map::insert	stl_hash_map.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_map	access:public	signature:(const value_type* f, const value_type* l)
hash_map::insert	stl_hash_map.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_unique(f, l); }$/;"	f	class:hash_map	access:public	signature:(const_iterator f, const_iterator l)
hash_map::insert_noresize	stl_hash_map.h	/^  pair<iterator, bool> insert_noresize(const value_type& obj)$/;"	f	class:hash_map	access:public	signature:(const value_type& obj)
hash_map::iterator	stl_hash_map.h	/^  typedef typename ht::iterator iterator;$/;"	t	class:hash_map	access:public
hash_map::key_eq	stl_hash_map.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_map	access:public	signature:() const
hash_map::key_equal	stl_hash_map.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_map	access:public
hash_map::key_type	stl_hash_map.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_map	access:public
hash_map::mapped_type	stl_hash_map.h	/^  typedef T mapped_type;$/;"	t	class:hash_map	access:public
hash_map::max_bucket_count	stl_hash_map.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_map	access:public	signature:() const
hash_map::max_size	stl_hash_map.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_map	access:public	signature:() const
hash_map::operator []	stl_hash_map.h	/^  T& operator[](const key_type& key) {$/;"	f	class:hash_map	access:public	signature:(const key_type& key)
hash_map::pointer	stl_hash_map.h	/^  typedef typename ht::pointer pointer;$/;"	t	class:hash_map	access:public
hash_map::reference	stl_hash_map.h	/^  typedef typename ht::reference reference;$/;"	t	class:hash_map	access:public
hash_map::rep	stl_hash_map.h	/^  ht rep;$/;"	m	class:hash_map	access:private
hash_map::resize	stl_hash_map.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_map	access:public	signature:(size_type hint)
hash_map::size	stl_hash_map.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_map	access:public	signature:() const
hash_map::size_type	stl_hash_map.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_map	access:public
hash_map::swap	stl_hash_map.h	/^  void swap(hash_map& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_map	access:public	signature:(hash_map& hs)
hash_map::value_type	stl_hash_map.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_map	access:public
hash_multimap	stl_hash_map.h	/^  explicit hash_multimap(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_multimap	access:public	signature:(size_type n)
hash_multimap	stl_hash_map.h	/^  hash_multimap() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_multimap	access:public	signature:()
hash_multimap	stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l)$/;"	f	class:hash_multimap	access:public	signature:(InputIterator f, InputIterator l)
hash_multimap	stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_multimap	access:public	signature:(InputIterator f, InputIterator l, size_type n)
hash_multimap	stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multimap	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf)
hash_multimap	stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multimap	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_multimap	stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l)$/;"	f	class:hash_multimap	access:public	signature:(const value_type* f, const value_type* l)
hash_multimap	stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_multimap	access:public	signature:(const value_type* f, const value_type* l, size_type n)
hash_multimap	stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multimap	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf)
hash_multimap	stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multimap	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf, const key_equal& eql)
hash_multimap	stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l)$/;"	f	class:hash_multimap	access:public	signature:(const_iterator f, const_iterator l)
hash_multimap	stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_multimap	access:public	signature:(const_iterator f, const_iterator l, size_type n)
hash_multimap	stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multimap	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf)
hash_multimap	stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multimap	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_multimap	stl_hash_map.h	/^  hash_multimap(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_multimap	access:public	signature:(size_type n, const hasher& hf)
hash_multimap	stl_hash_map.h	/^  hash_multimap(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_multimap	access:public	signature:(size_type n, const hasher& hf, const key_equal& eql)
hash_multimap	stl_hash_map.h	/^class hash_multimap$/;"	c
hash_multimap::__STL_NULL_TMPL_ARGS	stl_hash_map.h	/^  operator== __STL_NULL_TMPL_ARGS (const hash_multimap&, const hash_multimap&);$/;"	p	class:hash_multimap	access:friend	signature:(const hash_multimap&, const hash_multimap&)
hash_multimap::begin	stl_hash_map.h	/^  const_iterator begin() const { return rep.begin(); }$/;"	f	class:hash_multimap	access:public	signature:() const
hash_multimap::begin	stl_hash_map.h	/^  iterator begin() { return rep.begin(); }$/;"	f	class:hash_multimap	access:public	signature:()
hash_multimap::bucket_count	stl_hash_map.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_multimap	access:public	signature:() const
hash_multimap::clear	stl_hash_map.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_multimap	access:public	signature:()
hash_multimap::const_iterator	stl_hash_map.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_multimap	access:public
hash_multimap::const_pointer	stl_hash_map.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_multimap	access:public
hash_multimap::const_reference	stl_hash_map.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_multimap	access:public
hash_multimap::count	stl_hash_map.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_multimap	access:public	signature:(const key_type& key) const
hash_multimap::data_type	stl_hash_map.h	/^  typedef T data_type;$/;"	t	class:hash_multimap	access:public
hash_multimap::difference_type	stl_hash_map.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_multimap	access:public
hash_multimap::elems_in_bucket	stl_hash_map.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_multimap	access:public	signature:(size_type n) const
hash_multimap::empty	stl_hash_map.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_multimap	access:public	signature:() const
hash_multimap::end	stl_hash_map.h	/^  const_iterator end() const { return rep.end(); }$/;"	f	class:hash_multimap	access:public	signature:() const
hash_multimap::end	stl_hash_map.h	/^  iterator end() { return rep.end(); }$/;"	f	class:hash_multimap	access:public	signature:()
hash_multimap::equal_range	stl_hash_map.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& key) const$/;"	f	class:hash_multimap	access:public	signature:(const key_type& key) const
hash_multimap::equal_range	stl_hash_map.h	/^  pair<iterator, iterator> equal_range(const key_type& key)$/;"	f	class:hash_multimap	access:public	signature:(const key_type& key)
hash_multimap::erase	stl_hash_map.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_multimap	access:public	signature:(const key_type& key)
hash_multimap::erase	stl_hash_map.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_multimap	access:public	signature:(iterator f, iterator l)
hash_multimap::erase	stl_hash_map.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_multimap	access:public	signature:(iterator it)
hash_multimap::find	stl_hash_map.h	/^  const_iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_multimap	access:public	signature:(const key_type& key) const
hash_multimap::find	stl_hash_map.h	/^  iterator find(const key_type& key) { return rep.find(key); }$/;"	f	class:hash_multimap	access:public	signature:(const key_type& key)
hash_multimap::hash_funct	stl_hash_map.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_multimap	access:public	signature:() const
hash_multimap::hash_multimap	stl_hash_map.h	/^  explicit hash_multimap(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_multimap	access:public	signature:(size_type n)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_multimap	access:public	signature:()
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l)$/;"	f	class:hash_multimap	access:public	signature:(InputIterator f, InputIterator l)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_multimap	access:public	signature:(InputIterator f, InputIterator l, size_type n)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multimap	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multimap	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l)$/;"	f	class:hash_multimap	access:public	signature:(const value_type* f, const value_type* l)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_multimap	access:public	signature:(const value_type* f, const value_type* l, size_type n)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multimap	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multimap	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf, const key_equal& eql)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l)$/;"	f	class:hash_multimap	access:public	signature:(const_iterator f, const_iterator l)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_multimap	access:public	signature:(const_iterator f, const_iterator l, size_type n)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multimap	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multimap	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_multimap	access:public	signature:(size_type n, const hasher& hf)
hash_multimap::hash_multimap	stl_hash_map.h	/^  hash_multimap(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_multimap	access:public	signature:(size_type n, const hasher& hf, const key_equal& eql)
hash_multimap::hasher	stl_hash_map.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_multimap	access:public
hash_multimap::ht	stl_hash_map.h	/^                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;$/;"	t	class:hash_multimap	access:private
hash_multimap::insert	stl_hash_map.h	/^  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }$/;"	f	class:hash_multimap	access:public	signature:(const value_type& obj)
hash_multimap::insert	stl_hash_map.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }$/;"	f	class:hash_multimap	access:public	signature:(InputIterator f, InputIterator l)
hash_multimap::insert	stl_hash_map.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_multimap	access:public	signature:(const value_type* f, const value_type* l)
hash_multimap::insert	stl_hash_map.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }$/;"	f	class:hash_multimap	access:public	signature:(const_iterator f, const_iterator l)
hash_multimap::insert_noresize	stl_hash_map.h	/^  iterator insert_noresize(const value_type& obj)$/;"	f	class:hash_multimap	access:public	signature:(const value_type& obj)
hash_multimap::iterator	stl_hash_map.h	/^  typedef typename ht::iterator iterator;$/;"	t	class:hash_multimap	access:public
hash_multimap::key_eq	stl_hash_map.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_multimap	access:public	signature:() const
hash_multimap::key_equal	stl_hash_map.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_multimap	access:public
hash_multimap::key_type	stl_hash_map.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_multimap	access:public
hash_multimap::mapped_type	stl_hash_map.h	/^  typedef T mapped_type;$/;"	t	class:hash_multimap	access:public
hash_multimap::max_bucket_count	stl_hash_map.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_multimap	access:public	signature:() const
hash_multimap::max_size	stl_hash_map.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_multimap	access:public	signature:() const
hash_multimap::pointer	stl_hash_map.h	/^  typedef typename ht::pointer pointer;$/;"	t	class:hash_multimap	access:public
hash_multimap::reference	stl_hash_map.h	/^  typedef typename ht::reference reference;$/;"	t	class:hash_multimap	access:public
hash_multimap::rep	stl_hash_map.h	/^  ht rep;$/;"	m	class:hash_multimap	access:private
hash_multimap::resize	stl_hash_map.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_multimap	access:public	signature:(size_type hint)
hash_multimap::size	stl_hash_map.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_multimap	access:public	signature:() const
hash_multimap::size_type	stl_hash_map.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_multimap	access:public
hash_multimap::swap	stl_hash_map.h	/^  void swap(hash_multimap& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_multimap	access:public	signature:(hash_multimap& hs)
hash_multimap::value_type	stl_hash_map.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_multimap	access:public
hash_multiset	stl_hash_set.h	/^  explicit hash_multiset(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_multiset	access:public	signature:(size_type n)
hash_multiset	stl_hash_set.h	/^  hash_multiset() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_multiset	access:public	signature:()
hash_multiset	stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l)$/;"	f	class:hash_multiset	access:public	signature:(InputIterator f, InputIterator l)
hash_multiset	stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_multiset	access:public	signature:(InputIterator f, InputIterator l, size_type n)
hash_multiset	stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multiset	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf)
hash_multiset	stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multiset	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_multiset	stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l)$/;"	f	class:hash_multiset	access:public	signature:(const value_type* f, const value_type* l)
hash_multiset	stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_multiset	access:public	signature:(const value_type* f, const value_type* l, size_type n)
hash_multiset	stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multiset	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf)
hash_multiset	stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multiset	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf, const key_equal& eql)
hash_multiset	stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l)$/;"	f	class:hash_multiset	access:public	signature:(const_iterator f, const_iterator l)
hash_multiset	stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_multiset	access:public	signature:(const_iterator f, const_iterator l, size_type n)
hash_multiset	stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multiset	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf)
hash_multiset	stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multiset	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_multiset	stl_hash_set.h	/^  hash_multiset(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_multiset	access:public	signature:(size_type n, const hasher& hf)
hash_multiset	stl_hash_set.h	/^  hash_multiset(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_multiset	access:public	signature:(size_type n, const hasher& hf, const key_equal& eql)
hash_multiset	stl_hash_set.h	/^class hash_multiset$/;"	c
hash_multiset::__STL_NULL_TMPL_ARGS	stl_hash_set.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const hash_multiset&,$/;"	p	class:hash_multiset	access:friend	signature:(const hash_multiset&, const hash_multiset&)
hash_multiset::begin	stl_hash_set.h	/^  iterator begin() const { return rep.begin(); }$/;"	f	class:hash_multiset	access:public	signature:() const
hash_multiset::bucket_count	stl_hash_set.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_multiset	access:public	signature:() const
hash_multiset::clear	stl_hash_set.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_multiset	access:public	signature:()
hash_multiset::const_iterator	stl_hash_set.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_multiset	access:public
hash_multiset::const_pointer	stl_hash_set.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_multiset	access:public
hash_multiset::const_reference	stl_hash_set.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_multiset	access:public
hash_multiset::count	stl_hash_set.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_multiset	access:public	signature:(const key_type& key) const
hash_multiset::difference_type	stl_hash_set.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_multiset	access:public
hash_multiset::elems_in_bucket	stl_hash_set.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_multiset	access:public	signature:(size_type n) const
hash_multiset::empty	stl_hash_set.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_multiset	access:public	signature:() const
hash_multiset::end	stl_hash_set.h	/^  iterator end() const { return rep.end(); }$/;"	f	class:hash_multiset	access:public	signature:() const
hash_multiset::equal_range	stl_hash_set.h	/^  pair<iterator, iterator> equal_range(const key_type& key) const$/;"	f	class:hash_multiset	access:public	signature:(const key_type& key) const
hash_multiset::erase	stl_hash_set.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_multiset	access:public	signature:(const key_type& key)
hash_multiset::erase	stl_hash_set.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_multiset	access:public	signature:(iterator f, iterator l)
hash_multiset::erase	stl_hash_set.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_multiset	access:public	signature:(iterator it)
hash_multiset::find	stl_hash_set.h	/^  iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_multiset	access:public	signature:(const key_type& key) const
hash_multiset::hash_funct	stl_hash_set.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_multiset	access:public	signature:() const
hash_multiset::hash_multiset	stl_hash_set.h	/^  explicit hash_multiset(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_multiset	access:public	signature:(size_type n)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_multiset	access:public	signature:()
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l)$/;"	f	class:hash_multiset	access:public	signature:(InputIterator f, InputIterator l)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_multiset	access:public	signature:(InputIterator f, InputIterator l, size_type n)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multiset	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multiset	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l)$/;"	f	class:hash_multiset	access:public	signature:(const value_type* f, const value_type* l)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_multiset	access:public	signature:(const value_type* f, const value_type* l, size_type n)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multiset	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multiset	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf, const key_equal& eql)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l)$/;"	f	class:hash_multiset	access:public	signature:(const_iterator f, const_iterator l)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_multiset	access:public	signature:(const_iterator f, const_iterator l, size_type n)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multiset	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multiset	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_multiset	access:public	signature:(size_type n, const hasher& hf)
hash_multiset::hash_multiset	stl_hash_set.h	/^  hash_multiset(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_multiset	access:public	signature:(size_type n, const hasher& hf, const key_equal& eql)
hash_multiset::hasher	stl_hash_set.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_multiset	access:public
hash_multiset::ht	stl_hash_set.h	/^                    EqualKey, Alloc> ht;$/;"	t	class:hash_multiset	access:private
hash_multiset::insert	stl_hash_set.h	/^  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }$/;"	f	class:hash_multiset	access:public	signature:(const value_type& obj)
hash_multiset::insert	stl_hash_set.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }$/;"	f	class:hash_multiset	access:public	signature:(InputIterator f, InputIterator l)
hash_multiset::insert	stl_hash_set.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_multiset	access:public	signature:(const value_type* f, const value_type* l)
hash_multiset::insert	stl_hash_set.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }$/;"	f	class:hash_multiset	access:public	signature:(const_iterator f, const_iterator l)
hash_multiset::insert_noresize	stl_hash_set.h	/^  iterator insert_noresize(const value_type& obj)$/;"	f	class:hash_multiset	access:public	signature:(const value_type& obj)
hash_multiset::iterator	stl_hash_set.h	/^  typedef typename ht::const_iterator iterator;$/;"	t	class:hash_multiset	access:public
hash_multiset::key_eq	stl_hash_set.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_multiset	access:public	signature:() const
hash_multiset::key_equal	stl_hash_set.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_multiset	access:public
hash_multiset::key_type	stl_hash_set.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_multiset	access:public
hash_multiset::max_bucket_count	stl_hash_set.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_multiset	access:public	signature:() const
hash_multiset::max_size	stl_hash_set.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_multiset	access:public	signature:() const
hash_multiset::pointer	stl_hash_set.h	/^  typedef typename ht::const_pointer pointer;$/;"	t	class:hash_multiset	access:public
hash_multiset::reference	stl_hash_set.h	/^  typedef typename ht::const_reference reference;$/;"	t	class:hash_multiset	access:public
hash_multiset::rep	stl_hash_set.h	/^  ht rep;$/;"	m	class:hash_multiset	access:private
hash_multiset::resize	stl_hash_set.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_multiset	access:public	signature:(size_type hint)
hash_multiset::size	stl_hash_set.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_multiset	access:public	signature:() const
hash_multiset::size_type	stl_hash_set.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_multiset	access:public
hash_multiset::swap	stl_hash_set.h	/^  void swap(hash_multiset& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_multiset	access:public	signature:(hash_multiset& hs)
hash_multiset::value_type	stl_hash_set.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_multiset	access:public
hash_set	stl_hash_set.h	/^  explicit hash_set(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_set	access:public	signature:(size_type n)
hash_set	stl_hash_set.h	/^  hash_set() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_set	access:public	signature:()
hash_set	stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l)$/;"	f	class:hash_set	access:public	signature:(InputIterator f, InputIterator l)
hash_set	stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_set	access:public	signature:(InputIterator f, InputIterator l, size_type n)
hash_set	stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_set	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf)
hash_set	stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_set	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_set	stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l)$/;"	f	class:hash_set	access:public	signature:(const value_type* f, const value_type* l)
hash_set	stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_set	access:public	signature:(const value_type* f, const value_type* l, size_type n)
hash_set	stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_set	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf)
hash_set	stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_set	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf, const key_equal& eql)
hash_set	stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l)$/;"	f	class:hash_set	access:public	signature:(const_iterator f, const_iterator l)
hash_set	stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_set	access:public	signature:(const_iterator f, const_iterator l, size_type n)
hash_set	stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_set	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf)
hash_set	stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_set	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_set	stl_hash_set.h	/^  hash_set(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_set	access:public	signature:(size_type n, const hasher& hf)
hash_set	stl_hash_set.h	/^  hash_set(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_set	access:public	signature:(size_type n, const hasher& hf, const key_equal& eql)
hash_set	stl_hash_set.h	/^class hash_set$/;"	c
hash_set::__STL_NULL_TMPL_ARGS	stl_hash_set.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const hash_set&,$/;"	p	class:hash_set	access:friend	signature:(const hash_set&, const hash_set&)
hash_set::begin	stl_hash_set.h	/^  iterator begin() const { return rep.begin(); }$/;"	f	class:hash_set	access:public	signature:() const
hash_set::bucket_count	stl_hash_set.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_set	access:public	signature:() const
hash_set::clear	stl_hash_set.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_set	access:public	signature:()
hash_set::const_iterator	stl_hash_set.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_set	access:public
hash_set::const_pointer	stl_hash_set.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_set	access:public
hash_set::const_reference	stl_hash_set.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_set	access:public
hash_set::count	stl_hash_set.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_set	access:public	signature:(const key_type& key) const
hash_set::difference_type	stl_hash_set.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_set	access:public
hash_set::elems_in_bucket	stl_hash_set.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_set	access:public	signature:(size_type n) const
hash_set::empty	stl_hash_set.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_set	access:public	signature:() const
hash_set::end	stl_hash_set.h	/^  iterator end() const { return rep.end(); }$/;"	f	class:hash_set	access:public	signature:() const
hash_set::equal_range	stl_hash_set.h	/^  pair<iterator, iterator> equal_range(const key_type& key) const$/;"	f	class:hash_set	access:public	signature:(const key_type& key) const
hash_set::erase	stl_hash_set.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_set	access:public	signature:(const key_type& key)
hash_set::erase	stl_hash_set.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_set	access:public	signature:(iterator f, iterator l)
hash_set::erase	stl_hash_set.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_set	access:public	signature:(iterator it)
hash_set::find	stl_hash_set.h	/^  iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_set	access:public	signature:(const key_type& key) const
hash_set::hash_funct	stl_hash_set.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_set	access:public	signature:() const
hash_set::hash_set	stl_hash_set.h	/^  explicit hash_set(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_set	access:public	signature:(size_type n)
hash_set::hash_set	stl_hash_set.h	/^  hash_set() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_set	access:public	signature:()
hash_set::hash_set	stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l)$/;"	f	class:hash_set	access:public	signature:(InputIterator f, InputIterator l)
hash_set::hash_set	stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_set	access:public	signature:(InputIterator f, InputIterator l, size_type n)
hash_set::hash_set	stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_set	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf)
hash_set::hash_set	stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_set	access:public	signature:(InputIterator f, InputIterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_set::hash_set	stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l)$/;"	f	class:hash_set	access:public	signature:(const value_type* f, const value_type* l)
hash_set::hash_set	stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_set	access:public	signature:(const value_type* f, const value_type* l, size_type n)
hash_set::hash_set	stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_set	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf)
hash_set::hash_set	stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_set	access:public	signature:(const value_type* f, const value_type* l, size_type n, const hasher& hf, const key_equal& eql)
hash_set::hash_set	stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l)$/;"	f	class:hash_set	access:public	signature:(const_iterator f, const_iterator l)
hash_set::hash_set	stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_set	access:public	signature:(const_iterator f, const_iterator l, size_type n)
hash_set::hash_set	stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_set	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf)
hash_set::hash_set	stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_set	access:public	signature:(const_iterator f, const_iterator l, size_type n, const hasher& hf, const key_equal& eql)
hash_set::hash_set	stl_hash_set.h	/^  hash_set(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_set	access:public	signature:(size_type n, const hasher& hf)
hash_set::hash_set	stl_hash_set.h	/^  hash_set(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_set	access:public	signature:(size_type n, const hasher& hf, const key_equal& eql)
hash_set::hasher	stl_hash_set.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_set	access:public
hash_set::ht	stl_hash_set.h	/^                    EqualKey, Alloc> ht;$/;"	t	class:hash_set	access:private
hash_set::insert	stl_hash_set.h	/^  pair<iterator, bool> insert(const value_type& obj)$/;"	f	class:hash_set	access:public	signature:(const value_type& obj)
hash_set::insert	stl_hash_set.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }$/;"	f	class:hash_set	access:public	signature:(InputIterator f, InputIterator l)
hash_set::insert	stl_hash_set.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_set	access:public	signature:(const value_type* f, const value_type* l)
hash_set::insert	stl_hash_set.h	/^  void insert(const_iterator f, const_iterator l) {rep.insert_unique(f, l); }$/;"	f	class:hash_set	access:public	signature:(const_iterator f, const_iterator l)
hash_set::insert_noresize	stl_hash_set.h	/^  pair<iterator, bool> insert_noresize(const value_type& obj)$/;"	f	class:hash_set	access:public	signature:(const value_type& obj)
hash_set::iterator	stl_hash_set.h	/^  typedef typename ht::const_iterator iterator;$/;"	t	class:hash_set	access:public
hash_set::key_eq	stl_hash_set.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_set	access:public	signature:() const
hash_set::key_equal	stl_hash_set.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_set	access:public
hash_set::key_type	stl_hash_set.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_set	access:public
hash_set::max_bucket_count	stl_hash_set.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_set	access:public	signature:() const
hash_set::max_size	stl_hash_set.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_set	access:public	signature:() const
hash_set::pointer	stl_hash_set.h	/^  typedef typename ht::const_pointer pointer;$/;"	t	class:hash_set	access:public
hash_set::reference	stl_hash_set.h	/^  typedef typename ht::const_reference reference;$/;"	t	class:hash_set	access:public
hash_set::rep	stl_hash_set.h	/^  ht rep;$/;"	m	class:hash_set	access:private
hash_set::resize	stl_hash_set.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_set	access:public	signature:(size_type hint)
hash_set::size	stl_hash_set.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_set	access:public	signature:() const
hash_set::size_type	stl_hash_set.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_set	access:public
hash_set::swap	stl_hash_set.h	/^  void swap(hash_set& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_set	access:public	signature:(hash_set& hs)
hash_set::value_type	stl_hash_set.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_set	access:public
hasher	stl_hash_map.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_map	access:public
hasher	stl_hash_map.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_multimap	access:public
hasher	stl_hash_set.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_multiset	access:public
hasher	stl_hash_set.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_set	access:public
hasher	stl_hashtable.h	/^  typedef HashFcn hasher;$/;"	t	class:hashtable	access:public
hashtable	stl_hashtable.h	/^          hashtable;$/;"	t	struct:__hashtable_const_iterator	access:public
hashtable	stl_hashtable.h	/^          hashtable;$/;"	t	struct:__hashtable_iterator	access:public
hashtable	stl_hashtable.h	/^  hashtable(const hashtable& ht)$/;"	f	class:hashtable	access:public	signature:(const hashtable& ht)
hashtable	stl_hashtable.h	/^  hashtable(size_type n,$/;"	f	class:hashtable	access:public	signature:(size_type n, const HashFcn& hf, const EqualKey& eql)
hashtable	stl_hashtable.h	/^  hashtable(size_type n,$/;"	f	class:hashtable	access:public	signature:(size_type n, const HashFcn& hf, const EqualKey& eql, const ExtractKey& ext)
hashtable	stl_hashtable.h	/^class hashtable {$/;"	c
hashtable::__STL_NULL_TMPL_ARGS	stl_hashtable.h	/^  operator== __STL_NULL_TMPL_ARGS (const hashtable&, const hashtable&);$/;"	p	class:hashtable	access:friend	signature:(const hashtable&, const hashtable&)
hashtable::begin	stl_hashtable.h	/^  const_iterator begin() const$/;"	f	class:hashtable	access:public	signature:() const
hashtable::begin	stl_hashtable.h	/^  iterator begin()$/;"	f	class:hashtable	access:public	signature:()
hashtable::bkt_num	stl_hashtable.h	/^  size_type bkt_num(const value_type& obj) const$/;"	f	class:hashtable	access:private	signature:(const value_type& obj) const
hashtable::bkt_num	stl_hashtable.h	/^  size_type bkt_num(const value_type& obj, size_t n) const$/;"	f	class:hashtable	access:private	signature:(const value_type& obj, size_t n) const
hashtable::bkt_num_key	stl_hashtable.h	/^  size_type bkt_num_key(const key_type& key) const$/;"	f	class:hashtable	access:private	signature:(const key_type& key) const
hashtable::bkt_num_key	stl_hashtable.h	/^  size_type bkt_num_key(const key_type& key, size_t n) const$/;"	f	class:hashtable	access:private	signature:(const key_type& key, size_t n) const
hashtable::bucket_count	stl_hashtable.h	/^  size_type bucket_count() const { return buckets.size(); }$/;"	f	class:hashtable	access:public	signature:() const
hashtable::buckets	stl_hashtable.h	/^  vector<node*,Alloc> buckets;$/;"	m	class:hashtable	access:private
hashtable::clear	stl_hashtable.h	/^  void clear();$/;"	p	class:hashtable	access:public	signature:()
hashtable::clear	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::clear()$/;"	f	class:hashtable	signature:()
hashtable::const_iterator	stl_hashtable.h	/^  const_iterator;$/;"	t	class:hashtable	access:public
hashtable::const_pointer	stl_hashtable.h	/^  typedef const value_type* const_pointer;$/;"	t	class:hashtable	access:public
hashtable::const_reference	stl_hashtable.h	/^  typedef const value_type& const_reference;$/;"	t	class:hashtable	access:public
hashtable::copy_from	stl_hashtable.h	/^  void copy_from(const hashtable& ht);$/;"	p	class:hashtable	access:private	signature:(const hashtable& ht)
hashtable::copy_from	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::copy_from(const hashtable& ht)$/;"	f	class:hashtable	signature:(const hashtable& ht)
hashtable::count	stl_hashtable.h	/^  size_type count(const key_type& key) const$/;"	f	class:hashtable	access:public	signature:(const key_type& key) const
hashtable::delete_node	stl_hashtable.h	/^  void delete_node(node* n)$/;"	f	class:hashtable	access:private	signature:(node* n)
hashtable::difference_type	stl_hashtable.h	/^  typedef ptrdiff_t         difference_type;$/;"	t	class:hashtable	access:public
hashtable::elems_in_bucket	stl_hashtable.h	/^  size_type elems_in_bucket(size_type bucket) const$/;"	f	class:hashtable	access:public	signature:(size_type bucket) const
hashtable::empty	stl_hashtable.h	/^  bool empty() const { return size() == 0; }$/;"	f	class:hashtable	access:public	signature:() const
hashtable::end	stl_hashtable.h	/^  const_iterator end() const { return const_iterator(0, this); }$/;"	f	class:hashtable	access:public	signature:() const
hashtable::end	stl_hashtable.h	/^  iterator end() { return iterator(0, this); }$/;"	f	class:hashtable	access:public	signature:()
hashtable::equal_range	stl_hashtable.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& key) const;$/;"	p	class:hashtable	access:public	signature:(const key_type& key) const
hashtable::equal_range	stl_hashtable.h	/^  pair<iterator, iterator> equal_range(const key_type& key);$/;"	p	class:hashtable	access:public	signature:(const key_type& key)
hashtable::equal_range	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key) const$/;"	f	class:hashtable	signature:(const key_type& key) const
hashtable::equal_range	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key)$/;"	f	class:hashtable	signature:(const key_type& key)
hashtable::equals	stl_hashtable.h	/^  key_equal equals;$/;"	m	class:hashtable	access:private
hashtable::erase	stl_hashtable.h	/^  size_type erase(const key_type& key);$/;"	p	class:hashtable	access:public	signature:(const key_type& key)
hashtable::erase	stl_hashtable.h	/^  void erase(const const_iterator& it);$/;"	p	class:hashtable	access:public	signature:(const const_iterator& it)
hashtable::erase	stl_hashtable.h	/^  void erase(const iterator& it);$/;"	p	class:hashtable	access:public	signature:(const iterator& it)
hashtable::erase	stl_hashtable.h	/^  void erase(const_iterator first, const_iterator last);$/;"	p	class:hashtable	access:public	signature:(const_iterator first, const_iterator last)
hashtable::erase	stl_hashtable.h	/^  void erase(iterator first, iterator last);$/;"	p	class:hashtable	access:public	signature:(iterator first, iterator last)
hashtable::erase	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const const_iterator& it)$/;"	f	class:hashtable	signature:(const const_iterator& it)
hashtable::erase	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const key_type& key)$/;"	f	class:hashtable	signature:(const key_type& key)
hashtable::erase	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const_iterator first,$/;"	f	class:hashtable	signature:(const_iterator first, const_iterator last)
hashtable::erase	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase(const iterator& it)$/;"	f	class:hashtable	signature:(const iterator& it)
hashtable::erase	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase(iterator first, iterator last)$/;"	f	class:hashtable	signature:(iterator first, iterator last)
hashtable::erase_bucket	stl_hashtable.h	/^  void erase_bucket(const size_type n, node* first, node* last);$/;"	p	class:hashtable	access:private	signature:(const size_type n, node* first, node* last)
hashtable::erase_bucket	stl_hashtable.h	/^  void erase_bucket(const size_type n, node* last);$/;"	p	class:hashtable	access:private	signature:(const size_type n, node* last)
hashtable::erase_bucket	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, node* last)$/;"	f	class:hashtable	signature:(const size_type n, node* last)
hashtable::erase_bucket	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, $/;"	f	class:hashtable	signature:(const size_type n, node* first, node* last)
hashtable::find	stl_hashtable.h	/^  const_iterator find(const key_type& key) const$/;"	f	class:hashtable	access:public	signature:(const key_type& key) const
hashtable::find	stl_hashtable.h	/^  iterator find(const key_type& key) $/;"	f	class:hashtable	access:public	signature:(const key_type& key)
hashtable::find_or_insert	stl_hashtable.h	/^  reference find_or_insert(const value_type& obj);$/;"	p	class:hashtable	access:public	signature:(const value_type& obj)
hashtable::find_or_insert	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::find_or_insert(const value_type& obj)$/;"	f	class:hashtable	signature:(const value_type& obj)
hashtable::get_key	stl_hashtable.h	/^  ExtractKey get_key;$/;"	m	class:hashtable	access:private
hashtable::hash	stl_hashtable.h	/^  hasher hash;$/;"	m	class:hashtable	access:private
hashtable::hash_funct	stl_hashtable.h	/^  hasher hash_funct() const { return hash; }$/;"	f	class:hashtable	access:public	signature:() const
hashtable::hasher	stl_hashtable.h	/^  typedef HashFcn hasher;$/;"	t	class:hashtable	access:public
hashtable::hashtable	stl_hashtable.h	/^  hashtable(const hashtable& ht)$/;"	f	class:hashtable	access:public	signature:(const hashtable& ht)
hashtable::hashtable	stl_hashtable.h	/^  hashtable(size_type n,$/;"	f	class:hashtable	access:public	signature:(size_type n, const HashFcn& hf, const EqualKey& eql)
hashtable::hashtable	stl_hashtable.h	/^  hashtable(size_type n,$/;"	f	class:hashtable	access:public	signature:(size_type n, const HashFcn& hf, const EqualKey& eql, const ExtractKey& ext)
hashtable::initialize_buckets	stl_hashtable.h	/^  void initialize_buckets(size_type n)$/;"	f	class:hashtable	access:private	signature:(size_type n)
hashtable::insert_equal	stl_hashtable.h	/^  iterator insert_equal(const value_type& obj)$/;"	f	class:hashtable	access:public	signature:(const value_type& obj)
hashtable::insert_equal	stl_hashtable.h	/^  void insert_equal(ForwardIterator f, ForwardIterator l,$/;"	f	class:hashtable	access:public	signature:(ForwardIterator f, ForwardIterator l, forward_iterator_tag)
hashtable::insert_equal	stl_hashtable.h	/^  void insert_equal(InputIterator f, InputIterator l)$/;"	f	class:hashtable	access:public	signature:(InputIterator f, InputIterator l)
hashtable::insert_equal	stl_hashtable.h	/^  void insert_equal(InputIterator f, InputIterator l,$/;"	f	class:hashtable	access:public	signature:(InputIterator f, InputIterator l, input_iterator_tag)
hashtable::insert_equal	stl_hashtable.h	/^  void insert_equal(const value_type* f, const value_type* l)$/;"	f	class:hashtable	access:public	signature:(const value_type* f, const value_type* l)
hashtable::insert_equal	stl_hashtable.h	/^  void insert_equal(const_iterator f, const_iterator l)$/;"	f	class:hashtable	access:public	signature:(const_iterator f, const_iterator l)
hashtable::insert_equal_noresize	stl_hashtable.h	/^  iterator insert_equal_noresize(const value_type& obj);$/;"	p	class:hashtable	access:public	signature:(const value_type& obj)
hashtable::insert_equal_noresize	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::insert_equal_noresize(const value_type& obj)$/;"	f	class:hashtable	signature:(const value_type& obj)
hashtable::insert_unique	stl_hashtable.h	/^  pair<iterator, bool> insert_unique(const value_type& obj)$/;"	f	class:hashtable	access:public	signature:(const value_type& obj)
hashtable::insert_unique	stl_hashtable.h	/^  void insert_unique(ForwardIterator f, ForwardIterator l,$/;"	f	class:hashtable	access:public	signature:(ForwardIterator f, ForwardIterator l, forward_iterator_tag)
hashtable::insert_unique	stl_hashtable.h	/^  void insert_unique(InputIterator f, InputIterator l)$/;"	f	class:hashtable	access:public	signature:(InputIterator f, InputIterator l)
hashtable::insert_unique	stl_hashtable.h	/^  void insert_unique(InputIterator f, InputIterator l,$/;"	f	class:hashtable	access:public	signature:(InputIterator f, InputIterator l, input_iterator_tag)
hashtable::insert_unique	stl_hashtable.h	/^  void insert_unique(const value_type* f, const value_type* l)$/;"	f	class:hashtable	access:public	signature:(const value_type* f, const value_type* l)
hashtable::insert_unique	stl_hashtable.h	/^  void insert_unique(const_iterator f, const_iterator l)$/;"	f	class:hashtable	access:public	signature:(const_iterator f, const_iterator l)
hashtable::insert_unique_noresize	stl_hashtable.h	/^  pair<iterator, bool> insert_unique_noresize(const value_type& obj);$/;"	p	class:hashtable	access:public	signature:(const value_type& obj)
hashtable::insert_unique_noresize	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::insert_unique_noresize(const value_type& obj)$/;"	f	class:hashtable	signature:(const value_type& obj)
hashtable::iterator	stl_hashtable.h	/^  iterator;$/;"	t	class:hashtable	access:public
hashtable::key_eq	stl_hashtable.h	/^  key_equal key_eq() const { return equals; }$/;"	f	class:hashtable	access:public	signature:() const
hashtable::key_equal	stl_hashtable.h	/^  typedef EqualKey key_equal;$/;"	t	class:hashtable	access:public
hashtable::key_type	stl_hashtable.h	/^  typedef Key key_type;$/;"	t	class:hashtable	access:public
hashtable::max_bucket_count	stl_hashtable.h	/^  size_type max_bucket_count() const$/;"	f	class:hashtable	access:public	signature:() const
hashtable::max_size	stl_hashtable.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:hashtable	access:public	signature:() const
hashtable::new_node	stl_hashtable.h	/^  node* new_node(const value_type& obj)$/;"	f	class:hashtable	access:private	signature:(const value_type& obj)
hashtable::next_size	stl_hashtable.h	/^  size_type next_size(size_type n) const { return __stl_next_prime(n); }$/;"	f	class:hashtable	access:private	signature:(size_type n) const
hashtable::node	stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	class:hashtable	access:private
hashtable::node_allocator	stl_hashtable.h	/^  typedef simple_alloc<node, Alloc> node_allocator;$/;"	t	class:hashtable	access:private
hashtable::num_elements	stl_hashtable.h	/^  size_type num_elements;$/;"	m	class:hashtable	access:private
hashtable::operator =	stl_hashtable.h	/^  hashtable& operator= (const hashtable& ht)$/;"	f	class:hashtable	access:public	signature:(const hashtable& ht)
hashtable::pointer	stl_hashtable.h	/^  typedef value_type*       pointer;$/;"	t	class:hashtable	access:public
hashtable::reference	stl_hashtable.h	/^  typedef value_type&       reference;$/;"	t	class:hashtable	access:public
hashtable::resize	stl_hashtable.h	/^  void resize(size_type num_elements_hint);$/;"	p	class:hashtable	access:public	signature:(size_type num_elements_hint)
hashtable::resize	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::resize(size_type num_elements_hint)$/;"	f	class:hashtable	signature:(size_type num_elements_hint)
hashtable::size	stl_hashtable.h	/^  size_type size() const { return num_elements; }$/;"	f	class:hashtable	access:public	signature:() const
hashtable::size_type	stl_hashtable.h	/^  typedef size_t            size_type;$/;"	t	class:hashtable	access:public
hashtable::swap	stl_hashtable.h	/^  void swap(hashtable& ht)$/;"	f	class:hashtable	access:public	signature:(hashtable& ht)
hashtable::value_type	stl_hashtable.h	/^  typedef Value value_type;$/;"	t	class:hashtable	access:public
hashtable::~hashtable	stl_hashtable.h	/^  ~hashtable() { clear(); }$/;"	f	class:hashtable	access:public	signature:()
head	stl_slist.h	/^  list_node_base head;$/;"	m	class:slist	access:private
header	stl_tree.h	/^  link_type header;  $/;"	m	class:rb_tree	access:protected
heap_size	stl_alloc.h	/^  static size_t heap_size;$/;"	m	class:__default_alloc_template	access:private
heap_size	stl_alloc.h	/^size_t __default_alloc_template<threads, inst>::heap_size = 0;$/;"	m	class:__default_alloc_template
ht	stl_hash_map.h	/^                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;$/;"	t	class:hash_map	access:private
ht	stl_hash_map.h	/^                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;$/;"	t	class:hash_multimap	access:private
ht	stl_hash_set.h	/^                    EqualKey, Alloc> ht;$/;"	t	class:hash_multiset	access:private
ht	stl_hash_set.h	/^                    EqualKey, Alloc> ht;$/;"	t	class:hash_set	access:private
ht	stl_hashtable.h	/^  const hashtable* ht;$/;"	m	struct:__hashtable_const_iterator	access:public
ht	stl_hashtable.h	/^  hashtable* ht;$/;"	m	struct:__hashtable_iterator	access:public
identity	stl_function.h	/^struct identity : public unary_function<T, T> {$/;"	s	inherits:unary_function
identity::operator ()	stl_function.h	/^  const T& operator()(const T& x) const { return x; }$/;"	f	struct:identity	access:public	signature:(const T& x) const
identity_element	stl_function.h	/^template <class T> inline T identity_element(multiplies<T>) { return T(1); }$/;"	f	signature:(multiplies<T>)
identity_element	stl_function.h	/^template <class T> inline T identity_element(plus<T>) { return T(0); }$/;"	f	signature:(plus<T>)
identity_element	stl_rope.h	/^        friend rope identity_element(concat_fn) { return rope<charT,Alloc>(); }$/;"	f	class:rope	access:friend	signature:(concat_fn)
includes	stl_algo.h	/^bool includes(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2)
includes	stl_algo.h	/^bool includes(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp)
incr	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::incr(size_t n) {$/;"	f	class:__rope_iterator_base	signature:(size_t n)
incr	stl_rope.h	/^    void incr(size_t n);$/;"	p	class:__rope_iterator_base	access:protected	signature:(size_t n)
incr	stl_slist.h	/^  void incr() { node = node->next; }$/;"	f	struct:__slist_iterator_base	access:public	signature:()
incr_refcount	stl_rope.h	/^	    void incr_refcount ()$/;"	f	struct:__rope_RopeBase	access:public	signature:()
incr_refcount	stl_rope.h	/^	void incr_refcount () {}$/;"	f	struct:__rope_RopeBase	access:public	signature:()
incr_refcount	stl_rope.h	/^            void incr_refcount ()$/;"	f	struct:__rope_RopeBase	access:public	signature:()
increment	stl_tree.h	/^  void increment()$/;"	f	struct:__rb_tree_base_iterator	access:public	signature:()
index	stl_rope.h	/^    size_t index() const { return current_pos; }$/;"	f	class:__rope_iterator_base	access:public	signature:() const
index1	stl_function.h	/^  size_t index1;$/;"	m	class:subtractive_rng	access:private
index2	stl_function.h	/^  size_t index2;$/;"	m	class:subtractive_rng	access:private
init	stl_tree.h	/^  void init() {$/;"	f	class:rb_tree	access:private	signature:()
init_page_size	defalloc.h	/^    size_type init_page_size() { $/;"	f	class:allocator	access:public	signature:()
init_refcount_lock	stl_rope.h	/^	    void init_refcount_lock() {$/;"	f	struct:__rope_RopeBase	access:public	signature:()
init_refcount_lock	stl_rope.h	/^	    void init_refcount_lock() {}$/;"	f	struct:__rope_RopeBase	access:public	signature:()
initial_map_size	stl_deque.h	/^  static size_type initial_map_size() { return 8; }$/;"	f	class:__deque_iterator::deque	access:protected	signature:()
initialize	stl_bvector.h	/^  void initialize(size_type n) {$/;"	f	class:vector	access:protected	signature:(size_type n)
initialize	stl_function.h	/^  void initialize(unsigned int seed)$/;"	f	class:subtractive_rng	access:public	signature:(unsigned int seed)
initialize_buckets	stl_hashtable.h	/^  void initialize_buckets(size_type n)$/;"	f	class:hashtable	access:private	signature:(size_type n)
initialize_buffer	stl_tempbuf.h	/^  void initialize_buffer(const T& val, __false_type) {$/;"	f	class:temporary_buffer	access:private	signature:(const T& val, __false_type)
initialize_buffer	stl_tempbuf.h	/^  void initialize_buffer(const T&, __true_type) {}$/;"	f	class:temporary_buffer	access:private	signature:(const T&, __true_type)
initialize_range	stl_bvector.h	/^  void initialize_range(ForwardIterator first, ForwardIterator last,$/;"	f	class:vector	access:protected	signature:(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
initialize_range	stl_bvector.h	/^  void initialize_range(InputIterator first, InputIterator last,$/;"	f	class:vector	access:protected	signature:(InputIterator first, InputIterator last, input_iterator_tag)
inner_product	stl_numeric.h	/^T inner_product(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init)
inner_product	stl_numeric.h	/^T inner_product(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryOperation1 binary_op1, BinaryOperation2 binary_op2)
inplace_merge	stl_algo.h	/^inline void inplace_merge(BidirectionalIterator first,$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last)
inplace_merge	stl_algo.h	/^inline void inplace_merge(BidirectionalIterator first,$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp)
input_iterator	stl_iterator.h	/^template <class T, class Distance> struct input_iterator {$/;"	s
input_iterator::difference_type	stl_iterator.h	/^  typedef Distance           difference_type;$/;"	t	struct:input_iterator	access:public
input_iterator::iterator_category	stl_iterator.h	/^  typedef input_iterator_tag iterator_category;$/;"	t	struct:input_iterator	access:public
input_iterator::pointer	stl_iterator.h	/^  typedef T*                 pointer;$/;"	t	struct:input_iterator	access:public
input_iterator::reference	stl_iterator.h	/^  typedef T&                 reference;$/;"	t	struct:input_iterator	access:public
input_iterator::value_type	stl_iterator.h	/^  typedef T                  value_type;$/;"	t	struct:input_iterator	access:public
input_iterator_tag	stl_iterator.h	/^struct input_iterator_tag {};$/;"	s
insert	stl_bvector.h	/^  iterator insert(iterator position, bool x = bool()) {$/;"	f	class:vector	access:public	signature:(iterator position, bool x = bool())
insert	stl_bvector.h	/^  template <class InputIterator> void insert(iterator position,$/;"	f	class:vector	access:public	signature:(iterator position, InputIterator first, InputIterator last)
insert	stl_bvector.h	/^  void insert(iterator pos, int n, bool x)  { insert(pos, (size_type)n, x); }$/;"	f	class:vector	access:public	signature:(iterator pos, int n, bool x)
insert	stl_bvector.h	/^  void insert(iterator pos, long n, bool x) { insert(pos, (size_type)n, x); }$/;"	f	class:vector	access:public	signature:(iterator pos, long n, bool x)
insert	stl_bvector.h	/^  void insert(iterator position, const bool* first, const bool* last) {$/;"	f	class:vector	access:public	signature:(iterator position, const bool* first, const bool* last)
insert	stl_bvector.h	/^  void insert(iterator position, const_iterator first, $/;"	f	class:vector	access:public	signature:(iterator position, const_iterator first, const_iterator last)
insert	stl_bvector.h	/^  void insert(iterator position, size_type n, bool x) {$/;"	f	class:vector	access:public	signature:(iterator position, size_type n, bool x)
insert	stl_deque.h	/^  iterator insert(iterator position) { return insert(position, value_type()); }$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator position)
insert	stl_deque.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator position, const value_type& x)
insert	stl_deque.h	/^  void insert(iterator pos, ForwardIterator first, ForwardIterator last,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, ForwardIterator first, ForwardIterator last, forward_iterator_tag)
insert	stl_deque.h	/^  void insert(iterator pos, InputIterator first, InputIterator last) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, InputIterator first, InputIterator last)
insert	stl_deque.h	/^  void insert(iterator pos, InputIterator first, InputIterator last,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, InputIterator first, InputIterator last, input_iterator_tag)
insert	stl_deque.h	/^  void insert(iterator pos, const value_type* first, const value_type* last);$/;"	p	class:__deque_iterator::deque	access:public	signature:(iterator pos, const value_type* first, const value_type* last)
insert	stl_deque.h	/^  void insert(iterator pos, const_iterator first, const_iterator last);$/;"	p	class:__deque_iterator::deque	access:public	signature:(iterator pos, const_iterator first, const_iterator last)
insert	stl_deque.h	/^  void insert(iterator pos, int n, const value_type& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, int n, const value_type& x)
insert	stl_deque.h	/^  void insert(iterator pos, long n, const value_type& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, long n, const value_type& x)
insert	stl_deque.h	/^  void insert(iterator pos, size_type n, const value_type& x); $/;"	p	class:__deque_iterator::deque	access:public	signature:(iterator pos, size_type n, const value_type& x)
insert	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, ForwardIterator first, ForwardIterator last, forward_iterator_tag)
insert	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, InputIterator first, InputIterator last, input_iterator_tag)
insert	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, const value_type* first, const value_type* last)
insert	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, const_iterator first, const_iterator last)
insert	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, size_type n, const value_type& x)
insert	stl_hash_map.h	/^  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }$/;"	f	class:hash_multimap	access:public	signature:(const value_type& obj)
insert	stl_hash_map.h	/^  pair<iterator, bool> insert(const value_type& obj)$/;"	f	class:hash_map	access:public	signature:(const value_type& obj)
insert	stl_hash_map.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }$/;"	f	class:hash_multimap	access:public	signature:(InputIterator f, InputIterator l)
insert	stl_hash_map.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }$/;"	f	class:hash_map	access:public	signature:(InputIterator f, InputIterator l)
insert	stl_hash_map.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_map	access:public	signature:(const value_type* f, const value_type* l)
insert	stl_hash_map.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_multimap	access:public	signature:(const value_type* f, const value_type* l)
insert	stl_hash_map.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }$/;"	f	class:hash_multimap	access:public	signature:(const_iterator f, const_iterator l)
insert	stl_hash_map.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_unique(f, l); }$/;"	f	class:hash_map	access:public	signature:(const_iterator f, const_iterator l)
insert	stl_hash_set.h	/^  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }$/;"	f	class:hash_multiset	access:public	signature:(const value_type& obj)
insert	stl_hash_set.h	/^  pair<iterator, bool> insert(const value_type& obj)$/;"	f	class:hash_set	access:public	signature:(const value_type& obj)
insert	stl_hash_set.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }$/;"	f	class:hash_multiset	access:public	signature:(InputIterator f, InputIterator l)
insert	stl_hash_set.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }$/;"	f	class:hash_set	access:public	signature:(InputIterator f, InputIterator l)
insert	stl_hash_set.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_multiset	access:public	signature:(const value_type* f, const value_type* l)
insert	stl_hash_set.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_set	access:public	signature:(const value_type* f, const value_type* l)
insert	stl_hash_set.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }$/;"	f	class:hash_multiset	access:public	signature:(const_iterator f, const_iterator l)
insert	stl_hash_set.h	/^  void insert(const_iterator f, const_iterator l) {rep.insert_unique(f, l); }$/;"	f	class:hash_set	access:public	signature:(const_iterator f, const_iterator l)
insert	stl_list.h	/^  iterator insert(iterator position) { return insert(position, T()); }$/;"	f	class:list	access:public	signature:(iterator position)
insert	stl_list.h	/^  iterator insert(iterator position, const T& x) {$/;"	f	class:list	access:public	signature:(iterator position, const T& x)
insert	stl_list.h	/^  void insert(iterator pos, int n, const T& x) {$/;"	f	class:list	access:public	signature:(iterator pos, int n, const T& x)
insert	stl_list.h	/^  void insert(iterator pos, long n, const T& x) {$/;"	f	class:list	access:public	signature:(iterator pos, long n, const T& x)
insert	stl_list.h	/^  void insert(iterator pos, size_type n, const T& x);$/;"	p	class:list	access:public	signature:(iterator pos, size_type n, const T& x)
insert	stl_list.h	/^  void insert(iterator position, InputIterator first, InputIterator last);$/;"	p	class:list	access:public	signature:(iterator position, InputIterator first, InputIterator last)
insert	stl_list.h	/^  void insert(iterator position, const T* first, const T* last);$/;"	p	class:list	access:public	signature:(iterator position, const T* first, const T* last)
insert	stl_list.h	/^  void insert(iterator position,$/;"	p	class:list	access:public	signature:(iterator position, const_iterator first, const_iterator last)
insert	stl_list.h	/^void list<T, Alloc>::insert(iterator position, const T* first, const T* last) {$/;"	f	class:list	signature:(iterator position, const T* first, const T* last)
insert	stl_list.h	/^void list<T, Alloc>::insert(iterator position, size_type n, const T& x) {$/;"	f	class:list	signature:(iterator position, size_type n, const T& x)
insert	stl_list.h	/^void list<T, Alloc>::insert(iterator position,$/;"	f	class:list	signature:(iterator position, InputIterator first, InputIterator last)
insert	stl_list.h	/^void list<T, Alloc>::insert(iterator position,$/;"	f	class:list	signature:(iterator position, const_iterator first, const_iterator last)
insert	stl_map.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:map	access:public	signature:(iterator position, const value_type& x)
insert	stl_map.h	/^  pair<iterator,bool> insert(const value_type& x) { return t.insert_unique(x); }$/;"	f	class:map	access:public	signature:(const value_type& x)
insert	stl_map.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:map	access:public	signature:(InputIterator first, InputIterator last)
insert	stl_map.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:map	access:public	signature:(const value_type* first, const value_type* last)
insert	stl_map.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:map	access:public	signature:(const_iterator first, const_iterator last)
insert	stl_multimap.h	/^  iterator insert(const value_type& x) { return t.insert_equal(x); }$/;"	f	class:multimap	access:public	signature:(const value_type& x)
insert	stl_multimap.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:multimap	access:public	signature:(iterator position, const value_type& x)
insert	stl_multimap.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:multimap	access:public	signature:(InputIterator first, InputIterator last)
insert	stl_multimap.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:multimap	access:public	signature:(const value_type* first, const value_type* last)
insert	stl_multimap.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:multimap	access:public	signature:(const_iterator first, const_iterator last)
insert	stl_multiset.h	/^  iterator insert(const value_type& x) { $/;"	f	class:multiset	access:public	signature:(const value_type& x)
insert	stl_multiset.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:multiset	access:public	signature:(iterator position, const value_type& x)
insert	stl_multiset.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:multiset	access:public	signature:(InputIterator first, InputIterator last)
insert	stl_multiset.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:multiset	access:public	signature:(const value_type* first, const value_type* last)
insert	stl_multiset.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:multiset	access:public	signature:(const_iterator first, const_iterator last)
insert	stl_rope.h	/^	iterator insert(const iterator& p ) $/;"	f	class:rope	access:public	signature:(const iterator& p )
insert	stl_rope.h	/^	iterator insert(const iterator& p, charT c) $/;"	f	class:rope	access:public	signature:(const iterator& p, charT c)
insert	stl_rope.h	/^	iterator insert(const iterator& p, const charT *c_string) $/;"	f	class:rope	access:public	signature:(const iterator& p, const charT *c_string)
insert	stl_rope.h	/^	iterator insert(const iterator& p, const charT *i, const charT *j)$/;"	f	class:rope	access:public	signature:(const iterator& p, const charT *i, const charT *j)
insert	stl_rope.h	/^	iterator insert(const iterator& p, const charT *i, size_t n)$/;"	f	class:rope	access:public	signature:(const iterator& p, const charT *i, size_t n)
insert	stl_rope.h	/^	iterator insert(const iterator& p, const rope& r)$/;"	f	class:rope	access:public	signature:(const iterator& p, const rope& r)
insert	stl_rope.h	/^	iterator insert(const iterator& p, size_t n, charT c)$/;"	f	class:rope	access:public	signature:(const iterator& p, size_t n, charT c)
insert	stl_rope.h	/^	iterator insert(const iterator& p,$/;"	f	class:rope	access:public	signature:(const iterator& p, const const_iterator& i, const const_iterator& j)
insert	stl_rope.h	/^	iterator insert(const iterator& p,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& i, const iterator& j)
insert	stl_rope.h	/^	void insert(size_t p) {$/;"	f	class:rope	access:public	signature:(size_t p)
insert	stl_rope.h	/^	void insert(size_t p, charT c) {$/;"	f	class:rope	access:public	signature:(size_t p, charT c)
insert	stl_rope.h	/^	void insert(size_t p, const charT * c_string) {$/;"	f	class:rope	access:public	signature:(size_t p, const charT * c_string)
insert	stl_rope.h	/^	void insert(size_t p, const charT * i, size_t n) {$/;"	f	class:rope	access:public	signature:(size_t p, const charT * i, size_t n)
insert	stl_rope.h	/^	void insert(size_t p, const charT *i, const charT *j) {$/;"	f	class:rope	access:public	signature:(size_t p, const charT *i, const charT *j)
insert	stl_rope.h	/^	void insert(size_t p, const const_iterator& i,$/;"	f	class:rope	access:public	signature:(size_t p, const const_iterator& i, const const_iterator& j)
insert	stl_rope.h	/^	void insert(size_t p, const iterator& i,$/;"	f	class:rope	access:public	signature:(size_t p, const iterator& i, const iterator& j)
insert	stl_rope.h	/^	void insert(size_t p, const rope& r) {$/;"	f	class:rope	access:public	signature:(size_t p, const rope& r)
insert	stl_rope.h	/^	void insert(size_t p, size_t n, charT c) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, charT c)
insert	stl_set.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:set	access:public	signature:(iterator position, const value_type& x)
insert	stl_set.h	/^  pair<iterator,bool> insert(const value_type& x) { $/;"	f	class:set	access:public	signature:(const value_type& x)
insert	stl_set.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:set	access:public	signature:(InputIterator first, InputIterator last)
insert	stl_set.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:set	access:public	signature:(const value_type* first, const value_type* last)
insert	stl_set.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:set	access:public	signature:(const_iterator first, const_iterator last)
insert	stl_slist.h	/^  iterator insert(iterator pos) {$/;"	f	class:slist	access:public	signature:(iterator pos)
insert	stl_slist.h	/^  iterator insert(iterator pos, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, const value_type& x)
insert	stl_slist.h	/^  void insert(iterator pos, InIter first, InIter last) {$/;"	f	class:slist	access:public	signature:(iterator pos, InIter first, InIter last)
insert	stl_slist.h	/^  void insert(iterator pos, const value_type* first, const value_type* last) {$/;"	f	class:slist	access:public	signature:(iterator pos, const value_type* first, const value_type* last)
insert	stl_slist.h	/^  void insert(iterator pos, const_iterator first, const_iterator last) {$/;"	f	class:slist	access:public	signature:(iterator pos, const_iterator first, const_iterator last)
insert	stl_slist.h	/^  void insert(iterator pos, int n, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, int n, const value_type& x)
insert	stl_slist.h	/^  void insert(iterator pos, long n, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, long n, const value_type& x)
insert	stl_slist.h	/^  void insert(iterator pos, size_type n, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, size_type n, const value_type& x)
insert	stl_vector.h	/^  iterator insert(iterator position) { return insert(position, T()); }$/;"	f	class:vector	access:public	signature:(iterator position)
insert	stl_vector.h	/^  iterator insert(iterator position, const T& x) {$/;"	f	class:vector	access:public	signature:(iterator position, const T& x)
insert	stl_vector.h	/^  void insert (iterator pos, int n, const T& x) {$/;"	f	class:vector	access:public	signature:(iterator pos, int n, const T& x)
insert	stl_vector.h	/^  void insert (iterator pos, long n, const T& x) {$/;"	f	class:vector	access:public	signature:(iterator pos, long n, const T& x)
insert	stl_vector.h	/^  void insert (iterator pos, size_type n, const T& x);$/;"	p	class:vector	access:public	signature:(iterator pos, size_type n, const T& x)
insert	stl_vector.h	/^  void insert(iterator position, InputIterator first, InputIterator last) {$/;"	f	class:vector	access:public	signature:(iterator position, InputIterator first, InputIterator last)
insert	stl_vector.h	/^  void insert(iterator position,$/;"	p	class:vector	access:public	signature:(iterator position, const_iterator first, const_iterator last)
insert	stl_vector.h	/^void vector<T, Alloc>::insert(iterator position, $/;"	f	class:vector	signature:(iterator position, const_iterator first, const_iterator last)
insert	stl_vector.h	/^void vector<T, Alloc>::insert(iterator position, size_type n, const T& x) {$/;"	f	class:vector	signature:(iterator position, size_type n, const T& x)
insert_after	stl_slist.h	/^  iterator insert_after(iterator pos) {$/;"	f	class:slist	access:public	signature:(iterator pos)
insert_after	stl_slist.h	/^  iterator insert_after(iterator pos, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, const value_type& x)
insert_after	stl_slist.h	/^  void insert_after(iterator pos, InIter first, InIter last) {$/;"	f	class:slist	access:public	signature:(iterator pos, InIter first, InIter last)
insert_after	stl_slist.h	/^  void insert_after(iterator pos, const_iterator first, const_iterator last) {$/;"	f	class:slist	access:public	signature:(iterator pos, const_iterator first, const_iterator last)
insert_after	stl_slist.h	/^  void insert_after(iterator pos, int n, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, int n, const value_type& x)
insert_after	stl_slist.h	/^  void insert_after(iterator pos, long n, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, long n, const value_type& x)
insert_after	stl_slist.h	/^  void insert_after(iterator pos, size_type n, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, size_type n, const value_type& x)
insert_after	stl_slist.h	/^  void insert_after(iterator pos,$/;"	f	class:slist	access:public	signature:(iterator pos, const value_type* first, const value_type* last)
insert_aux	stl_bvector.h	/^  void insert_aux(iterator position, bool x) {$/;"	f	class:vector	access:protected	signature:(iterator position, bool x)
insert_aux	stl_deque.h	/^  iterator insert_aux(iterator pos, const value_type& x);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, const value_type& x)
insert_aux	stl_deque.h	/^  void insert_aux(iterator pos, ForwardIterator first, ForwardIterator last,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, ForwardIterator first, ForwardIterator last, size_type n)
insert_aux	stl_deque.h	/^  void insert_aux(iterator pos, const_iterator first, const_iterator last,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, const_iterator first, const_iterator last, size_type n)
insert_aux	stl_deque.h	/^  void insert_aux(iterator pos, size_type n, const value_type& x);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, size_type n, const value_type& x)
insert_aux	stl_deque.h	/^  void insert_aux(iterator pos,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(iterator pos, const value_type* first, const value_type* last, size_type n)
insert_aux	stl_deque.h	/^deque<T, Alloc, BufSize>::insert_aux(iterator pos, const value_type& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, const value_type& x)
insert_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert_aux(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, ForwardIterator first, ForwardIterator last, size_type n)
insert_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert_aux(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, const value_type* first, const value_type* last, size_type n)
insert_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert_aux(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, const_iterator first, const_iterator last, size_type n)
insert_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert_aux(iterator pos,$/;"	f	class:__deque_iterator::deque	access:public	signature:(iterator pos, size_type n, const value_type& x)
insert_aux	stl_vector.h	/^  void insert_aux(iterator position, const T& x);$/;"	p	class:vector	access:protected	signature:(iterator position, const T& x)
insert_aux	stl_vector.h	/^void vector<T, Alloc>::insert_aux(iterator position, const T& x) {$/;"	f	class:vector	signature:(iterator position, const T& x)
insert_equal	stl_hashtable.h	/^  iterator insert_equal(const value_type& obj)$/;"	f	class:hashtable	access:public	signature:(const value_type& obj)
insert_equal	stl_hashtable.h	/^  void insert_equal(ForwardIterator f, ForwardIterator l,$/;"	f	class:hashtable	access:public	signature:(ForwardIterator f, ForwardIterator l, forward_iterator_tag)
insert_equal	stl_hashtable.h	/^  void insert_equal(InputIterator f, InputIterator l)$/;"	f	class:hashtable	access:public	signature:(InputIterator f, InputIterator l)
insert_equal	stl_hashtable.h	/^  void insert_equal(InputIterator f, InputIterator l,$/;"	f	class:hashtable	access:public	signature:(InputIterator f, InputIterator l, input_iterator_tag)
insert_equal	stl_hashtable.h	/^  void insert_equal(const value_type* f, const value_type* l)$/;"	f	class:hashtable	access:public	signature:(const value_type* f, const value_type* l)
insert_equal	stl_hashtable.h	/^  void insert_equal(const_iterator f, const_iterator l)$/;"	f	class:hashtable	access:public	signature:(const_iterator f, const_iterator l)
insert_equal	stl_tree.h	/^  iterator insert_equal(const value_type& x);$/;"	p	class:rb_tree	access:public	signature:(const value_type& x)
insert_equal	stl_tree.h	/^  iterator insert_equal(iterator position, const value_type& x);$/;"	p	class:rb_tree	access:public	signature:(iterator position, const value_type& x)
insert_equal	stl_tree.h	/^  void insert_equal(InputIterator first, InputIterator last);$/;"	p	class:rb_tree	access:public	signature:(InputIterator first, InputIterator last)
insert_equal	stl_tree.h	/^  void insert_equal(const value_type* first, const value_type* last);$/;"	p	class:rb_tree	access:public	signature:(const value_type* first, const value_type* last)
insert_equal	stl_tree.h	/^  void insert_equal(const_iterator first, const_iterator last);$/;"	p	class:rb_tree	access:public	signature:(const_iterator first, const_iterator last)
insert_equal	stl_tree.h	/^rb_tree<K, V, KoV, Cmp, Al>::insert_equal(const V* first, const V* last) {$/;"	f	class:rb_tree	signature:(const V* first, const V* last)
insert_equal	stl_tree.h	/^rb_tree<K, V, KoV, Cmp, Al>::insert_equal(const_iterator first,$/;"	f	class:rb_tree	signature:(const_iterator first, const_iterator last)
insert_equal	stl_tree.h	/^rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_equal(iterator position,$/;"	f	class:rb_tree	signature:(iterator position, const Val& v)
insert_equal	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_equal(const Value& v)$/;"	f	class:rb_tree	signature:(const Value& v)
insert_equal	stl_tree.h	/^void rb_tree<K, V, KoV, Cmp, Al>::insert_equal(II first, II last) {$/;"	f	class:rb_tree	signature:(II first, II last)
insert_equal_noresize	stl_hashtable.h	/^  iterator insert_equal_noresize(const value_type& obj);$/;"	p	class:hashtable	access:public	signature:(const value_type& obj)
insert_equal_noresize	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::insert_equal_noresize(const value_type& obj)$/;"	f	class:hashtable	signature:(const value_type& obj)
insert_iterator	stl_iterator.h	/^  insert_iterator(Container& x, typename Container::iterator i) $/;"	f	class:insert_iterator	access:public	signature:(Container& x, typename Container::iterator i)
insert_iterator	stl_iterator.h	/^class insert_iterator {$/;"	c
insert_iterator::container	stl_iterator.h	/^  Container* container;$/;"	m	class:insert_iterator	access:protected
insert_iterator::difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:insert_iterator	access:public
insert_iterator::insert_iterator	stl_iterator.h	/^  insert_iterator(Container& x, typename Container::iterator i) $/;"	f	class:insert_iterator	access:public	signature:(Container& x, typename Container::iterator i)
insert_iterator::iter	stl_iterator.h	/^  typename Container::iterator iter;$/;"	m	class:insert_iterator	access:protected
insert_iterator::iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:insert_iterator	access:public
insert_iterator::operator *	stl_iterator.h	/^  insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:insert_iterator	access:public	signature:()
insert_iterator::operator ++	stl_iterator.h	/^  insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:insert_iterator	access:public	signature:()
insert_iterator::operator ++	stl_iterator.h	/^  insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:insert_iterator	access:public	signature:(int)
insert_iterator::operator =	stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:insert_iterator	access:public	signature:(const typename Container::value_type& value)
insert_iterator::pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:insert_iterator	access:public
insert_iterator::reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	class:insert_iterator	access:public
insert_iterator::value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:insert_iterator	access:public
insert_noresize	stl_hash_map.h	/^  iterator insert_noresize(const value_type& obj)$/;"	f	class:hash_multimap	access:public	signature:(const value_type& obj)
insert_noresize	stl_hash_map.h	/^  pair<iterator, bool> insert_noresize(const value_type& obj)$/;"	f	class:hash_map	access:public	signature:(const value_type& obj)
insert_noresize	stl_hash_set.h	/^  iterator insert_noresize(const value_type& obj)$/;"	f	class:hash_multiset	access:public	signature:(const value_type& obj)
insert_noresize	stl_hash_set.h	/^  pair<iterator, bool> insert_noresize(const value_type& obj)$/;"	f	class:hash_set	access:public	signature:(const value_type& obj)
insert_ostream	ropeimpl.h	/^	typedef ostream insert_ostream;$/;"	t	class:__rope_insert_char_consumer	access:private
insert_range	stl_bvector.h	/^  void insert_range(iterator pos,$/;"	f	class:vector	access:protected	signature:(iterator pos, InputIterator first, InputIterator last, input_iterator_tag)
insert_range	stl_bvector.h	/^  void insert_range(iterator position,$/;"	f	class:vector	access:protected	signature:(iterator position, ForwardIterator first, ForwardIterator last, forward_iterator_tag)
insert_unique	stl_hashtable.h	/^  pair<iterator, bool> insert_unique(const value_type& obj)$/;"	f	class:hashtable	access:public	signature:(const value_type& obj)
insert_unique	stl_hashtable.h	/^  void insert_unique(ForwardIterator f, ForwardIterator l,$/;"	f	class:hashtable	access:public	signature:(ForwardIterator f, ForwardIterator l, forward_iterator_tag)
insert_unique	stl_hashtable.h	/^  void insert_unique(InputIterator f, InputIterator l)$/;"	f	class:hashtable	access:public	signature:(InputIterator f, InputIterator l)
insert_unique	stl_hashtable.h	/^  void insert_unique(InputIterator f, InputIterator l,$/;"	f	class:hashtable	access:public	signature:(InputIterator f, InputIterator l, input_iterator_tag)
insert_unique	stl_hashtable.h	/^  void insert_unique(const value_type* f, const value_type* l)$/;"	f	class:hashtable	access:public	signature:(const value_type* f, const value_type* l)
insert_unique	stl_hashtable.h	/^  void insert_unique(const_iterator f, const_iterator l)$/;"	f	class:hashtable	access:public	signature:(const_iterator f, const_iterator l)
insert_unique	stl_tree.h	/^  iterator insert_unique(iterator position, const value_type& x);$/;"	p	class:rb_tree	access:public	signature:(iterator position, const value_type& x)
insert_unique	stl_tree.h	/^  pair<iterator,bool> insert_unique(const value_type& x);$/;"	p	class:rb_tree	access:public	signature:(const value_type& x)
insert_unique	stl_tree.h	/^  void insert_unique(InputIterator first, InputIterator last);$/;"	p	class:rb_tree	access:public	signature:(InputIterator first, InputIterator last)
insert_unique	stl_tree.h	/^  void insert_unique(const value_type* first, const value_type* last);$/;"	p	class:rb_tree	access:public	signature:(const value_type* first, const value_type* last)
insert_unique	stl_tree.h	/^  void insert_unique(const_iterator first, const_iterator last);$/;"	p	class:rb_tree	access:public	signature:(const_iterator first, const_iterator last)
insert_unique	stl_tree.h	/^rb_tree<K, V, KoV, Cmp, A>::insert_unique(const V* first, const V* last) {$/;"	f	class:rb_tree	signature:(const V* first, const V* last)
insert_unique	stl_tree.h	/^rb_tree<K, V, KoV, Cmp, A>::insert_unique(const_iterator first,$/;"	f	class:rb_tree	signature:(const_iterator first, const_iterator last)
insert_unique	stl_tree.h	/^rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_unique(iterator position,$/;"	f	class:rb_tree	signature:(iterator position, const Val& v)
insert_unique	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_unique(const Value& v)$/;"	f	class:rb_tree	signature:(const Value& v)
insert_unique	stl_tree.h	/^void rb_tree<K, V, KoV, Cmp, Al>::insert_unique(II first, II last) {$/;"	f	class:rb_tree	signature:(II first, II last)
insert_unique_noresize	stl_hashtable.h	/^  pair<iterator, bool> insert_unique_noresize(const value_type& obj);$/;"	p	class:hashtable	access:public	signature:(const value_type& obj)
insert_unique_noresize	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::insert_unique_noresize(const value_type& obj)$/;"	f	class:hashtable	signature:(const value_type& obj)
inserter	stl_iterator.h	/^inline insert_iterator<Container> inserter(Container& x, Iterator i) {$/;"	f	signature:(Container& x, Iterator i)
iota	stl_numeric.h	/^void iota(ForwardIterator first, ForwardIterator last, T value) {$/;"	f	signature:(ForwardIterator first, ForwardIterator last, T value)
is0	stl_rope.h	/^	static bool is0(charT c) { return c == __eos((charT *)0); }$/;"	f	class:rope	access:protected	signature:(charT c)
is_POD_type	type_traits.h	/^   typedef __false_type    is_POD_type;$/;"	t	struct:__type_traits	access:public
is_POD_type	type_traits.h	/^   typedef __true_type    is_POD_type;$/;"	t	struct:__type_traits	access:public
is_almost_balanced	stl_rope.h	/^	static bool is_almost_balanced(RopeBase *r)$/;"	f	class:rope	access:protected	signature:(RopeBase *r)
is_balanced	stl_rope.h	/^	static bool is_balanced(RopeBase *r)$/;"	f	class:rope	access:protected	signature:(RopeBase *r)
is_balanced	stl_rope.h	/^    bool is_balanced:8;$/;"	m	struct:__rope_RopeBase	access:public
is_heap	stl_algo.h	/^inline bool is_heap(RandomAccessIterator first, RandomAccessIterator last)$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last)
is_heap	stl_algo.h	/^inline bool is_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp)
is_roughly_balanced	stl_rope.h	/^	static bool is_roughly_balanced(RopeBase *r)$/;"	f	class:rope	access:protected	signature:(RopeBase *r)
is_sorted	stl_algo.h	/^bool is_sorted(ForwardIterator first, ForwardIterator last)$/;"	f	signature:(ForwardIterator first, ForwardIterator last)
is_sorted	stl_algo.h	/^bool is_sorted(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, StrictWeakOrdering comp)
istream_iterator	stl_iterator.h	/^  istream_iterator() : stream(&cin), end_marker(false) {}$/;"	f	class:istream_iterator	access:public	signature:()
istream_iterator	stl_iterator.h	/^  istream_iterator(istream& s) : stream(&s) { read(); }$/;"	f	class:istream_iterator	access:public	signature:(istream& s)
istream_iterator	stl_iterator.h	/^class istream_iterator {$/;"	c
istream_iterator::__STL_NULL_TMPL_ARGS	stl_iterator.h	/^  operator== __STL_NULL_TMPL_ARGS (const istream_iterator<T, Distance>& x,$/;"	p	class:istream_iterator	access:friend	signature:(const istream_iterator<T, Distance>& x, const istream_iterator<T, Distance>& y)
istream_iterator::difference_type	stl_iterator.h	/^  typedef Distance           difference_type;$/;"	t	class:istream_iterator	access:public
istream_iterator::end_marker	stl_iterator.h	/^  bool end_marker;$/;"	m	class:istream_iterator	access:protected
istream_iterator::istream_iterator	stl_iterator.h	/^  istream_iterator() : stream(&cin), end_marker(false) {}$/;"	f	class:istream_iterator	access:public	signature:()
istream_iterator::istream_iterator	stl_iterator.h	/^  istream_iterator(istream& s) : stream(&s) { read(); }$/;"	f	class:istream_iterator	access:public	signature:(istream& s)
istream_iterator::iterator_category	stl_iterator.h	/^  typedef input_iterator_tag iterator_category;$/;"	t	class:istream_iterator	access:public
istream_iterator::operator *	stl_iterator.h	/^  reference operator*() const { return value; }$/;"	f	class:istream_iterator	access:public	signature:() const
istream_iterator::operator ++	stl_iterator.h	/^  istream_iterator<T, Distance> operator++(int)  {$/;"	f	class:istream_iterator	access:public	signature:(int)
istream_iterator::operator ++	stl_iterator.h	/^  istream_iterator<T, Distance>& operator++() { $/;"	f	class:istream_iterator	access:public	signature:()
istream_iterator::operator ->	stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:istream_iterator	access:public	signature:() const
istream_iterator::pointer	stl_iterator.h	/^  typedef const T*           pointer;$/;"	t	class:istream_iterator	access:public
istream_iterator::read	stl_iterator.h	/^  void read() {$/;"	f	class:istream_iterator	access:protected	signature:()
istream_iterator::reference	stl_iterator.h	/^  typedef const T&           reference;$/;"	t	class:istream_iterator	access:public
istream_iterator::stream	stl_iterator.h	/^  istream* stream;$/;"	m	class:istream_iterator	access:protected
istream_iterator::value	stl_iterator.h	/^  T value;$/;"	m	class:istream_iterator	access:protected
istream_iterator::value_type	stl_iterator.h	/^  typedef T                  value_type;$/;"	t	class:istream_iterator	access:public
iter	stl_iterator.h	/^  typename Container::iterator iter;$/;"	m	class:insert_iterator	access:protected
iter	stl_raw_storage_iter.h	/^  ForwardIterator iter;$/;"	m	class:raw_storage_iterator	access:protected
iter_swap	stl_algobase.h	/^inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {$/;"	f	signature:(ForwardIterator1 a, ForwardIterator2 b)
iterator	stl_bvector.h	/^  typedef __bit_iterator                iterator;$/;"	t	class:vector	access:public
iterator	stl_bvector.h	/^  typedef __bit_iterator iterator;$/;"	t	struct:__bit_iterator	access:public
iterator	stl_deque.h	/^  typedef __deque_iterator<T, T&, T*, BufSiz>              iterator;$/;"	t	class:__deque_iterator::deque	access:public
iterator	stl_deque.h	/^  typedef __deque_iterator<T, T&, T*, BufSiz>             iterator;$/;"	t	struct:__deque_iterator	access:public
iterator	stl_deque.h	/^  typedef __deque_iterator<T, T&, T*>                      iterator;$/;"	t	class:__deque_iterator::deque	access:public
iterator	stl_deque.h	/^  typedef __deque_iterator<T, T&, T*>             iterator;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
iterator	stl_hash_map.h	/^  typedef typename ht::iterator iterator;$/;"	t	class:hash_map	access:public
iterator	stl_hash_map.h	/^  typedef typename ht::iterator iterator;$/;"	t	class:hash_multimap	access:public
iterator	stl_hash_set.h	/^  typedef typename ht::const_iterator iterator;$/;"	t	class:hash_multiset	access:public
iterator	stl_hash_set.h	/^  typedef typename ht::const_iterator iterator;$/;"	t	class:hash_set	access:public
iterator	stl_hashtable.h	/^          iterator;$/;"	t	struct:__hashtable_const_iterator	access:public
iterator	stl_hashtable.h	/^          iterator;$/;"	t	struct:__hashtable_iterator	access:public
iterator	stl_hashtable.h	/^  iterator;$/;"	t	class:hashtable	access:public
iterator	stl_iterator.h	/^struct iterator {$/;"	s
iterator	stl_list.h	/^  typedef __list_iterator<T, T&, T*>             iterator;$/;"	t	class:list	access:public
iterator	stl_list.h	/^  typedef __list_iterator<T, T&, T*>             iterator;$/;"	t	struct:__list_iterator	access:public
iterator	stl_map.h	/^  typedef typename rep_type::iterator iterator;$/;"	t	class:map	access:public
iterator	stl_multimap.h	/^  typedef typename rep_type::iterator iterator;$/;"	t	class:multimap	access:public
iterator	stl_multiset.h	/^  typedef typename rep_type::const_iterator iterator;$/;"	t	class:multiset	access:public
iterator	stl_rope.h	/^	typedef __rope_iterator<charT,Alloc> iterator;$/;"	t	class:rope	access:public
iterator	stl_set.h	/^  typedef typename rep_type::const_iterator iterator;$/;"	t	class:set	access:public
iterator	stl_slist.h	/^  typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	class:slist	access:public
iterator	stl_slist.h	/^  typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	struct:__slist_iterator	access:public
iterator	stl_tree.h	/^  typedef __rb_tree_iterator<Value, Value&, Value*>             iterator;$/;"	t	struct:__rb_tree_iterator	access:public
iterator	stl_tree.h	/^  typedef __rb_tree_iterator<value_type, reference, pointer> iterator;$/;"	t	class:rb_tree	access:public
iterator	stl_vector.h	/^  typedef value_type* iterator;$/;"	t	class:vector	access:public
iterator::difference_type	stl_iterator.h	/^  typedef Distance  difference_type;$/;"	t	struct:iterator	access:public
iterator::iterator_category	stl_iterator.h	/^  typedef Category  iterator_category;$/;"	t	struct:iterator	access:public
iterator::pointer	stl_iterator.h	/^  typedef Pointer   pointer;$/;"	t	struct:iterator	access:public
iterator::reference	stl_iterator.h	/^  typedef Reference reference;$/;"	t	struct:iterator	access:public
iterator::value_type	stl_iterator.h	/^  typedef T         value_type;$/;"	t	struct:iterator	access:public
iterator_base	stl_slist.h	/^  typedef __slist_iterator_base iterator_base;$/;"	t	class:slist	access:private
iterator_buf_len	stl_rope.h	/^    enum { iterator_buf_len = 15 };$/;"	e	enum:__rope_iterator_base::__anon12
iterator_category	stl_deque.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
iterator_category	stl_deque.h	/^iterator_category(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {$/;"	f	struct:__deque_iterator	access:public	signature:(const __deque_iterator<T, Ref, Ptr, BufSiz>&)
iterator_category	stl_deque.h	/^iterator_category(const __deque_iterator<T, Ref, Ptr>&) {$/;"	f	struct:__deque_iterator	access:public	signature:(const __deque_iterator<T, Ref, Ptr>&)
iterator_category	stl_hashtable.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__hashtable_const_iterator	access:public
iterator_category	stl_hashtable.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__hashtable_iterator	access:public
iterator_category	stl_hashtable.h	/^iterator_category(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f	signature:(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)
iterator_category	stl_hashtable.h	/^iterator_category(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f	signature:(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)
iterator_category	stl_iterator.h	/^          iterator_category;$/;"	t	class:reverse_iterator	access:public
iterator_category	stl_iterator.h	/^  typedef Category  iterator_category;$/;"	t	struct:iterator	access:public
iterator_category	stl_iterator.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	class:reverse_bidirectional_iterator	access:public
iterator_category	stl_iterator.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:bidirectional_iterator	access:public
iterator_category	stl_iterator.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:forward_iterator	access:public
iterator_category	stl_iterator.h	/^  typedef input_iterator_tag iterator_category;$/;"	t	class:istream_iterator	access:public
iterator_category	stl_iterator.h	/^  typedef input_iterator_tag iterator_category;$/;"	t	struct:input_iterator	access:public
iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:back_insert_iterator	access:public
iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:front_insert_iterator	access:public
iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:insert_iterator	access:public
iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:ostream_iterator	access:public
iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	struct:output_iterator	access:public
iterator_category	stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	class:reverse_iterator	access:public
iterator_category	stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	struct:iterator_traits	access:public
iterator_category	stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	struct:random_access_iterator	access:public
iterator_category	stl_iterator.h	/^  typedef typename Iterator::iterator_category iterator_category;$/;"	t	struct:iterator_traits	access:public
iterator_category	stl_iterator.h	/^inline output_iterator_tag iterator_category(const output_iterator&) {$/;"	f	signature:(const output_iterator&)
iterator_category	stl_iterator.h	/^inline random_access_iterator_tag iterator_category(const T*) {$/;"	f	signature:(const T*)
iterator_category	stl_iterator.h	/^iterator_category(const Iterator&) {$/;"	f	signature:(const Iterator&)
iterator_category	stl_iterator.h	/^iterator_category(const back_insert_iterator<Container>&)$/;"	f	signature:(const back_insert_iterator<Container>&)
iterator_category	stl_iterator.h	/^iterator_category(const bidirectional_iterator<T, Distance>&) {$/;"	f	signature:(const bidirectional_iterator<T, Distance>&)
iterator_category	stl_iterator.h	/^iterator_category(const forward_iterator<T, Distance>&) {$/;"	f	signature:(const forward_iterator<T, Distance>&)
iterator_category	stl_iterator.h	/^iterator_category(const front_insert_iterator<Container>&)$/;"	f	signature:(const front_insert_iterator<Container>&)
iterator_category	stl_iterator.h	/^iterator_category(const input_iterator<T, Distance>&) {$/;"	f	signature:(const input_iterator<T, Distance>&)
iterator_category	stl_iterator.h	/^iterator_category(const insert_iterator<Container>&)$/;"	f	signature:(const insert_iterator<Container>&)
iterator_category	stl_iterator.h	/^iterator_category(const istream_iterator<T, Distance>&) {$/;"	f	signature:(const istream_iterator<T, Distance>&)
iterator_category	stl_iterator.h	/^iterator_category(const ostream_iterator<T>&) {$/;"	f	signature:(const ostream_iterator<T>&)
iterator_category	stl_iterator.h	/^iterator_category(const random_access_iterator<T, Distance>&) {$/;"	f	signature:(const random_access_iterator<T, Distance>&)
iterator_category	stl_iterator.h	/^iterator_category(const reverse_bidirectional_iterator<BidirectionalIterator,$/;"	f	signature:(const reverse_bidirectional_iterator<BidirectionalIterator, T, Reference, Distance>&)
iterator_category	stl_iterator.h	/^iterator_category(const reverse_iterator<RandomAccessIterator, T,$/;"	f	signature:(const reverse_iterator<RandomAccessIterator, T, Reference, Distance>&)
iterator_category	stl_list.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:__list_iterator	access:public
iterator_category	stl_list.h	/^iterator_category(const __list_iterator<T, Ref, Ptr>&) {$/;"	f	signature:(const __list_iterator<T, Ref, Ptr>&)
iterator_category	stl_raw_storage_iter.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:raw_storage_iterator	access:public
iterator_category	stl_raw_storage_iter.h	/^iterator_category(const raw_storage_iterator<ForwardIterator, T>&)$/;"	f	signature:(const raw_storage_iterator<ForwardIterator, T>&)
iterator_category	stl_slist.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__slist_iterator_base	access:public
iterator_category	stl_slist.h	/^iterator_category(const __slist_iterator_base&)$/;"	f	signature:(const __slist_iterator_base&)
iterator_category	stl_tree.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:__rb_tree_base_iterator	access:public
iterator_category	stl_tree.h	/^iterator_category(const __rb_tree_base_iterator&) {$/;"	f	signature:(const __rb_tree_base_iterator&)
iterator_traits	stl_iterator.h	/^struct iterator_traits {$/;"	s
iterator_traits	stl_iterator.h	/^struct iterator_traits<T*> {$/;"	s
iterator_traits	stl_iterator.h	/^struct iterator_traits<const T*> {$/;"	s
iterator_traits::difference_type	stl_iterator.h	/^  typedef ptrdiff_t                  difference_type;$/;"	t	struct:iterator_traits	access:public
iterator_traits::difference_type	stl_iterator.h	/^  typedef typename Iterator::difference_type   difference_type;$/;"	t	struct:iterator_traits	access:public
iterator_traits::iterator_category	stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	struct:iterator_traits	access:public
iterator_traits::iterator_category	stl_iterator.h	/^  typedef typename Iterator::iterator_category iterator_category;$/;"	t	struct:iterator_traits	access:public
iterator_traits::pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:iterator_traits	access:public
iterator_traits::pointer	stl_iterator.h	/^  typedef const T*                   pointer;$/;"	t	struct:iterator_traits	access:public
iterator_traits::pointer	stl_iterator.h	/^  typedef typename Iterator::pointer           pointer;$/;"	t	struct:iterator_traits	access:public
iterator_traits::reference	stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:iterator_traits	access:public
iterator_traits::reference	stl_iterator.h	/^  typedef const T&                   reference;$/;"	t	struct:iterator_traits	access:public
iterator_traits::reference	stl_iterator.h	/^  typedef typename Iterator::reference         reference;$/;"	t	struct:iterator_traits	access:public
iterator_traits::value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:iterator_traits	access:public
iterator_traits::value_type	stl_iterator.h	/^  typedef typename Iterator::value_type        value_type;$/;"	t	struct:iterator_traits	access:public
iterator_type	stl_iterator.h	/^  typedef Iterator iterator_type;$/;"	t	class:reverse_iterator	access:public
key	stl_tree.h	/^  static const Key& key(base_ptr x) { return KeyOfValue()(value(link_type(x)));} $/;"	f	class:rb_tree	access:protected	signature:(base_ptr x)
key	stl_tree.h	/^  static const Key& key(link_type x) { return KeyOfValue()(value(x)); }$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
key_comp	stl_map.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:map	access:public	signature:() const
key_comp	stl_multimap.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:multimap	access:public	signature:() const
key_comp	stl_multiset.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:multiset	access:public	signature:() const
key_comp	stl_set.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:set	access:public	signature:() const
key_comp	stl_tree.h	/^  Compare key_comp() const { return key_compare; }$/;"	f	class:rb_tree	access:public	signature:() const
key_compare	stl_map.h	/^  typedef Compare key_compare;$/;"	t	class:map	access:public
key_compare	stl_multimap.h	/^  typedef Compare key_compare;$/;"	t	class:multimap	access:public
key_compare	stl_multiset.h	/^  typedef Compare key_compare;$/;"	t	class:multiset	access:public
key_compare	stl_set.h	/^  typedef Compare key_compare;$/;"	t	class:set	access:public
key_compare	stl_tree.h	/^  Compare key_compare;$/;"	m	class:rb_tree	access:protected
key_eq	stl_hash_map.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_map	access:public	signature:() const
key_eq	stl_hash_map.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_multimap	access:public	signature:() const
key_eq	stl_hash_set.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_multiset	access:public	signature:() const
key_eq	stl_hash_set.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_set	access:public	signature:() const
key_eq	stl_hashtable.h	/^  key_equal key_eq() const { return equals; }$/;"	f	class:hashtable	access:public	signature:() const
key_equal	stl_hash_map.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_map	access:public
key_equal	stl_hash_map.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_multimap	access:public
key_equal	stl_hash_set.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_multiset	access:public
key_equal	stl_hash_set.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_set	access:public
key_equal	stl_hashtable.h	/^  typedef EqualKey key_equal;$/;"	t	class:hashtable	access:public
key_type	stl_hash_map.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_map	access:public
key_type	stl_hash_map.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_multimap	access:public
key_type	stl_hash_set.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_multiset	access:public
key_type	stl_hash_set.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_set	access:public
key_type	stl_hashtable.h	/^  typedef Key key_type;$/;"	t	class:hashtable	access:public
key_type	stl_map.h	/^  typedef Key key_type;$/;"	t	class:map	access:public
key_type	stl_multimap.h	/^  typedef Key key_type;$/;"	t	class:multimap	access:public
key_type	stl_multiset.h	/^  typedef Key key_type;$/;"	t	class:multiset	access:public
key_type	stl_set.h	/^  typedef Key key_type;$/;"	t	class:set	access:public
key_type	stl_tree.h	/^  typedef Key key_type;$/;"	t	class:rb_tree	access:public
last	stl_deque.h	/^  T* last;$/;"	m	struct:__deque_iterator::__deque_iterator	access:public
leaf	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon9
leaf_concat_char_iter	ropeimpl.h	/^rope<charT,Alloc>::leaf_concat_char_iter$/;"	f	class:rope	signature:(RopeLeaf * r, const charT * iter, size_t len)
leaf_concat_char_iter	stl_rope.h	/^	static RopeLeaf * leaf_concat_char_iter$/;"	p	class:rope	access:protected	signature:(RopeLeaf * r, const charT * iter, size_t slen)
leaf_index	stl_rope.h	/^    int leaf_index;     \/\/ Last valid pos in path_end;$/;"	m	class:__rope_iterator_base	access:protected
leaf_pos	stl_rope.h	/^    size_t leaf_pos;    \/\/ Starting position for current leaf$/;"	m	class:__rope_iterator_base	access:protected
left	stl_rope.h	/^    __rope_RopeBase<charT,Alloc>* left;$/;"	m	struct:__rope_RopeConcatenation	access:public
left	stl_tree.h	/^  base_ptr left;$/;"	m	struct:__rb_tree_node_base	access:public
left	stl_tree.h	/^  static link_type& left(base_ptr x) { return (link_type&)(x->left); }$/;"	f	class:rb_tree	access:protected	signature:(base_ptr x)
left	stl_tree.h	/^  static link_type& left(link_type x) { return (link_type&)(x->left); }$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
leftmost	stl_tree.h	/^  link_type& leftmost() const { return (link_type&) header->left; }$/;"	f	class:rb_tree	access:protected	signature:() const
len	stl_tempbuf.h	/^  ptrdiff_t len;$/;"	m	class:temporary_buffer	access:private
length	stl_rope.h	/^	size_type length() const {$/;"	f	class:rope	access:public	signature:() const
less	stl_function.h	/^struct less : public binary_function<T, T, bool> {$/;"	s	inherits:binary_function
less::operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x < y; }$/;"	f	struct:less	access:public	signature:(const T& x, const T& y) const
less_equal	stl_function.h	/^struct less_equal : public binary_function<T, T, bool> {$/;"	s	inherits:binary_function
less_equal::operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x <= y; }$/;"	f	struct:less_equal	access:public	signature:(const T& x, const T& y) const
lexicographical_compare	stl_algobase.h	/^bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2)
lexicographical_compare	stl_algobase.h	/^bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp)
lexicographical_compare	stl_algobase.h	/^inline bool lexicographical_compare(const char* first1, const char* last1,$/;"	f	signature:(const char* first1, const char* last1, const char* first2, const char* last2)
lexicographical_compare	stl_algobase.h	/^lexicographical_compare(const unsigned char* first1,$/;"	f	signature:(const unsigned char* first1, const unsigned char* last1, const unsigned char* first2, const unsigned char* last2)
lexicographical_compare_3way	stl_algobase.h	/^inline int lexicographical_compare_3way(const char* first1, const char* last1,$/;"	f	signature:(const char* first1, const char* last1, const char* first2, const char* last2)
lexicographical_compare_3way	stl_algobase.h	/^int lexicographical_compare_3way(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2)
lexicographical_compare_3way	stl_algobase.h	/^lexicographical_compare_3way(const unsigned char* first1,$/;"	f	signature:(const unsigned char* first1, const unsigned char* last1, const unsigned char* first2, const unsigned char* last2)
link_type	stl_list.h	/^  typedef __list_node<T>* link_type;$/;"	t	struct:__list_iterator	access:public
link_type	stl_list.h	/^  typedef list_node* link_type;$/;"	t	class:list	access:public
link_type	stl_tree.h	/^  typedef __rb_tree_node<Value>* link_type;$/;"	t	struct:__rb_tree_iterator	access:public
link_type	stl_tree.h	/^  typedef __rb_tree_node<Value>* link_type;$/;"	t	struct:__rb_tree_node	access:public
link_type	stl_tree.h	/^  typedef rb_tree_node* link_type;$/;"	t	class:rb_tree	access:public
list	stl_list.h	/^  explicit list(size_type n) { fill_initialize(n, T()); }$/;"	f	class:list	access:public	signature:(size_type n)
list	stl_list.h	/^  list() { empty_initialize(); }$/;"	f	class:list	access:public	signature:()
list	stl_list.h	/^  list(InputIterator first, InputIterator last) {$/;"	f	class:list	access:public	signature:(InputIterator first, InputIterator last)
list	stl_list.h	/^  list(const T* first, const T* last) { range_initialize(first, last); }$/;"	f	class:list	access:public	signature:(const T* first, const T* last)
list	stl_list.h	/^  list(const list<T, Alloc>& x) {$/;"	f	class:list	access:public	signature:(const list<T, Alloc>& x)
list	stl_list.h	/^  list(const_iterator first, const_iterator last) {$/;"	f	class:list	access:public	signature:(const_iterator first, const_iterator last)
list	stl_list.h	/^  list(int n, const T& value) { fill_initialize(n, value); }$/;"	f	class:list	access:public	signature:(int n, const T& value)
list	stl_list.h	/^  list(long n, const T& value) { fill_initialize(n, value); }$/;"	f	class:list	access:public	signature:(long n, const T& value)
list	stl_list.h	/^  list(size_type n, const T& value) { fill_initialize(n, value); }$/;"	f	class:list	access:public	signature:(size_type n, const T& value)
list	stl_list.h	/^class list {$/;"	c
list::__STL_NULL_TMPL_ARGS	stl_list.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const list& x, const list& y);$/;"	p	class:list	access:friend	signature:(const list& x, const list& y)
list::back	stl_list.h	/^  const_reference back() const { return *(--end()); }$/;"	f	class:list	access:public	signature:() const
list::back	stl_list.h	/^  reference back() { return *(--end()); }$/;"	f	class:list	access:public	signature:()
list::begin	stl_list.h	/^  const_iterator begin() const { return (link_type)((*node).next); }$/;"	f	class:list	access:public	signature:() const
list::begin	stl_list.h	/^  iterator begin() { return (link_type)((*node).next); }$/;"	f	class:list	access:public	signature:()
list::clear	stl_list.h	/^  void clear();$/;"	p	class:list	access:public	signature:()
list::clear	stl_list.h	/^void list<T, Alloc>::clear()$/;"	f	class:list	signature:()
list::const_iterator	stl_list.h	/^  typedef __list_iterator<T, const T&, const T*> const_iterator;$/;"	t	class:list	access:public
list::const_pointer	stl_list.h	/^  typedef const value_type* const_pointer;$/;"	t	class:list	access:public
list::const_reference	stl_list.h	/^  typedef const value_type& const_reference;$/;"	t	class:list	access:public
list::const_reverse_iterator	stl_list.h	/^  const_reverse_iterator;$/;"	t	class:list	access:public
list::const_reverse_iterator	stl_list.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:list	access:public
list::create_node	stl_list.h	/^  link_type create_node(const T& x) {$/;"	f	class:list	access:protected	signature:(const T& x)
list::destroy_node	stl_list.h	/^  void destroy_node(link_type p) {$/;"	f	class:list	access:protected	signature:(link_type p)
list::difference_type	stl_list.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:list	access:public
list::empty	stl_list.h	/^  bool empty() const { return node->next == node; }$/;"	f	class:list	access:public	signature:() const
list::empty_initialize	stl_list.h	/^  void empty_initialize() { $/;"	f	class:list	access:protected	signature:()
list::end	stl_list.h	/^  const_iterator end() const { return node; }$/;"	f	class:list	access:public	signature:() const
list::end	stl_list.h	/^  iterator end() { return node; }$/;"	f	class:list	access:public	signature:()
list::erase	stl_list.h	/^  iterator erase(iterator first, iterator last);$/;"	p	class:list	access:public	signature:(iterator first, iterator last)
list::erase	stl_list.h	/^  iterator erase(iterator position) {$/;"	f	class:list	access:public	signature:(iterator position)
list::erase	stl_list.h	/^list<T,Alloc>::iterator list<T, Alloc>::erase(iterator first, iterator last) {$/;"	f	class:list	signature:(iterator first, iterator last)
list::fill_initialize	stl_list.h	/^  void fill_initialize(size_type n, const T& value) {$/;"	f	class:list	access:protected	signature:(size_type n, const T& value)
list::front	stl_list.h	/^  const_reference front() const { return *begin(); }$/;"	f	class:list	access:public	signature:() const
list::front	stl_list.h	/^  reference front() { return *begin(); }$/;"	f	class:list	access:public	signature:()
list::get_node	stl_list.h	/^  link_type get_node() { return list_node_allocator::allocate(); }$/;"	f	class:list	access:protected	signature:()
list::insert	stl_list.h	/^  iterator insert(iterator position) { return insert(position, T()); }$/;"	f	class:list	access:public	signature:(iterator position)
list::insert	stl_list.h	/^  iterator insert(iterator position, const T& x) {$/;"	f	class:list	access:public	signature:(iterator position, const T& x)
list::insert	stl_list.h	/^  void insert(iterator pos, int n, const T& x) {$/;"	f	class:list	access:public	signature:(iterator pos, int n, const T& x)
list::insert	stl_list.h	/^  void insert(iterator pos, long n, const T& x) {$/;"	f	class:list	access:public	signature:(iterator pos, long n, const T& x)
list::insert	stl_list.h	/^  void insert(iterator pos, size_type n, const T& x);$/;"	p	class:list	access:public	signature:(iterator pos, size_type n, const T& x)
list::insert	stl_list.h	/^  void insert(iterator position, InputIterator first, InputIterator last);$/;"	p	class:list	access:public	signature:(iterator position, InputIterator first, InputIterator last)
list::insert	stl_list.h	/^  void insert(iterator position, const T* first, const T* last);$/;"	p	class:list	access:public	signature:(iterator position, const T* first, const T* last)
list::insert	stl_list.h	/^  void insert(iterator position,$/;"	p	class:list	access:public	signature:(iterator position, const_iterator first, const_iterator last)
list::insert	stl_list.h	/^void list<T, Alloc>::insert(iterator position, const T* first, const T* last) {$/;"	f	class:list	signature:(iterator position, const T* first, const T* last)
list::insert	stl_list.h	/^void list<T, Alloc>::insert(iterator position, size_type n, const T& x) {$/;"	f	class:list	signature:(iterator position, size_type n, const T& x)
list::insert	stl_list.h	/^void list<T, Alloc>::insert(iterator position,$/;"	f	class:list	signature:(iterator position, InputIterator first, InputIterator last)
list::insert	stl_list.h	/^void list<T, Alloc>::insert(iterator position,$/;"	f	class:list	signature:(iterator position, const_iterator first, const_iterator last)
list::iterator	stl_list.h	/^  typedef __list_iterator<T, T&, T*>             iterator;$/;"	t	class:list	access:public
list::link_type	stl_list.h	/^  typedef list_node* link_type;$/;"	t	class:list	access:public
list::list	stl_list.h	/^  explicit list(size_type n) { fill_initialize(n, T()); }$/;"	f	class:list	access:public	signature:(size_type n)
list::list	stl_list.h	/^  list() { empty_initialize(); }$/;"	f	class:list	access:public	signature:()
list::list	stl_list.h	/^  list(InputIterator first, InputIterator last) {$/;"	f	class:list	access:public	signature:(InputIterator first, InputIterator last)
list::list	stl_list.h	/^  list(const T* first, const T* last) { range_initialize(first, last); }$/;"	f	class:list	access:public	signature:(const T* first, const T* last)
list::list	stl_list.h	/^  list(const list<T, Alloc>& x) {$/;"	f	class:list	access:public	signature:(const list<T, Alloc>& x)
list::list	stl_list.h	/^  list(const_iterator first, const_iterator last) {$/;"	f	class:list	access:public	signature:(const_iterator first, const_iterator last)
list::list	stl_list.h	/^  list(int n, const T& value) { fill_initialize(n, value); }$/;"	f	class:list	access:public	signature:(int n, const T& value)
list::list	stl_list.h	/^  list(long n, const T& value) { fill_initialize(n, value); }$/;"	f	class:list	access:public	signature:(long n, const T& value)
list::list	stl_list.h	/^  list(size_type n, const T& value) { fill_initialize(n, value); }$/;"	f	class:list	access:public	signature:(size_type n, const T& value)
list::list_node	stl_list.h	/^  typedef __list_node<T> list_node;$/;"	t	class:list	access:protected
list::list_node_allocator	stl_list.h	/^  typedef simple_alloc<list_node, Alloc> list_node_allocator;$/;"	t	class:list	access:protected
list::max_size	stl_list.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:list	access:public	signature:() const
list::merge	stl_list.h	/^  template <class StrictWeakOrdering> void merge(list&, StrictWeakOrdering);$/;"	p	class:list	access:public	signature:(list&, StrictWeakOrdering)
list::merge	stl_list.h	/^  void merge(list& x);$/;"	p	class:list	access:public	signature:(list& x)
list::merge	stl_list.h	/^void list<T, Alloc>::merge(list<T, Alloc>& x) {$/;"	f	class:list	signature:(list<T, Alloc>& x)
list::merge	stl_list.h	/^void list<T, Alloc>::merge(list<T, Alloc>& x, StrictWeakOrdering comp) {$/;"	f	class:list	signature:(list<T, Alloc>& x, StrictWeakOrdering comp)
list::node	stl_list.h	/^  link_type node;$/;"	m	class:list	access:protected
list::operator =	stl_list.h	/^  list<T, Alloc>& operator=(const list<T, Alloc>& x);$/;"	p	class:list	access:public	signature:(const list<T, Alloc>& x)
list::operator =	stl_list.h	/^list<T, Alloc>& list<T, Alloc>::operator=(const list<T, Alloc>& x) {$/;"	f	class:list	signature:(const list<T, Alloc>& x)
list::pointer	stl_list.h	/^  typedef value_type* pointer;$/;"	t	class:list	access:public
list::pop_back	stl_list.h	/^  void pop_back() { $/;"	f	class:list	access:public	signature:()
list::pop_front	stl_list.h	/^  void pop_front() { erase(begin()); }$/;"	f	class:list	access:public	signature:()
list::push_back	stl_list.h	/^  void push_back(const T& x) { insert(end(), x); }$/;"	f	class:list	access:public	signature:(const T& x)
list::push_front	stl_list.h	/^  void push_front(const T& x) { insert(begin(), x); }$/;"	f	class:list	access:public	signature:(const T& x)
list::put_node	stl_list.h	/^  void put_node(link_type p) { list_node_allocator::deallocate(p); }$/;"	f	class:list	access:protected	signature:(link_type p)
list::range_initialize	stl_list.h	/^  void range_initialize(InputIterator first, InputIterator last) {$/;"	f	class:list	access:protected	signature:(InputIterator first, InputIterator last)
list::range_initialize	stl_list.h	/^  void range_initialize(const T* first, const T* last) {$/;"	f	class:list	access:protected	signature:(const T* first, const T* last)
list::range_initialize	stl_list.h	/^  void range_initialize(const_iterator first, const_iterator last) {$/;"	f	class:list	access:protected	signature:(const_iterator first, const_iterator last)
list::rbegin	stl_list.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:list	access:public	signature:() const
list::rbegin	stl_list.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:list	access:public	signature:()
list::reference	stl_list.h	/^  typedef value_type& reference;$/;"	t	class:list	access:public
list::remove	stl_list.h	/^  void remove(const T& value);$/;"	p	class:list	access:public	signature:(const T& value)
list::remove	stl_list.h	/^void list<T, Alloc>::remove(const T& value) {$/;"	f	class:list	signature:(const T& value)
list::remove_if	stl_list.h	/^  template <class Predicate> void remove_if(Predicate);$/;"	p	class:list	access:public	signature:(Predicate)
list::remove_if	stl_list.h	/^void list<T, Alloc>::remove_if(Predicate pred) {$/;"	f	class:list	signature:(Predicate pred)
list::rend	stl_list.h	/^  const_reverse_iterator rend() const { $/;"	f	class:list	access:public	signature:() const
list::rend	stl_list.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:list	access:public	signature:()
list::resize	stl_list.h	/^  void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:list	access:public	signature:(size_type new_size)
list::resize	stl_list.h	/^  void resize(size_type new_size, const T& x);$/;"	p	class:list	access:public	signature:(size_type new_size, const T& x)
list::resize	stl_list.h	/^void list<T, Alloc>::resize(size_type new_size, const T& x)$/;"	f	class:list	signature:(size_type new_size, const T& x)
list::reverse	stl_list.h	/^  void reverse();$/;"	p	class:list	access:public	signature:()
list::reverse	stl_list.h	/^void list<T, Alloc>::reverse() {$/;"	f	class:list	signature:()
list::reverse_iterator	stl_list.h	/^  reverse_iterator; $/;"	t	class:list	access:public
list::reverse_iterator	stl_list.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:list	access:public
list::size	stl_list.h	/^  size_type size() const {$/;"	f	class:list	access:public	signature:() const
list::size_type	stl_list.h	/^  typedef size_t size_type;$/;"	t	class:list	access:public
list::sort	stl_list.h	/^  template <class StrictWeakOrdering> void sort(StrictWeakOrdering);$/;"	p	class:list	access:public	signature:(StrictWeakOrdering)
list::sort	stl_list.h	/^  void sort();$/;"	p	class:list	access:public	signature:()
list::sort	stl_list.h	/^void list<T, Alloc>::sort() {$/;"	f	class:list	signature:()
list::sort	stl_list.h	/^void list<T, Alloc>::sort(StrictWeakOrdering comp) {$/;"	f	class:list	signature:(StrictWeakOrdering comp)
list::splice	stl_list.h	/^  void splice(iterator position, list& x) {$/;"	f	class:list	access:public	signature:(iterator position, list& x)
list::splice	stl_list.h	/^  void splice(iterator position, list&, iterator first, iterator last) {$/;"	f	class:list	access:public	signature:(iterator position, list&, iterator first, iterator last)
list::splice	stl_list.h	/^  void splice(iterator position, list&, iterator i) {$/;"	f	class:list	access:public	signature:(iterator position, list&, iterator i)
list::swap	stl_list.h	/^  void swap(list<T, Alloc>& x) { __STD::swap(node, x.node); }$/;"	f	class:list	access:public	signature:(list<T, Alloc>& x)
list::transfer	stl_list.h	/^  void transfer(iterator position, iterator first, iterator last) {$/;"	f	class:list	access:protected	signature:(iterator position, iterator first, iterator last)
list::unique	stl_list.h	/^  template <class BinaryPredicate> void unique(BinaryPredicate);$/;"	p	class:list	access:public	signature:(BinaryPredicate)
list::unique	stl_list.h	/^  void unique();$/;"	p	class:list	access:public	signature:()
list::unique	stl_list.h	/^void list<T, Alloc>::unique() {$/;"	f	class:list	signature:()
list::unique	stl_list.h	/^void list<T, Alloc>::unique(BinaryPredicate binary_pred) {$/;"	f	class:list	signature:(BinaryPredicate binary_pred)
list::value_type	stl_list.h	/^  typedef T value_type;$/;"	t	class:list	access:public
list::void_pointer	stl_list.h	/^  typedef void* void_pointer;$/;"	t	class:list	access:protected
list::~list	stl_list.h	/^  ~list() {$/;"	f	class:list	access:public	signature:()
list_node	stl_list.h	/^  typedef __list_node<T> list_node;$/;"	t	class:list	access:protected
list_node	stl_slist.h	/^  typedef __slist_node<T> list_node;$/;"	t	class:slist	access:private
list_node	stl_slist.h	/^  typedef __slist_node<T> list_node;$/;"	t	struct:__slist_iterator	access:public
list_node_allocator	stl_list.h	/^  typedef simple_alloc<list_node, Alloc> list_node_allocator;$/;"	t	class:list	access:protected
list_node_allocator	stl_slist.h	/^  typedef simple_alloc<list_node, Alloc> list_node_allocator;$/;"	t	class:slist	access:private
list_node_base	stl_slist.h	/^  typedef __slist_node_base list_node_base;$/;"	t	class:slist	access:private
lock	stl_alloc.h	/^            lock() { __NODE_ALLOCATOR_LOCK; }$/;"	f	class:__default_alloc_template::lock	access:public	signature:()
lock	stl_alloc.h	/^    class lock {$/;"	c	class:__default_alloc_template	access:private
logical_and	stl_function.h	/^struct logical_and : public binary_function<T, T, bool> {$/;"	s	inherits:binary_function
logical_and::operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x && y; }$/;"	f	struct:logical_and	access:public	signature:(const T& x, const T& y) const
logical_not	stl_function.h	/^struct logical_not : public unary_function<T, bool> {$/;"	s	inherits:unary_function
logical_not::operator ()	stl_function.h	/^    bool operator()(const T& x) const { return !x; }$/;"	f	struct:logical_not	access:public	signature:(const T& x) const
logical_or	stl_function.h	/^struct logical_or : public binary_function<T, T, bool> {$/;"	s	inherits:binary_function
logical_or::operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x || y; }$/;"	f	struct:logical_or	access:public	signature:(const T& x, const T& y) const
lower_bound	stl_algo.h	/^inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value)
lower_bound	stl_algo.h	/^inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value, Compare comp)
lower_bound	stl_map.h	/^  const_iterator lower_bound(const key_type& x) const {$/;"	f	class:map	access:public	signature:(const key_type& x) const
lower_bound	stl_map.h	/^  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }$/;"	f	class:map	access:public	signature:(const key_type& x)
lower_bound	stl_multimap.h	/^  const_iterator lower_bound(const key_type& x) const {$/;"	f	class:multimap	access:public	signature:(const key_type& x) const
lower_bound	stl_multimap.h	/^  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }$/;"	f	class:multimap	access:public	signature:(const key_type& x)
lower_bound	stl_multiset.h	/^  iterator lower_bound(const key_type& x) const {$/;"	f	class:multiset	access:public	signature:(const key_type& x) const
lower_bound	stl_set.h	/^  iterator lower_bound(const key_type& x) const {$/;"	f	class:set	access:public	signature:(const key_type& x) const
lower_bound	stl_tree.h	/^  const_iterator lower_bound(const key_type& x) const;$/;"	p	class:rb_tree	access:public	signature:(const key_type& x) const
lower_bound	stl_tree.h	/^  iterator lower_bound(const key_type& x);$/;"	p	class:rb_tree	access:public	signature:(const key_type& x)
lower_bound	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) const {$/;"	f	class:rb_tree	signature:(const Key& k) const
lower_bound	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) {$/;"	f	class:rb_tree	signature:(const Key& k)
make_heap	stl_heap.h	/^inline void make_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last)
make_heap	stl_heap.h	/^inline void make_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
make_pair	stl_pair.h	/^inline pair<T1, T2> make_pair(const T1& x, const T2& y) {$/;"	f	signature:(const T1& x, const T2& y)
malloc_alloc	stl_alloc.h	/^typedef __malloc_alloc_template<0> malloc_alloc;$/;"	t
map	stl_deque.h	/^  map_pointer map;$/;"	m	class:__deque_iterator::deque	access:protected
map	stl_map.h	/^  explicit map(const Compare& comp) : t(comp) {}$/;"	f	class:map	access:public	signature:(const Compare& comp)
map	stl_map.h	/^  map() : t(Compare()) {}$/;"	f	class:map	access:public	signature:()
map	stl_map.h	/^  map(InputIterator first, InputIterator last)$/;"	f	class:map	access:public	signature:(InputIterator first, InputIterator last)
map	stl_map.h	/^  map(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:map	access:public	signature:(InputIterator first, InputIterator last, const Compare& comp)
map	stl_map.h	/^  map(const map<Key, T, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:map	access:public	signature:(const map<Key, T, Compare, Alloc>& x)
map	stl_map.h	/^  map(const value_type* first, const value_type* last)$/;"	f	class:map	access:public	signature:(const value_type* first, const value_type* last)
map	stl_map.h	/^  map(const value_type* first, const value_type* last, const Compare& comp)$/;"	f	class:map	access:public	signature:(const value_type* first, const value_type* last, const Compare& comp)
map	stl_map.h	/^  map(const_iterator first, const_iterator last)$/;"	f	class:map	access:public	signature:(const_iterator first, const_iterator last)
map	stl_map.h	/^  map(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:map	access:public	signature:(const_iterator first, const_iterator last, const Compare& comp)
map	stl_map.h	/^class map {$/;"	c
map::__STL_NULL_TMPL_ARGS	stl_map.h	/^  friend bool operator< __STL_NULL_TMPL_ARGS (const map&, const map&);$/;"	p	class:map	access:friend	signature:(const map&, const map&)
map::__STL_NULL_TMPL_ARGS	stl_map.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const map&, const map&);$/;"	p	class:map	access:friend	signature:(const map&, const map&)
map::begin	stl_map.h	/^  const_iterator begin() const { return t.begin(); }$/;"	f	class:map	access:public	signature:() const
map::begin	stl_map.h	/^  iterator begin() { return t.begin(); }$/;"	f	class:map	access:public	signature:()
map::clear	stl_map.h	/^  void clear() { t.clear(); }$/;"	f	class:map	access:public	signature:()
map::const_iterator	stl_map.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:map	access:public
map::const_pointer	stl_map.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:map	access:public
map::const_reference	stl_map.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:map	access:public
map::const_reverse_iterator	stl_map.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:map	access:public
map::count	stl_map.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:map	access:public	signature:(const key_type& x) const
map::data_type	stl_map.h	/^  typedef T data_type;$/;"	t	class:map	access:public
map::difference_type	stl_map.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:map	access:public
map::empty	stl_map.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:map	access:public	signature:() const
map::end	stl_map.h	/^  const_iterator end() const { return t.end(); }$/;"	f	class:map	access:public	signature:() const
map::end	stl_map.h	/^  iterator end() { return t.end(); }$/;"	f	class:map	access:public	signature:()
map::equal_range	stl_map.h	/^  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {$/;"	f	class:map	access:public	signature:(const key_type& x) const
map::equal_range	stl_map.h	/^  pair<iterator,iterator> equal_range(const key_type& x) {$/;"	f	class:map	access:public	signature:(const key_type& x)
map::erase	stl_map.h	/^  size_type erase(const key_type& x) { return t.erase(x); }$/;"	f	class:map	access:public	signature:(const key_type& x)
map::erase	stl_map.h	/^  void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:map	access:public	signature:(iterator first, iterator last)
map::erase	stl_map.h	/^  void erase(iterator position) { t.erase(position); }$/;"	f	class:map	access:public	signature:(iterator position)
map::find	stl_map.h	/^  const_iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:map	access:public	signature:(const key_type& x) const
map::find	stl_map.h	/^  iterator find(const key_type& x) { return t.find(x); }$/;"	f	class:map	access:public	signature:(const key_type& x)
map::insert	stl_map.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:map	access:public	signature:(iterator position, const value_type& x)
map::insert	stl_map.h	/^  pair<iterator,bool> insert(const value_type& x) { return t.insert_unique(x); }$/;"	f	class:map	access:public	signature:(const value_type& x)
map::insert	stl_map.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:map	access:public	signature:(InputIterator first, InputIterator last)
map::insert	stl_map.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:map	access:public	signature:(const value_type* first, const value_type* last)
map::insert	stl_map.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:map	access:public	signature:(const_iterator first, const_iterator last)
map::iterator	stl_map.h	/^  typedef typename rep_type::iterator iterator;$/;"	t	class:map	access:public
map::key_comp	stl_map.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:map	access:public	signature:() const
map::key_compare	stl_map.h	/^  typedef Compare key_compare;$/;"	t	class:map	access:public
map::key_type	stl_map.h	/^  typedef Key key_type;$/;"	t	class:map	access:public
map::lower_bound	stl_map.h	/^  const_iterator lower_bound(const key_type& x) const {$/;"	f	class:map	access:public	signature:(const key_type& x) const
map::lower_bound	stl_map.h	/^  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }$/;"	f	class:map	access:public	signature:(const key_type& x)
map::map	stl_map.h	/^  explicit map(const Compare& comp) : t(comp) {}$/;"	f	class:map	access:public	signature:(const Compare& comp)
map::map	stl_map.h	/^  map() : t(Compare()) {}$/;"	f	class:map	access:public	signature:()
map::map	stl_map.h	/^  map(InputIterator first, InputIterator last)$/;"	f	class:map	access:public	signature:(InputIterator first, InputIterator last)
map::map	stl_map.h	/^  map(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:map	access:public	signature:(InputIterator first, InputIterator last, const Compare& comp)
map::map	stl_map.h	/^  map(const map<Key, T, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:map	access:public	signature:(const map<Key, T, Compare, Alloc>& x)
map::map	stl_map.h	/^  map(const value_type* first, const value_type* last)$/;"	f	class:map	access:public	signature:(const value_type* first, const value_type* last)
map::map	stl_map.h	/^  map(const value_type* first, const value_type* last, const Compare& comp)$/;"	f	class:map	access:public	signature:(const value_type* first, const value_type* last, const Compare& comp)
map::map	stl_map.h	/^  map(const_iterator first, const_iterator last)$/;"	f	class:map	access:public	signature:(const_iterator first, const_iterator last)
map::map	stl_map.h	/^  map(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:map	access:public	signature:(const_iterator first, const_iterator last, const Compare& comp)
map::mapped_type	stl_map.h	/^  typedef T mapped_type;$/;"	t	class:map	access:public
map::max_size	stl_map.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:map	access:public	signature:() const
map::operator =	stl_map.h	/^  map<Key, T, Compare, Alloc>& operator=(const map<Key, T, Compare, Alloc>& x)$/;"	f	class:map	access:public	signature:(const map<Key, T, Compare, Alloc>& x)
map::operator []	stl_map.h	/^  T& operator[](const key_type& k) {$/;"	f	class:map	access:public	signature:(const key_type& k)
map::pointer	stl_map.h	/^  typedef typename rep_type::pointer pointer;$/;"	t	class:map	access:public
map::rbegin	stl_map.h	/^  const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:map	access:public	signature:() const
map::rbegin	stl_map.h	/^  reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:map	access:public	signature:()
map::reference	stl_map.h	/^  typedef typename rep_type::reference reference;$/;"	t	class:map	access:public
map::rend	stl_map.h	/^  const_reverse_iterator rend() const { return t.rend(); }$/;"	f	class:map	access:public	signature:() const
map::rend	stl_map.h	/^  reverse_iterator rend() { return t.rend(); }$/;"	f	class:map	access:public	signature:()
map::rep_type	stl_map.h	/^                  select1st<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:map	access:private
map::reverse_iterator	stl_map.h	/^  typedef typename rep_type::reverse_iterator reverse_iterator;$/;"	t	class:map	access:public
map::size	stl_map.h	/^  size_type size() const { return t.size(); }$/;"	f	class:map	access:public	signature:() const
map::size_type	stl_map.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:map	access:public
map::swap	stl_map.h	/^  void swap(map<Key, T, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:map	access:public	signature:(map<Key, T, Compare, Alloc>& x)
map::t	stl_map.h	/^  rep_type t;  \/\/ red-black tree representing map$/;"	m	class:map	access:private
map::upper_bound	stl_map.h	/^  const_iterator upper_bound(const key_type& x) const {$/;"	f	class:map	access:public	signature:(const key_type& x) const
map::upper_bound	stl_map.h	/^  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }$/;"	f	class:map	access:public	signature:(const key_type& x)
map::value_comp	stl_map.h	/^  value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:map	access:public	signature:() const
map::value_compare	stl_map.h	/^  class value_compare$/;"	c	class:map	inherits:binary_function	access:public
map::value_compare::comp	stl_map.h	/^    Compare comp;$/;"	m	class:map::value_compare	access:protected
map::value_compare::operator ()	stl_map.h	/^    bool operator()(const value_type& x, const value_type& y) const {$/;"	f	class:map::value_compare	access:public	signature:(const value_type& x, const value_type& y) const
map::value_compare::value_compare	stl_map.h	/^    value_compare(Compare c) : comp(c) {}$/;"	f	class:map::value_compare	access:protected	signature:(Compare c)
map::value_type	stl_map.h	/^  typedef pair<const Key, T> value_type;$/;"	t	class:map	access:public
map_allocator	stl_deque.h	/^  typedef simple_alloc<pointer, Alloc> map_allocator;$/;"	t	class:__deque_iterator::deque	access:protected
map_pointer	stl_deque.h	/^  typedef T** map_pointer;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
map_pointer	stl_deque.h	/^  typedef pointer* map_pointer;$/;"	t	class:__deque_iterator::deque	access:protected
map_size	stl_deque.h	/^  size_type map_size;$/;"	m	class:__deque_iterator::deque	access:protected
mapped_type	stl_hash_map.h	/^  typedef T mapped_type;$/;"	t	class:hash_map	access:public
mapped_type	stl_hash_map.h	/^  typedef T mapped_type;$/;"	t	class:hash_multimap	access:public
mapped_type	stl_map.h	/^  typedef T mapped_type;$/;"	t	class:map	access:public
mapped_type	stl_multimap.h	/^  typedef T mapped_type;$/;"	t	class:multimap	access:public
mask	stl_bvector.h	/^  unsigned int mask;$/;"	m	struct:__bit_reference	access:public
max	stl_algobase.h	/^inline const T& max(const T& a, const T& b) {$/;"	f	signature:(const T& a, const T& b)
max	stl_algobase.h	/^inline const T& max(const T& a, const T& b, Compare comp) {$/;"	f	signature:(const T& a, const T& b, Compare comp)
max	stl_algobase.h	83;"	d
max_bucket_count	stl_hash_map.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_map	access:public	signature:() const
max_bucket_count	stl_hash_map.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_multimap	access:public	signature:() const
max_bucket_count	stl_hash_set.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_multiset	access:public	signature:() const
max_bucket_count	stl_hash_set.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_set	access:public	signature:() const
max_bucket_count	stl_hashtable.h	/^  size_type max_bucket_count() const$/;"	f	class:hashtable	access:public	signature:() const
max_element	stl_algo.h	/^ForwardIterator max_element(ForwardIterator first, ForwardIterator last) {$/;"	f	signature:(ForwardIterator first, ForwardIterator last)
max_element	stl_algo.h	/^ForwardIterator max_element(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, Compare comp)
max_rope_depth	stl_rope.h	/^    enum { max_rope_depth = 45 };$/;"	e	enum:__rope_RopeBase::__anon8
max_size	defalloc.h	/^    size_type max_size() const { $/;"	f	class:allocator	access:public	signature:() const
max_size	stl_bvector.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:vector	access:public	signature:() const
max_size	stl_deque.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
max_size	stl_hash_map.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_map	access:public	signature:() const
max_size	stl_hash_map.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_multimap	access:public	signature:() const
max_size	stl_hash_set.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_multiset	access:public	signature:() const
max_size	stl_hash_set.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_set	access:public	signature:() const
max_size	stl_hashtable.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:hashtable	access:public	signature:() const
max_size	stl_list.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:list	access:public	signature:() const
max_size	stl_map.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:map	access:public	signature:() const
max_size	stl_multimap.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:multimap	access:public	signature:() const
max_size	stl_multiset.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:multiset	access:public	signature:() const
max_size	stl_rope.h	/^	size_type max_size() const {$/;"	f	class:rope	access:public	signature:() const
max_size	stl_set.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:set	access:public	signature:() const
max_size	stl_slist.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:slist	access:public	signature:() const
max_size	stl_tree.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:rb_tree	access:public	signature:() const
max_size	stl_vector.h	/^  size_type max_size() const { return size_type(-1) \/ sizeof(T); }$/;"	f	class:vector	access:public	signature:() const
maximum	stl_tree.h	/^  static base_ptr maximum(base_ptr x)$/;"	f	struct:__rb_tree_node_base	access:public	signature:(base_ptr x)
maximum	stl_tree.h	/^  static link_type maximum(link_type x) {$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
mem_fun1_ref_t	stl_function.h	/^  explicit mem_fun1_ref_t(void (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_ref_t	access:public	signature:(void (T::*pf)(A))
mem_fun1_ref_t	stl_function.h	/^class mem_fun1_ref_t : public binary_function<T, A, S> {$/;"	c	inherits:binary_function
mem_fun1_ref_t	stl_function.h	/^class mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {$/;"	c	inherits:binary_function
mem_fun1_ref_t::S	stl_function.h	/^  explicit mem_fun1_ref_t(S (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_ref_t	access:public	signature:(T::*pf)
mem_fun1_ref_t::f	stl_function.h	/^  S (T::*f)(A);$/;"	m	class:mem_fun1_ref_t	access:private
mem_fun1_ref_t::f	stl_function.h	/^  void (T::*f)(A);$/;"	m	class:mem_fun1_ref_t	access:private
mem_fun1_ref_t::mem_fun1_ref_t	stl_function.h	/^  explicit mem_fun1_ref_t(void (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_ref_t	access:public	signature:(void (T::*pf)(A))
mem_fun1_ref_t::operator ()	stl_function.h	/^  S operator()(T& r, A x) const { return (r.*f)(x); }$/;"	f	class:mem_fun1_ref_t	access:public	signature:(T& r, A x) const
mem_fun1_ref_t::operator ()	stl_function.h	/^  void operator()(T& r, A x) const { (r.*f)(x); }$/;"	f	class:mem_fun1_ref_t	access:public	signature:(T& r, A x) const
mem_fun1_t	stl_function.h	/^  explicit mem_fun1_t(void (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_t	access:public	signature:(void (T::*pf)(A))
mem_fun1_t	stl_function.h	/^class mem_fun1_t : public binary_function<T*, A, S> {$/;"	c	inherits:binary_function
mem_fun1_t	stl_function.h	/^class mem_fun1_t<void, T, A> : public binary_function<T*, A, void> {$/;"	c	inherits:binary_function
mem_fun1_t::S	stl_function.h	/^  explicit mem_fun1_t(S (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_t	access:public	signature:(T::*pf)
mem_fun1_t::f	stl_function.h	/^  S (T::*f)(A);$/;"	m	class:mem_fun1_t	access:private
mem_fun1_t::f	stl_function.h	/^  void (T::*f)(A);$/;"	m	class:mem_fun1_t	access:private
mem_fun1_t::mem_fun1_t	stl_function.h	/^  explicit mem_fun1_t(void (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_t	access:public	signature:(void (T::*pf)(A))
mem_fun1_t::operator ()	stl_function.h	/^  S operator()(T* p, A x) const { return (p->*f)(x); }$/;"	f	class:mem_fun1_t	access:public	signature:(T* p, A x) const
mem_fun1_t::operator ()	stl_function.h	/^  void operator()(T* p, A x) const { (p->*f)(x); }$/;"	f	class:mem_fun1_t	access:public	signature:(T* p, A x) const
mem_fun_ref_t	stl_function.h	/^  explicit mem_fun_ref_t(void (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_ref_t	access:public	signature:(void (T::*pf)())
mem_fun_ref_t	stl_function.h	/^class mem_fun_ref_t : public unary_function<T, S> {$/;"	c	inherits:unary_function
mem_fun_ref_t	stl_function.h	/^class mem_fun_ref_t<void, T> : public unary_function<T, void> {$/;"	c	inherits:unary_function
mem_fun_ref_t::S	stl_function.h	/^  explicit mem_fun_ref_t(S (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_ref_t	access:public	signature:(T::*pf)
mem_fun_ref_t::f	stl_function.h	/^  S (T::*f)();$/;"	m	class:mem_fun_ref_t	access:private
mem_fun_ref_t::f	stl_function.h	/^  void (T::*f)();$/;"	m	class:mem_fun_ref_t	access:private
mem_fun_ref_t::mem_fun_ref_t	stl_function.h	/^  explicit mem_fun_ref_t(void (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_ref_t	access:public	signature:(void (T::*pf)())
mem_fun_ref_t::operator ()	stl_function.h	/^  S operator()(T& r) const { return (r.*f)(); }$/;"	f	class:mem_fun_ref_t	access:public	signature:(T& r) const
mem_fun_ref_t::operator ()	stl_function.h	/^  void operator()(T& r) const { (r.*f)(); }$/;"	f	class:mem_fun_ref_t	access:public	signature:(T& r) const
mem_fun_t	stl_function.h	/^  explicit mem_fun_t(void (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_t	access:public	signature:(void (T::*pf)())
mem_fun_t	stl_function.h	/^class mem_fun_t : public unary_function<T*, S> {$/;"	c	inherits:unary_function
mem_fun_t	stl_function.h	/^class mem_fun_t<void, T> : public unary_function<T*, void> {$/;"	c	inherits:unary_function
mem_fun_t::S	stl_function.h	/^  explicit mem_fun_t(S (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_t	access:public	signature:(T::*pf)
mem_fun_t::f	stl_function.h	/^  S (T::*f)();$/;"	m	class:mem_fun_t	access:private
mem_fun_t::f	stl_function.h	/^  void (T::*f)();$/;"	m	class:mem_fun_t	access:private
mem_fun_t::mem_fun_t	stl_function.h	/^  explicit mem_fun_t(void (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_t	access:public	signature:(void (T::*pf)())
mem_fun_t::operator ()	stl_function.h	/^  S operator()(T* p) const { return (p->*f)(); }$/;"	f	class:mem_fun_t	access:public	signature:(T* p) const
mem_fun_t::operator ()	stl_function.h	/^  void operator()(T* p) const { (p->*f)(); }$/;"	f	class:mem_fun_t	access:public	signature:(T* p) const
merge	stl_algo.h	/^OutputIterator merge(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)
merge	stl_algo.h	/^OutputIterator merge(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp)
merge	stl_list.h	/^  template <class StrictWeakOrdering> void merge(list&, StrictWeakOrdering);$/;"	p	class:list	access:public	signature:(list&, StrictWeakOrdering)
merge	stl_list.h	/^  void merge(list& x);$/;"	p	class:list	access:public	signature:(list& x)
merge	stl_list.h	/^void list<T, Alloc>::merge(list<T, Alloc>& x) {$/;"	f	class:list	signature:(list<T, Alloc>& x)
merge	stl_list.h	/^void list<T, Alloc>::merge(list<T, Alloc>& x, StrictWeakOrdering comp) {$/;"	f	class:list	signature:(list<T, Alloc>& x, StrictWeakOrdering comp)
merge	stl_slist.h	/^  template <class StrictWeakOrdering> void merge(slist&, StrictWeakOrdering); $/;"	p	class:slist	access:public	signature:(slist&, StrictWeakOrdering)
merge	stl_slist.h	/^  void merge(slist& L);$/;"	p	class:slist	access:public	signature:(slist& L)
merge	stl_slist.h	/^void slist<T,Alloc>::merge(slist<T,Alloc>& L)$/;"	f	class:slist	signature:(slist<T,Alloc>& L)
merge	stl_slist.h	/^void slist<T,Alloc>::merge(slist<T,Alloc>& L, StrictWeakOrdering comp)$/;"	f	class:slist	signature:(slist<T,Alloc>& L, StrictWeakOrdering comp)
min	stl_algobase.h	/^inline const T& min(const T& a, const T& b) {$/;"	f	signature:(const T& a, const T& b)
min	stl_algobase.h	/^inline const T& min(const T& a, const T& b, Compare comp) {$/;"	f	signature:(const T& a, const T& b, Compare comp)
min	stl_algobase.h	82;"	d
min_element	stl_algo.h	/^ForwardIterator min_element(ForwardIterator first, ForwardIterator last) {$/;"	f	signature:(ForwardIterator first, ForwardIterator last)
min_element	stl_algo.h	/^ForwardIterator min_element(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, Compare comp)
min_len	ropeimpl.h	/^rope<charT,Alloc>::min_len[__rope_RopeBase<charT,Alloc>::max_rope_depth + 1] = {$/;"	m	class:rope
min_len	stl_rope.h	/^	static const unsigned long min_len[RopeBase::max_rope_depth + 1];$/;"	m	class:rope	access:protected
minimum	stl_tree.h	/^  static base_ptr minimum(base_ptr x)$/;"	f	struct:__rb_tree_node_base	access:public	signature:(base_ptr x)
minimum	stl_tree.h	/^  static link_type minimum(link_type x) { $/;"	f	class:rb_tree	access:protected	signature:(link_type x)
minus	stl_function.h	/^struct minus : public binary_function<T, T, T> {$/;"	s	inherits:binary_function
minus::operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x - y; }$/;"	f	struct:minus	access:public	signature:(const T& x, const T& y) const
mismatch	stl_algobase.h	/^pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
mismatch	stl_algobase.h	/^pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred)
modulus	stl_function.h	/^struct modulus : public binary_function<T, T, T> {$/;"	s	inherits:binary_function
modulus::operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x % y; }$/;"	f	struct:modulus	access:public	signature:(const T& x, const T& y) const
multimap	stl_multimap.h	/^  explicit multimap(const Compare& comp) : t(comp) { }$/;"	f	class:multimap	access:public	signature:(const Compare& comp)
multimap	stl_multimap.h	/^  multimap() : t(Compare()) { }$/;"	f	class:multimap	access:public	signature:()
multimap	stl_multimap.h	/^  multimap(InputIterator first, InputIterator last)$/;"	f	class:multimap	access:public	signature:(InputIterator first, InputIterator last)
multimap	stl_multimap.h	/^  multimap(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:multimap	access:public	signature:(InputIterator first, InputIterator last, const Compare& comp)
multimap	stl_multimap.h	/^  multimap(const multimap<Key, T, Compare, Alloc>& x) : t(x.t) { }$/;"	f	class:multimap	access:public	signature:(const multimap<Key, T, Compare, Alloc>& x)
multimap	stl_multimap.h	/^  multimap(const value_type* first, const value_type* last)$/;"	f	class:multimap	access:public	signature:(const value_type* first, const value_type* last)
multimap	stl_multimap.h	/^  multimap(const value_type* first, const value_type* last,$/;"	f	class:multimap	access:public	signature:(const value_type* first, const value_type* last, const Compare& comp)
multimap	stl_multimap.h	/^  multimap(const_iterator first, const_iterator last)$/;"	f	class:multimap	access:public	signature:(const_iterator first, const_iterator last)
multimap	stl_multimap.h	/^  multimap(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:multimap	access:public	signature:(const_iterator first, const_iterator last, const Compare& comp)
multimap	stl_multimap.h	/^class multimap {$/;"	c
multimap::__STL_NULL_TMPL_ARGS	stl_multimap.h	/^  friend bool operator< __STL_NULL_TMPL_ARGS (const multimap&,$/;"	p	class:multimap	access:friend	signature:(const multimap&, const multimap&)
multimap::__STL_NULL_TMPL_ARGS	stl_multimap.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const multimap&,$/;"	p	class:multimap	access:friend	signature:(const multimap&, const multimap&)
multimap::begin	stl_multimap.h	/^  const_iterator begin() const { return t.begin(); }$/;"	f	class:multimap	access:public	signature:() const
multimap::begin	stl_multimap.h	/^  iterator begin() { return t.begin(); }$/;"	f	class:multimap	access:public	signature:()
multimap::clear	stl_multimap.h	/^  void clear() { t.clear(); }$/;"	f	class:multimap	access:public	signature:()
multimap::const_iterator	stl_multimap.h	/^  typedef typename rep_type::const_iterator const_iterator; $/;"	t	class:multimap	access:public
multimap::const_pointer	stl_multimap.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:multimap	access:public
multimap::const_reference	stl_multimap.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:multimap	access:public
multimap::const_reverse_iterator	stl_multimap.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:multimap	access:public
multimap::count	stl_multimap.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:multimap	access:public	signature:(const key_type& x) const
multimap::data_type	stl_multimap.h	/^  typedef T data_type;$/;"	t	class:multimap	access:public
multimap::difference_type	stl_multimap.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:multimap	access:public
multimap::empty	stl_multimap.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:multimap	access:public	signature:() const
multimap::end	stl_multimap.h	/^  const_iterator end() const { return t.end(); }$/;"	f	class:multimap	access:public	signature:() const
multimap::end	stl_multimap.h	/^  iterator end() { return t.end(); }$/;"	f	class:multimap	access:public	signature:()
multimap::equal_range	stl_multimap.h	/^   pair<iterator,iterator> equal_range(const key_type& x) {$/;"	f	class:multimap	access:public	signature:(const key_type& x)
multimap::equal_range	stl_multimap.h	/^  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {$/;"	f	class:multimap	access:public	signature:(const key_type& x) const
multimap::erase	stl_multimap.h	/^  size_type erase(const key_type& x) { return t.erase(x); }$/;"	f	class:multimap	access:public	signature:(const key_type& x)
multimap::erase	stl_multimap.h	/^  void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:multimap	access:public	signature:(iterator first, iterator last)
multimap::erase	stl_multimap.h	/^  void erase(iterator position) { t.erase(position); }$/;"	f	class:multimap	access:public	signature:(iterator position)
multimap::find	stl_multimap.h	/^  const_iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:multimap	access:public	signature:(const key_type& x) const
multimap::find	stl_multimap.h	/^  iterator find(const key_type& x) { return t.find(x); }$/;"	f	class:multimap	access:public	signature:(const key_type& x)
multimap::insert	stl_multimap.h	/^  iterator insert(const value_type& x) { return t.insert_equal(x); }$/;"	f	class:multimap	access:public	signature:(const value_type& x)
multimap::insert	stl_multimap.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:multimap	access:public	signature:(iterator position, const value_type& x)
multimap::insert	stl_multimap.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:multimap	access:public	signature:(InputIterator first, InputIterator last)
multimap::insert	stl_multimap.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:multimap	access:public	signature:(const value_type* first, const value_type* last)
multimap::insert	stl_multimap.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:multimap	access:public	signature:(const_iterator first, const_iterator last)
multimap::iterator	stl_multimap.h	/^  typedef typename rep_type::iterator iterator;$/;"	t	class:multimap	access:public
multimap::key_comp	stl_multimap.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:multimap	access:public	signature:() const
multimap::key_compare	stl_multimap.h	/^  typedef Compare key_compare;$/;"	t	class:multimap	access:public
multimap::key_type	stl_multimap.h	/^  typedef Key key_type;$/;"	t	class:multimap	access:public
multimap::lower_bound	stl_multimap.h	/^  const_iterator lower_bound(const key_type& x) const {$/;"	f	class:multimap	access:public	signature:(const key_type& x) const
multimap::lower_bound	stl_multimap.h	/^  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }$/;"	f	class:multimap	access:public	signature:(const key_type& x)
multimap::mapped_type	stl_multimap.h	/^  typedef T mapped_type;$/;"	t	class:multimap	access:public
multimap::max_size	stl_multimap.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:multimap	access:public	signature:() const
multimap::multimap	stl_multimap.h	/^  explicit multimap(const Compare& comp) : t(comp) { }$/;"	f	class:multimap	access:public	signature:(const Compare& comp)
multimap::multimap	stl_multimap.h	/^  multimap() : t(Compare()) { }$/;"	f	class:multimap	access:public	signature:()
multimap::multimap	stl_multimap.h	/^  multimap(InputIterator first, InputIterator last)$/;"	f	class:multimap	access:public	signature:(InputIterator first, InputIterator last)
multimap::multimap	stl_multimap.h	/^  multimap(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:multimap	access:public	signature:(InputIterator first, InputIterator last, const Compare& comp)
multimap::multimap	stl_multimap.h	/^  multimap(const multimap<Key, T, Compare, Alloc>& x) : t(x.t) { }$/;"	f	class:multimap	access:public	signature:(const multimap<Key, T, Compare, Alloc>& x)
multimap::multimap	stl_multimap.h	/^  multimap(const value_type* first, const value_type* last)$/;"	f	class:multimap	access:public	signature:(const value_type* first, const value_type* last)
multimap::multimap	stl_multimap.h	/^  multimap(const value_type* first, const value_type* last,$/;"	f	class:multimap	access:public	signature:(const value_type* first, const value_type* last, const Compare& comp)
multimap::multimap	stl_multimap.h	/^  multimap(const_iterator first, const_iterator last)$/;"	f	class:multimap	access:public	signature:(const_iterator first, const_iterator last)
multimap::multimap	stl_multimap.h	/^  multimap(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:multimap	access:public	signature:(const_iterator first, const_iterator last, const Compare& comp)
multimap::operator =	stl_multimap.h	/^  operator=(const multimap<Key, T, Compare, Alloc>& x) {$/;"	f	class:multimap	access:public	signature:(const multimap<Key, T, Compare, Alloc>& x)
multimap::pointer	stl_multimap.h	/^  typedef typename rep_type::pointer pointer;$/;"	t	class:multimap	access:public
multimap::rbegin	stl_multimap.h	/^  const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:multimap	access:public	signature:() const
multimap::rbegin	stl_multimap.h	/^  reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:multimap	access:public	signature:()
multimap::reference	stl_multimap.h	/^  typedef typename rep_type::reference reference;$/;"	t	class:multimap	access:public
multimap::rend	stl_multimap.h	/^  const_reverse_iterator rend() const { return t.rend(); }$/;"	f	class:multimap	access:public	signature:() const
multimap::rend	stl_multimap.h	/^  reverse_iterator rend() { return t.rend(); }$/;"	f	class:multimap	access:public	signature:()
multimap::rep_type	stl_multimap.h	/^                  select1st<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:multimap	access:private
multimap::reverse_iterator	stl_multimap.h	/^  typedef typename rep_type::reverse_iterator reverse_iterator;$/;"	t	class:multimap	access:public
multimap::size	stl_multimap.h	/^  size_type size() const { return t.size(); }$/;"	f	class:multimap	access:public	signature:() const
multimap::size_type	stl_multimap.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:multimap	access:public
multimap::swap	stl_multimap.h	/^  void swap(multimap<Key, T, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:multimap	access:public	signature:(multimap<Key, T, Compare, Alloc>& x)
multimap::t	stl_multimap.h	/^  rep_type t;  \/\/ red-black tree representing multimap$/;"	m	class:multimap	access:private
multimap::upper_bound	stl_multimap.h	/^  const_iterator upper_bound(const key_type& x) const {$/;"	f	class:multimap	access:public	signature:(const key_type& x) const
multimap::upper_bound	stl_multimap.h	/^  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }$/;"	f	class:multimap	access:public	signature:(const key_type& x)
multimap::value_comp	stl_multimap.h	/^  value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:multimap	access:public	signature:() const
multimap::value_compare	stl_multimap.h	/^  class value_compare : public binary_function<value_type, value_type, bool> {$/;"	c	class:multimap	inherits:binary_function	access:public
multimap::value_compare::comp	stl_multimap.h	/^    Compare comp;$/;"	m	class:multimap::value_compare	access:protected
multimap::value_compare::operator ()	stl_multimap.h	/^    bool operator()(const value_type& x, const value_type& y) const {$/;"	f	class:multimap::value_compare	access:public	signature:(const value_type& x, const value_type& y) const
multimap::value_compare::value_compare	stl_multimap.h	/^    value_compare(Compare c) : comp(c) {}$/;"	f	class:multimap::value_compare	access:protected	signature:(Compare c)
multimap::value_type	stl_multimap.h	/^  typedef pair<const Key, T> value_type;$/;"	t	class:multimap	access:public
multiplies	stl_function.h	/^struct multiplies : public binary_function<T, T, T> {$/;"	s	inherits:binary_function
multiplies::operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x * y; }$/;"	f	struct:multiplies	access:public	signature:(const T& x, const T& y) const
multiset	stl_multiset.h	/^  explicit multiset(const Compare& comp) : t(comp) {}$/;"	f	class:multiset	access:public	signature:(const Compare& comp)
multiset	stl_multiset.h	/^  multiset() : t(Compare()) {}$/;"	f	class:multiset	access:public	signature:()
multiset	stl_multiset.h	/^  multiset(InputIterator first, InputIterator last)$/;"	f	class:multiset	access:public	signature:(InputIterator first, InputIterator last)
multiset	stl_multiset.h	/^  multiset(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:multiset	access:public	signature:(InputIterator first, InputIterator last, const Compare& comp)
multiset	stl_multiset.h	/^  multiset(const multiset<Key, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:multiset	access:public	signature:(const multiset<Key, Compare, Alloc>& x)
multiset	stl_multiset.h	/^  multiset(const value_type* first, const value_type* last)$/;"	f	class:multiset	access:public	signature:(const value_type* first, const value_type* last)
multiset	stl_multiset.h	/^  multiset(const value_type* first, const value_type* last,$/;"	f	class:multiset	access:public	signature:(const value_type* first, const value_type* last, const Compare& comp)
multiset	stl_multiset.h	/^  multiset(const_iterator first, const_iterator last)$/;"	f	class:multiset	access:public	signature:(const_iterator first, const_iterator last)
multiset	stl_multiset.h	/^  multiset(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:multiset	access:public	signature:(const_iterator first, const_iterator last, const Compare& comp)
multiset	stl_multiset.h	/^class multiset {$/;"	c
multiset::__STL_NULL_TMPL_ARGS	stl_multiset.h	/^  friend bool operator< __STL_NULL_TMPL_ARGS (const multiset&,$/;"	p	class:multiset	access:friend	signature:(const multiset&, const multiset&)
multiset::__STL_NULL_TMPL_ARGS	stl_multiset.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const multiset&,$/;"	p	class:multiset	access:friend	signature:(const multiset&, const multiset&)
multiset::begin	stl_multiset.h	/^  iterator begin() const { return t.begin(); }$/;"	f	class:multiset	access:public	signature:() const
multiset::clear	stl_multiset.h	/^  void clear() { t.clear(); }$/;"	f	class:multiset	access:public	signature:()
multiset::const_iterator	stl_multiset.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:multiset	access:public
multiset::const_pointer	stl_multiset.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:multiset	access:public
multiset::const_reference	stl_multiset.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:multiset	access:public
multiset::const_reverse_iterator	stl_multiset.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:multiset	access:public
multiset::count	stl_multiset.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:multiset	access:public	signature:(const key_type& x) const
multiset::difference_type	stl_multiset.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:multiset	access:public
multiset::empty	stl_multiset.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:multiset	access:public	signature:() const
multiset::end	stl_multiset.h	/^  iterator end() const { return t.end(); }$/;"	f	class:multiset	access:public	signature:() const
multiset::equal_range	stl_multiset.h	/^  pair<iterator,iterator> equal_range(const key_type& x) const {$/;"	f	class:multiset	access:public	signature:(const key_type& x) const
multiset::erase	stl_multiset.h	/^  size_type erase(const key_type& x) { $/;"	f	class:multiset	access:public	signature:(const key_type& x)
multiset::erase	stl_multiset.h	/^  void erase(iterator first, iterator last) { $/;"	f	class:multiset	access:public	signature:(iterator first, iterator last)
multiset::erase	stl_multiset.h	/^  void erase(iterator position) { $/;"	f	class:multiset	access:public	signature:(iterator position)
multiset::find	stl_multiset.h	/^  iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:multiset	access:public	signature:(const key_type& x) const
multiset::insert	stl_multiset.h	/^  iterator insert(const value_type& x) { $/;"	f	class:multiset	access:public	signature:(const value_type& x)
multiset::insert	stl_multiset.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:multiset	access:public	signature:(iterator position, const value_type& x)
multiset::insert	stl_multiset.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:multiset	access:public	signature:(InputIterator first, InputIterator last)
multiset::insert	stl_multiset.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:multiset	access:public	signature:(const value_type* first, const value_type* last)
multiset::insert	stl_multiset.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:multiset	access:public	signature:(const_iterator first, const_iterator last)
multiset::iterator	stl_multiset.h	/^  typedef typename rep_type::const_iterator iterator;$/;"	t	class:multiset	access:public
multiset::key_comp	stl_multiset.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:multiset	access:public	signature:() const
multiset::key_compare	stl_multiset.h	/^  typedef Compare key_compare;$/;"	t	class:multiset	access:public
multiset::key_type	stl_multiset.h	/^  typedef Key key_type;$/;"	t	class:multiset	access:public
multiset::lower_bound	stl_multiset.h	/^  iterator lower_bound(const key_type& x) const {$/;"	f	class:multiset	access:public	signature:(const key_type& x) const
multiset::max_size	stl_multiset.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:multiset	access:public	signature:() const
multiset::multiset	stl_multiset.h	/^  explicit multiset(const Compare& comp) : t(comp) {}$/;"	f	class:multiset	access:public	signature:(const Compare& comp)
multiset::multiset	stl_multiset.h	/^  multiset() : t(Compare()) {}$/;"	f	class:multiset	access:public	signature:()
multiset::multiset	stl_multiset.h	/^  multiset(InputIterator first, InputIterator last)$/;"	f	class:multiset	access:public	signature:(InputIterator first, InputIterator last)
multiset::multiset	stl_multiset.h	/^  multiset(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:multiset	access:public	signature:(InputIterator first, InputIterator last, const Compare& comp)
multiset::multiset	stl_multiset.h	/^  multiset(const multiset<Key, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:multiset	access:public	signature:(const multiset<Key, Compare, Alloc>& x)
multiset::multiset	stl_multiset.h	/^  multiset(const value_type* first, const value_type* last)$/;"	f	class:multiset	access:public	signature:(const value_type* first, const value_type* last)
multiset::multiset	stl_multiset.h	/^  multiset(const value_type* first, const value_type* last,$/;"	f	class:multiset	access:public	signature:(const value_type* first, const value_type* last, const Compare& comp)
multiset::multiset	stl_multiset.h	/^  multiset(const_iterator first, const_iterator last)$/;"	f	class:multiset	access:public	signature:(const_iterator first, const_iterator last)
multiset::multiset	stl_multiset.h	/^  multiset(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:multiset	access:public	signature:(const_iterator first, const_iterator last, const Compare& comp)
multiset::operator =	stl_multiset.h	/^  operator=(const multiset<Key, Compare, Alloc>& x) {$/;"	f	class:multiset	access:public	signature:(const multiset<Key, Compare, Alloc>& x)
multiset::pointer	stl_multiset.h	/^  typedef typename rep_type::const_pointer pointer;$/;"	t	class:multiset	access:public
multiset::rbegin	stl_multiset.h	/^  reverse_iterator rbegin() const { return t.rbegin(); } $/;"	f	class:multiset	access:public	signature:() const
multiset::reference	stl_multiset.h	/^  typedef typename rep_type::const_reference reference;$/;"	t	class:multiset	access:public
multiset::rend	stl_multiset.h	/^  reverse_iterator rend() const { return t.rend(); }$/;"	f	class:multiset	access:public	signature:() const
multiset::rep_type	stl_multiset.h	/^                  identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:multiset	access:private
multiset::reverse_iterator	stl_multiset.h	/^  typedef typename rep_type::const_reverse_iterator reverse_iterator;$/;"	t	class:multiset	access:public
multiset::size	stl_multiset.h	/^  size_type size() const { return t.size(); }$/;"	f	class:multiset	access:public	signature:() const
multiset::size_type	stl_multiset.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:multiset	access:public
multiset::swap	stl_multiset.h	/^  void swap(multiset<Key, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:multiset	access:public	signature:(multiset<Key, Compare, Alloc>& x)
multiset::t	stl_multiset.h	/^  rep_type t;  \/\/ red-black tree representing multiset$/;"	m	class:multiset	access:private
multiset::upper_bound	stl_multiset.h	/^  iterator upper_bound(const key_type& x) const {$/;"	f	class:multiset	access:public	signature:(const key_type& x) const
multiset::value_comp	stl_multiset.h	/^  value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:multiset	access:public	signature:() const
multiset::value_compare	stl_multiset.h	/^  typedef Compare value_compare;$/;"	t	class:multiset	access:public
multiset::value_type	stl_multiset.h	/^  typedef Key value_type;$/;"	t	class:multiset	access:public
mutable_begin	stl_rope.h	/^	iterator mutable_begin() {$/;"	f	class:rope	access:public	signature:()
mutable_end	stl_rope.h	/^	iterator mutable_end() {$/;"	f	class:rope	access:public	signature:()
mutable_rbegin	stl_rope.h	/^	reverse_iterator mutable_rbegin() {$/;"	f	class:rope	access:public	signature:()
mutable_reference_at	stl_rope.h	/^	reference mutable_reference_at(size_type pos) {$/;"	f	class:rope	access:public	signature:(size_type pos)
mutable_rend	stl_rope.h	/^	reverse_iterator mutable_rend() {$/;"	f	class:rope	access:public	signature:()
my_rope	stl_rope.h	/^    typedef rope<charT,Alloc> my_rope;$/;"	t	class:__rope_charT_ref_proxy	access:private
my_rope	stl_rope.h	/^    typedef rope<charT,Alloc> my_rope;$/;"	t	struct:__rope_RopeBase	access:public
negate	stl_function.h	/^struct negate : public unary_function<T, T> {$/;"	s	inherits:unary_function
negate::operator ()	stl_function.h	/^    T operator()(const T& x) const { return -x; }$/;"	f	struct:negate	access:public	signature:(const T& x) const
new_elements_at_back	stl_deque.h	/^  void new_elements_at_back(size_type new_elements);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(size_type new_elements)
new_elements_at_back	stl_deque.h	/^void deque<T, Alloc, BufSize>::new_elements_at_back(size_type new_elements) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type new_elements)
new_elements_at_front	stl_deque.h	/^  void new_elements_at_front(size_type new_elements);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(size_type new_elements)
new_elements_at_front	stl_deque.h	/^void deque<T, Alloc, BufSize>::new_elements_at_front(size_type new_elements) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type new_elements)
new_node	stl_hashtable.h	/^  node* new_node(const value_type& obj)$/;"	f	class:hashtable	access:private	signature:(const value_type& obj)
next	stl_hashtable.h	/^  __hashtable_node* next;$/;"	m	struct:__hashtable_node	access:public
next	stl_list.h	/^  void_pointer next;$/;"	m	struct:__list_node	access:public
next	stl_slist.h	/^  __slist_node_base* next;$/;"	m	struct:__slist_node_base	access:public
next_permutation	stl_algo.h	/^bool next_permutation(BidirectionalIterator first, BidirectionalIterator last,$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator last, Compare comp)
next_permutation	stl_algo.h	/^bool next_permutation(BidirectionalIterator first,$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator last)
next_size	stl_hashtable.h	/^  size_type next_size(size_type n) const { return __stl_next_prime(n); }$/;"	f	class:hashtable	access:private	signature:(size_type n) const
node	stl_deque.h	/^  map_pointer node;$/;"	m	struct:__deque_iterator::__deque_iterator	access:public
node	stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	class:hashtable	access:private
node	stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	struct:__hashtable_const_iterator	access:public
node	stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	struct:__hashtable_iterator	access:public
node	stl_list.h	/^  link_type node;$/;"	m	class:list	access:protected
node	stl_list.h	/^  link_type node;$/;"	m	struct:__list_iterator	access:public
node	stl_slist.h	/^  __slist_node_base* node;$/;"	m	struct:__slist_iterator_base	access:public
node	stl_tree.h	/^  base_ptr node;$/;"	m	struct:__rb_tree_base_iterator	access:public
node_allocator	stl_hashtable.h	/^  typedef simple_alloc<node, Alloc> node_allocator;$/;"	t	class:hashtable	access:private
node_count	stl_tree.h	/^  size_type node_count; \/\/ keeps track of size of tree$/;"	m	class:rb_tree	access:protected
not1	stl_function.h	/^inline unary_negate<Predicate> not1(const Predicate& pred) {$/;"	f	signature:(const Predicate& pred)
not2	stl_function.h	/^inline binary_negate<Predicate> not2(const Predicate& pred) {$/;"	f	signature:(const Predicate& pred)
not_equal_to	stl_function.h	/^struct not_equal_to : public binary_function<T, T, bool> {$/;"	s	inherits:binary_function
not_equal_to::operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x != y; }$/;"	f	struct:not_equal_to	access:public	signature:(const T& x, const T& y) const
nth_element	stl_algo.h	/^inline void nth_element(RandomAccessIterator first, RandomAccessIterator nth,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last)
nth_element	stl_algo.h	/^inline void nth_element(RandomAccessIterator first, RandomAccessIterator nth,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp)
num_elements	stl_hashtable.h	/^  size_type num_elements;$/;"	m	class:hashtable	access:private
o	ropeimpl.h	/^	insert_ostream & o;$/;"	m	class:__rope_insert_char_consumer	access:private
obj	stl_alloc.h	/^  union obj {$/;"	u	class:__default_alloc_template	access:private
offset	stl_bvector.h	/^  unsigned int offset;$/;"	m	struct:__bit_const_iterator	access:public
offset	stl_bvector.h	/^  unsigned int offset;$/;"	m	struct:__bit_iterator	access:public
oom_malloc	stl_alloc.h	/^static void *oom_malloc(size_t);$/;"	p	class:__malloc_alloc_template	access:private	signature:(size_t)
oom_malloc	stl_alloc.h	/^void * __malloc_alloc_template<inst>::oom_malloc(size_t n)$/;"	f	class:__malloc_alloc_template	signature:(size_t n)
oom_realloc	stl_alloc.h	/^static void *oom_realloc(void *, size_t);$/;"	p	class:__malloc_alloc_template	access:private	signature:(void *, size_t)
oom_realloc	stl_alloc.h	/^void * __malloc_alloc_template<inst>::oom_realloc(void *p, size_t n)$/;"	f	class:__malloc_alloc_template	signature:(void *p, size_t n)
op	stl_function.h	/^  Operation op;$/;"	m	class:binder1st	access:protected
op	stl_function.h	/^  Operation op;$/;"	m	class:binder2nd	access:protected
op1	stl_function.h	/^  Operation1 op1;$/;"	m	class:binary_compose	access:protected
op1	stl_function.h	/^  Operation1 op1;$/;"	m	class:unary_compose	access:protected
op2	stl_function.h	/^  Operation2 op2;$/;"	m	class:binary_compose	access:protected
op2	stl_function.h	/^  Operation2 op2;$/;"	m	class:unary_compose	access:protected
op3	stl_function.h	/^  Operation3 op3;$/;"	m	class:binary_compose	access:protected
operator !=	stl_bvector.h	/^  bool operator!=(const const_iterator& x) const {$/;"	f	struct:__bit_const_iterator	access:public	signature:(const const_iterator& x) const
operator !=	stl_bvector.h	/^  bool operator!=(const iterator& x) const {$/;"	f	struct:__bit_iterator	access:public	signature:(const iterator& x) const
operator !=	stl_deque.h	/^  bool operator!=(const deque<T, Alloc, 0>& x) const {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const deque<T, Alloc, 0>& x) const
operator !=	stl_deque.h	/^  bool operator!=(const self& x) const { return !(*this == x); }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(const self& x) const
operator !=	stl_hashtable.h	/^  bool operator!=(const const_iterator& it) const { return cur != it.cur; }$/;"	f	struct:__hashtable_const_iterator	access:public	signature:(const const_iterator& it) const
operator !=	stl_hashtable.h	/^  bool operator!=(const iterator& it) const { return cur != it.cur; }$/;"	f	struct:__hashtable_iterator	access:public	signature:(const iterator& it) const
operator !=	stl_list.h	/^  bool operator!=(const self& x) const { return node != x.node; }$/;"	f	struct:__list_iterator	access:public	signature:(const self& x) const
operator !=	stl_relops.h	/^inline bool operator!=(const T& x, const T& y) {$/;"	f	signature:(const T& x, const T& y)
operator !=	stl_slist.h	/^  bool operator!=(const __slist_iterator_base& x) const {$/;"	f	struct:__slist_iterator_base	access:public	signature:(const __slist_iterator_base& x) const
operator !=	stl_tree.h	/^inline bool operator!=(const __rb_tree_base_iterator& x,$/;"	f	signature:(const __rb_tree_base_iterator& x, const __rb_tree_base_iterator& y)
operator &	ropeimpl.h	/^__rope_charT_ref_proxy<charT, Alloc>::operator& () const {$/;"	f	class:__rope_charT_ref_proxy	signature:() const
operator &	stl_rope.h	/^    __rope_charT_ptr_proxy<charT,Alloc> operator& () const;$/;"	p	class:__rope_charT_ref_proxy	access:public	signature:() const
operator ()	ropeimpl.h	/^	bool operator() (const charT* leaf, size_t n) {$/;"	f	class:__rope_find_char_char_consumer	access:public	signature:(const charT* leaf, size_t n)
operator ()	ropeimpl.h	/^	bool operator() (const charT* leaf, size_t n) {$/;"	f	class:__rope_flatten_char_consumer	access:public	signature:(const charT* leaf, size_t n)
operator ()	ropeimpl.h	/^	bool operator() (const charT* leaf, size_t n);$/;"	p	class:__rope_insert_char_consumer	access:public	signature:(const charT* leaf, size_t n)
operator ()	ropeimpl.h	/^bool __rope_insert_char_consumer<charT>::operator()$/;"	f	class:__rope_insert_char_consumer	signature:(const charT * leaf, size_t n)
operator ()	ropeimpl.h	/^inline bool __rope_insert_char_consumer<char>::operator()$/;"	f	class:__rope_insert_char_consumer	signature:(const char * leaf, size_t n)
operator ()	ropeimpl.h	/^inline bool __rope_insert_char_consumer<wchar_t>::operator()$/;"	f	class:__rope_insert_char_consumer	signature:(const wchar_t * leaf, size_t n)
operator ()	stl_algobase.h	/^  BidirectionalIterator2 operator()(BidirectionalIterator1 first, $/;"	f	struct:__copy_backward_dispatch	access:public	signature:(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 result)
operator ()	stl_algobase.h	/^  OutputIterator operator()(InputIterator first, InputIterator last,$/;"	f	struct:__copy_dispatch	access:public	signature:(InputIterator first, InputIterator last, OutputIterator result)
operator ()	stl_algobase.h	/^  T* operator()(T* first, T* last, T* result) {$/;"	f	struct:__copy_backward_dispatch	access:public	signature:(T* first, T* last, T* result)
operator ()	stl_algobase.h	/^  T* operator()(T* first, T* last, T* result) {$/;"	f	struct:__copy_dispatch	access:public	signature:(T* first, T* last, T* result)
operator ()	stl_algobase.h	/^  T* operator()(const T* first, const T* last, T* result) {$/;"	f	struct:__copy_backward_dispatch	access:public	signature:(const T* first, const T* last, T* result)
operator ()	stl_algobase.h	/^  T* operator()(const T* first, const T* last, T* result) {$/;"	f	struct:__copy_dispatch	access:public	signature:(const T* first, const T* last, T* result)
operator ()	stl_function.h	/^    Result operator()(Arg1 x, Arg2 y) const { return ptr(x, y); }$/;"	f	class:pointer_to_binary_function	access:public	signature:(Arg1 x, Arg2 y) const
operator ()	stl_function.h	/^    T operator()(const T& x) const { return -x; }$/;"	f	struct:negate	access:public	signature:(const T& x) const
operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x % y; }$/;"	f	struct:modulus	access:public	signature:(const T& x, const T& y) const
operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x * y; }$/;"	f	struct:multiplies	access:public	signature:(const T& x, const T& y) const
operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x + y; }$/;"	f	struct:plus	access:public	signature:(const T& x, const T& y) const
operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x - y; }$/;"	f	struct:minus	access:public	signature:(const T& x, const T& y) const
operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x \/ y; }$/;"	f	struct:divides	access:public	signature:(const T& x, const T& y) const
operator ()	stl_function.h	/^    bool operator()(const T& x) const { return !x; }$/;"	f	struct:logical_not	access:public	signature:(const T& x) const
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x != y; }$/;"	f	struct:not_equal_to	access:public	signature:(const T& x, const T& y) const
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x && y; }$/;"	f	struct:logical_and	access:public	signature:(const T& x, const T& y) const
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x < y; }$/;"	f	struct:less	access:public	signature:(const T& x, const T& y) const
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x <= y; }$/;"	f	struct:less_equal	access:public	signature:(const T& x, const T& y) const
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x == y; }$/;"	f	struct:equal_to	access:public	signature:(const T& x, const T& y) const
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x > y; }$/;"	f	struct:greater	access:public	signature:(const T& x, const T& y) const
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x >= y; }$/;"	f	struct:greater_equal	access:public	signature:(const T& x, const T& y) const
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x || y; }$/;"	f	struct:logical_or	access:public	signature:(const T& x, const T& y) const
operator ()	stl_function.h	/^  Arg1 operator()(const Arg1& x, const Arg2&) const { return x; }$/;"	f	struct:project1st	access:public	signature:(const Arg1& x, const Arg2&) const
operator ()	stl_function.h	/^  Arg2 operator()(const Arg1&, const Arg2& y) const { return y; }$/;"	f	struct:project2nd	access:public	signature:(const Arg1&, const Arg2& y) const
operator ()	stl_function.h	/^  Result operator()(Arg x) const { return ptr(x); }$/;"	f	class:pointer_to_unary_function	access:public	signature:(Arg x) const
operator ()	stl_function.h	/^  S operator()(T& r) const { return (r.*f)(); }$/;"	f	class:mem_fun_ref_t	access:public	signature:(T& r) const
operator ()	stl_function.h	/^  S operator()(T& r, A x) const { return (r.*f)(x); }$/;"	f	class:mem_fun1_ref_t	access:public	signature:(T& r, A x) const
operator ()	stl_function.h	/^  S operator()(T* p) const { return (p->*f)(); }$/;"	f	class:mem_fun_t	access:public	signature:(T* p) const
operator ()	stl_function.h	/^  S operator()(T* p, A x) const { return (p->*f)(x); }$/;"	f	class:mem_fun1_t	access:public	signature:(T* p, A x) const
operator ()	stl_function.h	/^  S operator()(const T& r) const { return (r.*f)(); }$/;"	f	class:const_mem_fun_ref_t	access:public	signature:(const T& r) const
operator ()	stl_function.h	/^  S operator()(const T& r, A x) const { return (r.*f)(x); }$/;"	f	class:const_mem_fun1_ref_t	access:public	signature:(const T& r, A x) const
operator ()	stl_function.h	/^  S operator()(const T* p) const { return (p->*f)(); }$/;"	f	class:const_mem_fun_t	access:public	signature:(const T* p) const
operator ()	stl_function.h	/^  S operator()(const T* p, A x) const { return (p->*f)(x); }$/;"	f	class:const_mem_fun1_t	access:public	signature:(const T* p, A x) const
operator ()	stl_function.h	/^  bool operator()(const typename Predicate::argument_type& x) const {$/;"	f	class:unary_negate	access:public	signature:(const typename Predicate::argument_type& x) const
operator ()	stl_function.h	/^  bool operator()(const typename Predicate::first_argument_type& x, $/;"	f	class:binary_negate	access:public	signature:(const typename Predicate::first_argument_type& x, const typename Predicate::second_argument_type& y) const
operator ()	stl_function.h	/^  const Result& operator()(const Arg1&, const Arg2&) const {$/;"	f	struct:constant_binary_fun	access:public	signature:(const Arg1&, const Arg2&) const
operator ()	stl_function.h	/^  const Result& operator()(const Argument&) const { return val; }$/;"	f	struct:constant_unary_fun	access:public	signature:(const Argument&) const
operator ()	stl_function.h	/^  const T& operator()(const T& x) const { return x; }$/;"	f	struct:identity	access:public	signature:(const T& x) const
operator ()	stl_function.h	/^  const result_type& operator()() const { return val; }$/;"	f	struct:constant_void_fun	access:public	signature:() const
operator ()	stl_function.h	/^  const typename Pair::first_type& operator()(const Pair& x) const$/;"	f	struct:select1st	access:public	signature:(const Pair& x) const
operator ()	stl_function.h	/^  const typename Pair::second_type& operator()(const Pair& x) const$/;"	f	struct:select2nd	access:public	signature:(const Pair& x) const
operator ()	stl_function.h	/^  operator()(const typename Operation2::argument_type& x) const {$/;"	f	class:binary_compose	access:public	signature:(const typename Operation2::argument_type& x) const
operator ()	stl_function.h	/^  operator()(const typename Operation2::argument_type& x) const {$/;"	f	class:unary_compose	access:public	signature:(const typename Operation2::argument_type& x) const
operator ()	stl_function.h	/^  operator()(const typename Operation::first_argument_type& x) const {$/;"	f	class:binder2nd	access:public	signature:(const typename Operation::first_argument_type& x) const
operator ()	stl_function.h	/^  operator()(const typename Operation::second_argument_type& x) const {$/;"	f	class:binder1st	access:public	signature:(const typename Operation::second_argument_type& x) const
operator ()	stl_function.h	/^  unsigned int operator()(unsigned int limit) {$/;"	f	class:subtractive_rng	access:public	signature:(unsigned int limit)
operator ()	stl_function.h	/^  void operator()(T& r) const { (r.*f)(); }$/;"	f	class:mem_fun_ref_t	access:public	signature:(T& r) const
operator ()	stl_function.h	/^  void operator()(T& r, A x) const { (r.*f)(x); }$/;"	f	class:mem_fun1_ref_t	access:public	signature:(T& r, A x) const
operator ()	stl_function.h	/^  void operator()(T* p) const { (p->*f)(); }$/;"	f	class:mem_fun_t	access:public	signature:(T* p) const
operator ()	stl_function.h	/^  void operator()(T* p, A x) const { (p->*f)(x); }$/;"	f	class:mem_fun1_t	access:public	signature:(T* p, A x) const
operator ()	stl_function.h	/^  void operator()(const T& r) const { (r.*f)(); }$/;"	f	class:const_mem_fun_ref_t	access:public	signature:(const T& r) const
operator ()	stl_function.h	/^  void operator()(const T& r, A x) const { (r.*f)(x); }$/;"	f	class:const_mem_fun1_ref_t	access:public	signature:(const T& r, A x) const
operator ()	stl_function.h	/^  void operator()(const T* p) const { (p->*f)(); }$/;"	f	class:const_mem_fun_t	access:public	signature:(const T* p) const
operator ()	stl_function.h	/^  void operator()(const T* p, A x) const { (p->*f)(x); }$/;"	f	class:const_mem_fun1_t	access:public	signature:(const T* p, A x) const
operator ()	stl_hash_fun.h	/^  size_t operator()(char x) const { return x; }$/;"	f	struct:hash	access:public	signature:(char x) const
operator ()	stl_hash_fun.h	/^  size_t operator()(const char* s) const { return __stl_hash_string(s); }$/;"	f	struct:hash	access:public	signature:(const char* s) const
operator ()	stl_hash_fun.h	/^  size_t operator()(int x) const { return x; }$/;"	f	struct:hash	access:public	signature:(int x) const
operator ()	stl_hash_fun.h	/^  size_t operator()(long x) const { return x; }$/;"	f	struct:hash	access:public	signature:(long x) const
operator ()	stl_hash_fun.h	/^  size_t operator()(short x) const { return x; }$/;"	f	struct:hash	access:public	signature:(short x) const
operator ()	stl_hash_fun.h	/^  size_t operator()(unsigned char x) const { return x; }$/;"	f	struct:hash	access:public	signature:(unsigned char x) const
operator ()	stl_hash_fun.h	/^  size_t operator()(unsigned int x) const { return x; }$/;"	f	struct:hash	access:public	signature:(unsigned int x) const
operator ()	stl_hash_fun.h	/^  size_t operator()(unsigned long x) const { return x; }$/;"	f	struct:hash	access:public	signature:(unsigned long x) const
operator ()	stl_hash_fun.h	/^  size_t operator()(unsigned short x) const { return x; }$/;"	f	struct:hash	access:public	signature:(unsigned short x) const
operator ()	stl_map.h	/^    bool operator()(const value_type& x, const value_type& y) const {$/;"	f	class:map::value_compare	access:public	signature:(const value_type& x, const value_type& y) const
operator ()	stl_multimap.h	/^    bool operator()(const value_type& x, const value_type& y) const {$/;"	f	class:multimap::value_compare	access:public	signature:(const value_type& x, const value_type& y) const
operator ()	stl_rope.h	/^		rope operator() (const rope& x, const rope& y) {$/;"	f	struct:rope::concat_fn	access:public	signature:(const rope& x, const rope& y)
operator ()	stl_rope.h	/^	virtual bool operator()(const charT* buffer, size_t len) = 0;$/;"	p	class:__rope_char_consumer	access:public	signature:(const charT* buffer, size_t len)
operator ()	stl_rope.h	/^	virtual void operator()(size_t start_pos, size_t len, charT* buffer)$/;"	p	class:char_producer	access:public	signature:(size_t start_pos, size_t len, charT* buffer)
operator ()	stl_rope.h	/^    virtual void operator()(size_t start_pos, size_t req_len,$/;"	f	struct:__rope_RopeSubstring	access:public	signature:(size_t start_pos, size_t req_len, charT *buffer)
operator ()	stl_rope.h	/^  size_t operator()(const crope& str) const$/;"	f	struct:hash	access:public	signature:(const crope& str) const
operator ()	stl_rope.h	/^  size_t operator()(const wrope& str) const$/;"	f	struct:hash	access:public	signature:(const wrope& str) const
operator *	stl_bvector.h	/^  const_reference operator*() const {$/;"	f	struct:__bit_const_iterator	access:public	signature:() const
operator *	stl_bvector.h	/^  reference operator*() const { return reference(p, 1U << offset); }$/;"	f	struct:__bit_iterator	access:public	signature:() const
operator *	stl_deque.h	/^  reference operator*() const { return *cur; }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:() const
operator *	stl_hashtable.h	/^  reference operator*() const { return cur->val; }$/;"	f	struct:__hashtable_const_iterator	access:public	signature:() const
operator *	stl_hashtable.h	/^  reference operator*() const { return cur->val; }$/;"	f	struct:__hashtable_iterator	access:public	signature:() const
operator *	stl_iterator.h	/^  Reference operator*() const { return *(current - 1); }$/;"	f	class:reverse_iterator	access:public	signature:() const
operator *	stl_iterator.h	/^  Reference operator*() const {$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:() const
operator *	stl_iterator.h	/^  back_insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:back_insert_iterator	access:public	signature:()
operator *	stl_iterator.h	/^  front_insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:front_insert_iterator	access:public	signature:()
operator *	stl_iterator.h	/^  insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:insert_iterator	access:public	signature:()
operator *	stl_iterator.h	/^  ostream_iterator<T>& operator*() { return *this; }$/;"	f	class:ostream_iterator	access:public	signature:()
operator *	stl_iterator.h	/^  reference operator*() const { return value; }$/;"	f	class:istream_iterator	access:public	signature:() const
operator *	stl_iterator.h	/^  reference operator*() const {$/;"	f	class:reverse_iterator	access:public	signature:() const
operator *	stl_list.h	/^  reference operator*() const { return (*node).data; }$/;"	f	struct:__list_iterator	access:public	signature:() const
operator *	stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator*() { return *this; }$/;"	f	class:raw_storage_iterator	access:public	signature:()
operator *	stl_rope.h	/^	sequence_buffer& operator*() { return *this; }$/;"	f	class:sequence_buffer	access:public	signature:()
operator *	stl_rope.h	/^    __rope_RopeBase<charT,Alloc> & operator*() { return *ptr; }$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:()
operator *	stl_rope.h	/^    __rope_charT_ref_proxy<charT,Alloc> operator *() const {$/;"	f	class:__rope_charT_ptr_proxy	access:public	signature:() const
operator *	stl_rope.h	/^    reference operator*() {$/;"	f	class:__rope_const_iterator	access:public	signature:()
operator *	stl_rope.h	/^    reference operator*() {$/;"	f	class:__rope_iterator	access:public	signature:()
operator *	stl_slist.h	/^  reference operator*() const { return ((list_node*) node)->data; }$/;"	f	struct:__slist_iterator	access:public	signature:() const
operator *	stl_tree.h	/^  reference operator*() const { return link_type(node)->value_field; }$/;"	f	struct:__rb_tree_iterator	access:public	signature:() const
operator +	stl_bvector.h	/^  const_iterator operator+(difference_type i) const {$/;"	f	struct:__bit_const_iterator	access:public	signature:(difference_type i) const
operator +	stl_bvector.h	/^  iterator operator+(difference_type i) const {$/;"	f	struct:__bit_iterator	access:public	signature:(difference_type i) const
operator +	stl_deque.h	/^  self operator+(difference_type n) const {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(difference_type n) const
operator +	stl_iterator.h	/^  self operator+(Distance n) const {$/;"	f	class:reverse_iterator	access:public	signature:(Distance n) const
operator +	stl_iterator.h	/^  self operator+(difference_type n) const {$/;"	f	class:reverse_iterator	access:public	signature:(difference_type n) const
operator +	stl_iterator.h	/^operator+(Dist n, const reverse_iterator<RandomAccessIter, T, Ref, Dist>& x) {$/;"	f	signature:(Dist n, const reverse_iterator<RandomAccessIter, T, Ref, Dist>& x)
operator +	stl_iterator.h	/^operator+(reverse_iterator<Iterator>::difference_type n,$/;"	f	signature:(reverse_iterator<Iterator>::difference_type n, const reverse_iterator<Iterator>& x)
operator +	stl_rope.h	/^operator+ (const rope<charT,Alloc> &left, charT right) {$/;"	f	signature:(const rope<charT,Alloc> &left, charT right)
operator +	stl_rope.h	/^operator+ (const rope<charT,Alloc> &left,$/;"	f	signature:(const rope<charT,Alloc> &left, const charT* right)
operator +	stl_rope.h	/^operator+ (const rope<charT,Alloc> &left,$/;"	f	signature:(const rope<charT,Alloc> &left, const rope<charT,Alloc> &right)
operator +	stl_rope.h	/^operator+(const __rope_const_iterator<charT,Alloc> & x,$/;"	f	signature:(const __rope_const_iterator<charT,Alloc> & x, ptrdiff_t n)
operator +	stl_rope.h	/^operator+(const __rope_iterator<charT,Alloc> & x,$/;"	f	signature:(const __rope_iterator<charT,Alloc> & x, ptrdiff_t n)
operator +	stl_rope.h	/^operator+(ptrdiff_t n,$/;"	f	signature:(ptrdiff_t n, const __rope_const_iterator<charT,Alloc> & x)
operator +	stl_rope.h	/^operator+(ptrdiff_t n,$/;"	f	signature:(ptrdiff_t n, const __rope_iterator<charT,Alloc> & x)
operator ++	stl_bvector.h	/^  const_iterator operator++(int) {$/;"	f	struct:__bit_const_iterator	access:public	signature:(int)
operator ++	stl_bvector.h	/^  const_iterator& operator++() {$/;"	f	struct:__bit_const_iterator	access:public	signature:()
operator ++	stl_bvector.h	/^  iterator operator++(int) {$/;"	f	struct:__bit_iterator	access:public	signature:(int)
operator ++	stl_bvector.h	/^  iterator& operator++() {$/;"	f	struct:__bit_iterator	access:public	signature:()
operator ++	stl_deque.h	/^  self operator++(int)  {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(int)
operator ++	stl_deque.h	/^  self& operator++() {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:()
operator ++	stl_hashtable.h	/^  const_iterator operator++(int);$/;"	p	struct:__hashtable_const_iterator	access:public	signature:(int)
operator ++	stl_hashtable.h	/^  const_iterator& operator++();$/;"	p	struct:__hashtable_const_iterator	access:public	signature:()
operator ++	stl_hashtable.h	/^  iterator operator++(int);$/;"	p	struct:__hashtable_iterator	access:public	signature:(int)
operator ++	stl_hashtable.h	/^  iterator& operator++();$/;"	p	struct:__hashtable_iterator	access:public	signature:()
operator ++	stl_hashtable.h	/^__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++()$/;"	f	class:__hashtable_const_iterator	signature:()
operator ++	stl_hashtable.h	/^__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++(int)$/;"	f	class:__hashtable_const_iterator	signature:(int)
operator ++	stl_hashtable.h	/^__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++()$/;"	f	class:__hashtable_iterator	signature:()
operator ++	stl_hashtable.h	/^__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++(int)$/;"	f	class:__hashtable_iterator	signature:(int)
operator ++	stl_iterator.h	/^  back_insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:back_insert_iterator	access:public	signature:()
operator ++	stl_iterator.h	/^  back_insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:back_insert_iterator	access:public	signature:(int)
operator ++	stl_iterator.h	/^  front_insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:front_insert_iterator	access:public	signature:()
operator ++	stl_iterator.h	/^  front_insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:front_insert_iterator	access:public	signature:(int)
operator ++	stl_iterator.h	/^  insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:insert_iterator	access:public	signature:()
operator ++	stl_iterator.h	/^  insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:insert_iterator	access:public	signature:(int)
operator ++	stl_iterator.h	/^  istream_iterator<T, Distance> operator++(int)  {$/;"	f	class:istream_iterator	access:public	signature:(int)
operator ++	stl_iterator.h	/^  istream_iterator<T, Distance>& operator++() { $/;"	f	class:istream_iterator	access:public	signature:()
operator ++	stl_iterator.h	/^  ostream_iterator<T>& operator++() { return *this; } $/;"	f	class:ostream_iterator	access:public	signature:()
operator ++	stl_iterator.h	/^  ostream_iterator<T>& operator++(int) { return *this; } $/;"	f	class:ostream_iterator	access:public	signature:(int)
operator ++	stl_iterator.h	/^  self operator++(int) {$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:(int)
operator ++	stl_iterator.h	/^  self operator++(int) {$/;"	f	class:reverse_iterator	access:public	signature:(int)
operator ++	stl_iterator.h	/^  self& operator++() {$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:()
operator ++	stl_iterator.h	/^  self& operator++() {$/;"	f	class:reverse_iterator	access:public	signature:()
operator ++	stl_list.h	/^  self operator++(int) { $/;"	f	struct:__list_iterator	access:public	signature:(int)
operator ++	stl_list.h	/^  self& operator++() { $/;"	f	struct:__list_iterator	access:public	signature:()
operator ++	stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T> operator++(int) {$/;"	f	class:raw_storage_iterator	access:public	signature:(int)
operator ++	stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator++() {$/;"	f	class:raw_storage_iterator	access:public	signature:()
operator ++	stl_rope.h	/^	sequence_buffer& operator++() { return *this; }$/;"	f	class:sequence_buffer	access:public	signature:()
operator ++	stl_rope.h	/^	sequence_buffer& operator++(int) { return *this; }$/;"	f	class:sequence_buffer	access:public	signature:(int)
operator ++	stl_rope.h	/^    __rope_const_iterator operator++(int) {$/;"	f	class:__rope_const_iterator	access:public	signature:(int)
operator ++	stl_rope.h	/^    __rope_const_iterator& operator++() {$/;"	f	class:__rope_const_iterator	access:public	signature:()
operator ++	stl_rope.h	/^    __rope_iterator operator++(int) {$/;"	f	class:__rope_iterator	access:public	signature:(int)
operator ++	stl_rope.h	/^    __rope_iterator& operator++() {$/;"	f	class:__rope_iterator	access:public	signature:()
operator ++	stl_slist.h	/^  self operator++(int)$/;"	f	struct:__slist_iterator	access:public	signature:(int)
operator ++	stl_slist.h	/^  self& operator++()$/;"	f	struct:__slist_iterator	access:public	signature:()
operator ++	stl_tree.h	/^  self operator++(int) {$/;"	f	struct:__rb_tree_iterator	access:public	signature:(int)
operator ++	stl_tree.h	/^  self& operator++() { increment(); return *this; }$/;"	f	struct:__rb_tree_iterator	access:public	signature:()
operator +=	stl_bvector.h	/^  const_iterator& operator+=(difference_type i) {$/;"	f	struct:__bit_const_iterator	access:public	signature:(difference_type i)
operator +=	stl_bvector.h	/^  iterator& operator+=(difference_type i) {$/;"	f	struct:__bit_iterator	access:public	signature:(difference_type i)
operator +=	stl_deque.h	/^  self& operator+=(difference_type n) {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(difference_type n)
operator +=	stl_iterator.h	/^  self& operator+=(Distance n) {$/;"	f	class:reverse_iterator	access:public	signature:(Distance n)
operator +=	stl_iterator.h	/^  self& operator+=(difference_type n) {$/;"	f	class:reverse_iterator	access:public	signature:(difference_type n)
operator +=	stl_rope.h	/^    __rope_const_iterator& operator+=(ptrdiff_t n) {$/;"	f	class:__rope_const_iterator	access:public	signature:(ptrdiff_t n)
operator +=	stl_rope.h	/^    __rope_iterator& operator+=(difference_type n) {$/;"	f	class:__rope_iterator	access:public	signature:(difference_type n)
operator +=	stl_rope.h	/^operator+= (rope<charT,Alloc> &left, charT right) {$/;"	f	signature:(rope<charT,Alloc> &left, charT right)
operator +=	stl_rope.h	/^operator+= (rope<charT,Alloc> &left,$/;"	f	signature:(rope<charT,Alloc> &left, const charT* right)
operator +=	stl_rope.h	/^operator+= (rope<charT,Alloc> &left,$/;"	f	signature:(rope<charT,Alloc> &left, const rope<charT,Alloc> &right)
operator -	stl_bvector.h	/^  const_iterator operator-(difference_type i) const {$/;"	f	struct:__bit_const_iterator	access:public	signature:(difference_type i) const
operator -	stl_bvector.h	/^  difference_type operator-(const_iterator x) const {$/;"	f	struct:__bit_const_iterator	access:public	signature:(const_iterator x) const
operator -	stl_bvector.h	/^  difference_type operator-(iterator x) const {$/;"	f	struct:__bit_iterator	access:public	signature:(iterator x) const
operator -	stl_bvector.h	/^  iterator operator-(difference_type i) const {$/;"	f	struct:__bit_iterator	access:public	signature:(difference_type i) const
operator -	stl_deque.h	/^  difference_type operator-(const self& x) const {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(const self& x) const
operator -	stl_deque.h	/^  self operator-(difference_type n) const {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(difference_type n) const
operator -	stl_iterator.h	/^  self operator-(Distance n) const {$/;"	f	class:reverse_iterator	access:public	signature:(Distance n) const
operator -	stl_iterator.h	/^  self operator-(difference_type n) const {$/;"	f	class:reverse_iterator	access:public	signature:(difference_type n) const
operator -	stl_iterator.h	/^inline Distance operator-(const reverse_iterator<RandomAccessIterator, T,$/;"	f	signature:(const reverse_iterator<RandomAccessIterator, T, Reference, Distance>& x, const reverse_iterator<RandomAccessIterator, T, Reference, Distance>& y)
operator -	stl_iterator.h	/^operator-(const reverse_iterator<Iterator>& x, $/;"	f	signature:(const reverse_iterator<Iterator>& x, const reverse_iterator<Iterator>& y)
operator -	stl_rope.h	/^inline ptrdiff_t operator-(const __rope_const_iterator<charT,Alloc> & x,$/;"	f	signature:(const __rope_const_iterator<charT,Alloc> & x, const __rope_const_iterator<charT,Alloc> & y)
operator -	stl_rope.h	/^inline ptrdiff_t operator-(const __rope_iterator<charT,Alloc> & x,$/;"	f	signature:(const __rope_iterator<charT,Alloc> & x, const __rope_iterator<charT,Alloc> & y)
operator -	stl_rope.h	/^operator-(const __rope_const_iterator<charT,Alloc> & x,$/;"	f	signature:(const __rope_const_iterator<charT,Alloc> & x, ptrdiff_t n)
operator -	stl_rope.h	/^operator-(const __rope_iterator<charT,Alloc> & x,$/;"	f	signature:(const __rope_iterator<charT,Alloc> & x, ptrdiff_t n)
operator --	stl_bvector.h	/^  const_iterator operator--(int) {$/;"	f	struct:__bit_const_iterator	access:public	signature:(int)
operator --	stl_bvector.h	/^  const_iterator& operator--() {$/;"	f	struct:__bit_const_iterator	access:public	signature:()
operator --	stl_bvector.h	/^  iterator operator--(int) {$/;"	f	struct:__bit_iterator	access:public	signature:(int)
operator --	stl_bvector.h	/^  iterator& operator--() {$/;"	f	struct:__bit_iterator	access:public	signature:()
operator --	stl_deque.h	/^  self operator--(int) {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(int)
operator --	stl_deque.h	/^  self& operator--() {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:()
operator --	stl_iterator.h	/^  self operator--(int) {$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:(int)
operator --	stl_iterator.h	/^  self operator--(int) {$/;"	f	class:reverse_iterator	access:public	signature:(int)
operator --	stl_iterator.h	/^  self& operator--() {$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:()
operator --	stl_iterator.h	/^  self& operator--() {$/;"	f	class:reverse_iterator	access:public	signature:()
operator --	stl_list.h	/^  self operator--(int) { $/;"	f	struct:__list_iterator	access:public	signature:(int)
operator --	stl_list.h	/^  self& operator--() { $/;"	f	struct:__list_iterator	access:public	signature:()
operator --	stl_rope.h	/^    __rope_const_iterator operator--(int) {$/;"	f	class:__rope_const_iterator	access:public	signature:(int)
operator --	stl_rope.h	/^    __rope_const_iterator& operator--() {$/;"	f	class:__rope_const_iterator	access:public	signature:()
operator --	stl_rope.h	/^    __rope_iterator operator--(int) {$/;"	f	class:__rope_iterator	access:public	signature:(int)
operator --	stl_rope.h	/^    __rope_iterator& operator--() {$/;"	f	class:__rope_iterator	access:public	signature:()
operator --	stl_tree.h	/^  self operator--(int) {$/;"	f	struct:__rb_tree_iterator	access:public	signature:(int)
operator --	stl_tree.h	/^  self& operator--() { decrement(); return *this; }$/;"	f	struct:__rb_tree_iterator	access:public	signature:()
operator -=	stl_bvector.h	/^  const_iterator& operator-=(difference_type i) {$/;"	f	struct:__bit_const_iterator	access:public	signature:(difference_type i)
operator -=	stl_bvector.h	/^  iterator& operator-=(difference_type i) {$/;"	f	struct:__bit_iterator	access:public	signature:(difference_type i)
operator -=	stl_deque.h	/^  self& operator-=(difference_type n) { return *this += -n; }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(difference_type n)
operator -=	stl_iterator.h	/^  self& operator-=(Distance n) {$/;"	f	class:reverse_iterator	access:public	signature:(Distance n)
operator -=	stl_iterator.h	/^  self& operator-=(difference_type n) {$/;"	f	class:reverse_iterator	access:public	signature:(difference_type n)
operator -=	stl_rope.h	/^    __rope_const_iterator& operator-=(ptrdiff_t n) {$/;"	f	class:__rope_const_iterator	access:public	signature:(ptrdiff_t n)
operator -=	stl_rope.h	/^    __rope_iterator& operator-=(difference_type n) {$/;"	f	class:__rope_iterator	access:public	signature:(difference_type n)
operator ->	stl_deque.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:() const
operator ->	stl_hashtable.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__hashtable_const_iterator	access:public	signature:() const
operator ->	stl_hashtable.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__hashtable_iterator	access:public	signature:() const
operator ->	stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:istream_iterator	access:public	signature:() const
operator ->	stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:() const
operator ->	stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:reverse_iterator	access:public	signature:() const
operator ->	stl_list.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__list_iterator	access:public	signature:() const
operator ->	stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * operator->() { return ptr; }$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:()
operator ->	stl_slist.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__slist_iterator	access:public	signature:() const
operator ->	stl_tree.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__rb_tree_iterator	access:public	signature:() const
operator <	stl_bvector.h	/^  bool operator<(const __bit_reference& x) const {$/;"	f	struct:__bit_reference	access:public	signature:(const __bit_reference& x) const
operator <	stl_bvector.h	/^  bool operator<(const_iterator x) const {$/;"	f	struct:__bit_const_iterator	access:public	signature:(const_iterator x) const
operator <	stl_bvector.h	/^  bool operator<(iterator x) const {$/;"	f	struct:__bit_iterator	access:public	signature:(iterator x) const
operator <	stl_bvector.h	/^inline bool operator<(const bit_vector& x, const bit_vector& y) {$/;"	f	signature:(const bit_vector& x, const bit_vector& y)
operator <	stl_deque.h	/^  bool operator<(const deque<T, Alloc, 0>& x) const {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const deque<T, Alloc, 0>& x) const
operator <	stl_deque.h	/^  bool operator<(const self& x) const {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(const self& x) const
operator <	stl_deque.h	/^bool operator<(const deque<T, Alloc, BufSiz>& x,$/;"	f	struct:__deque_iterator	access:public	signature:(const deque<T, Alloc, BufSiz>& x, const deque<T, Alloc, BufSiz>& y)
operator <	stl_iterator.h	/^inline bool operator<(const reverse_iterator<Iterator>& x, $/;"	f	signature:(const reverse_iterator<Iterator>& x, const reverse_iterator<Iterator>& y)
operator <	stl_iterator.h	/^inline bool operator<(const reverse_iterator<RandomAccessIterator, T,$/;"	f	signature:(const reverse_iterator<RandomAccessIterator, T, Reference, Distance>& x, const reverse_iterator<RandomAccessIterator, T, Reference, Distance>& y)
operator <	stl_list.h	/^inline bool operator<(const list<T, Alloc>& x, const list<T, Alloc>& y) {$/;"	f	signature:(const list<T, Alloc>& x, const list<T, Alloc>& y)
operator <	stl_map.h	/^inline bool operator<(const map<Key, T, Compare, Alloc>& x, $/;"	f	signature:(const map<Key, T, Compare, Alloc>& x, const map<Key, T, Compare, Alloc>& y)
operator <	stl_multimap.h	/^inline bool operator<(const multimap<Key, T, Compare, Alloc>& x, $/;"	f	signature:(const multimap<Key, T, Compare, Alloc>& x, const multimap<Key, T, Compare, Alloc>& y)
operator <	stl_multiset.h	/^inline bool operator<(const multiset<Key, Compare, Alloc>& x, $/;"	f	signature:(const multiset<Key, Compare, Alloc>& x, const multiset<Key, Compare, Alloc>& y)
operator <	stl_pair.h	/^inline bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y) { $/;"	f	signature:(const pair<T1, T2>& x, const pair<T1, T2>& y)
operator <	stl_queue.h	/^bool operator<(const queue<T, Sequence>& x, const queue<T, Sequence>& y) {$/;"	f	signature:(const queue<T, Sequence>& x, const queue<T, Sequence>& y)
operator <	stl_rope.h	/^inline bool operator< (const __rope_const_iterator<charT,Alloc> & x,$/;"	f	signature:(const __rope_const_iterator<charT,Alloc> & x, const __rope_const_iterator<charT,Alloc> & y)
operator <	stl_rope.h	/^inline bool operator< (const __rope_iterator<charT,Alloc> & x,$/;"	f	signature:(const __rope_iterator<charT,Alloc> & x, const __rope_iterator<charT,Alloc> & y)
operator <	stl_rope.h	/^operator< (const rope<charT,Alloc> &left, const rope<charT,Alloc> &right) {$/;"	f	signature:(const rope<charT,Alloc> &left, const rope<charT,Alloc> &right)
operator <	stl_set.h	/^inline bool operator<(const set<Key, Compare, Alloc>& x, $/;"	f	signature:(const set<Key, Compare, Alloc>& x, const set<Key, Compare, Alloc>& y)
operator <	stl_slist.h	/^inline bool operator<(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)$/;"	f	signature:(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)
operator <	stl_stack.h	/^bool operator<(const stack<T, Sequence>& x, const stack<T, Sequence>& y) {$/;"	f	signature:(const stack<T, Sequence>& x, const stack<T, Sequence>& y)
operator <	stl_tree.h	/^inline bool operator<(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, $/;"	f	signature:(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& y)
operator <	stl_vector.h	/^inline bool operator<(const vector<T, Alloc>& x, const vector<T, Alloc>& y) {$/;"	f	signature:(const vector<T, Alloc>& x, const vector<T, Alloc>& y)
operator <<	ropeimpl.h	/^ostream& operator<< (ostream& o, const rope<charT, Alloc>& r)$/;"	f	signature:(ostream& o, const rope<charT, Alloc>& r)
operator <<	stl_rope.h	/^ostream& operator<< (ostream& o, const rope<charT, Alloc>& r);        $/;"	p	signature:(ostream& o, const rope<charT, Alloc>& r)
operator <=	stl_relops.h	/^inline bool operator<=(const T& x, const T& y) {$/;"	f	signature:(const T& x, const T& y)
operator =	ropeimpl.h	/^__rope_charT_ref_proxy<charT, Alloc>::operator= (charT c) {$/;"	f	class:__rope_charT_ref_proxy	signature:(charT c)
operator =	stl_bvector.h	/^  __BVECTOR& operator=(const __BVECTOR& x) {$/;"	f	class:vector	access:public	signature:(const __BVECTOR& x)
operator =	stl_bvector.h	/^  __bit_reference& operator=(bool x) {$/;"	f	struct:__bit_reference	access:public	signature:(bool x)
operator =	stl_bvector.h	/^  __bit_reference& operator=(const __bit_reference& x) { return *this = bool(x); }$/;"	f	struct:__bit_reference	access:public	signature:(const __bit_reference& x)
operator =	stl_deque.h	/^  deque& operator= (const deque& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const deque& x)
operator =	stl_hashtable.h	/^  hashtable& operator= (const hashtable& ht)$/;"	f	class:hashtable	access:public	signature:(const hashtable& ht)
operator =	stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:back_insert_iterator	access:public	signature:(const typename Container::value_type& value)
operator =	stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:front_insert_iterator	access:public	signature:(const typename Container::value_type& value)
operator =	stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:insert_iterator	access:public	signature:(const typename Container::value_type& value)
operator =	stl_iterator.h	/^  ostream_iterator<T>& operator=(const T& value) { $/;"	f	class:ostream_iterator	access:public	signature:(const T& value)
operator =	stl_list.h	/^  list<T, Alloc>& operator=(const list<T, Alloc>& x);$/;"	p	class:list	access:public	signature:(const list<T, Alloc>& x)
operator =	stl_list.h	/^list<T, Alloc>& list<T, Alloc>::operator=(const list<T, Alloc>& x) {$/;"	f	class:list	signature:(const list<T, Alloc>& x)
operator =	stl_map.h	/^  map<Key, T, Compare, Alloc>& operator=(const map<Key, T, Compare, Alloc>& x)$/;"	f	class:map	access:public	signature:(const map<Key, T, Compare, Alloc>& x)
operator =	stl_multimap.h	/^  operator=(const multimap<Key, T, Compare, Alloc>& x) {$/;"	f	class:multimap	access:public	signature:(const multimap<Key, T, Compare, Alloc>& x)
operator =	stl_multiset.h	/^  operator=(const multiset<Key, Compare, Alloc>& x) {$/;"	f	class:multiset	access:public	signature:(const multiset<Key, Compare, Alloc>& x)
operator =	stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator=(const T& element) {$/;"	f	class:raw_storage_iterator	access:public	signature:(const T& element)
operator =	stl_rope.h	/^	rope& operator=(const rope& x)$/;"	f	class:rope	access:public	signature:(const rope& x)
operator =	stl_rope.h	/^	sequence_buffer& operator= (const sequence_buffer& x) {$/;"	f	class:sequence_buffer	access:public	signature:(const sequence_buffer& x)
operator =	stl_rope.h	/^	sequence_buffer& operator= (sequence_buffer& x) {$/;"	f	class:sequence_buffer	access:public	signature:(sequence_buffer& x)
operator =	stl_rope.h	/^	sequence_buffer& operator=(const value_type& rhs)$/;"	f	class:sequence_buffer	access:public	signature:(const value_type& rhs)
operator =	stl_rope.h	/^    __rope_charT_ptr_proxy& operator= (const __rope_charT_ptr_proxy& x) {$/;"	f	class:__rope_charT_ptr_proxy	access:public	signature:(const __rope_charT_ptr_proxy& x)
operator =	stl_rope.h	/^    __rope_charT_ref_proxy& operator= (charT c);$/;"	p	class:__rope_charT_ref_proxy	access:public	signature:(charT c)
operator =	stl_rope.h	/^    __rope_charT_ref_proxy& operator= (const __rope_charT_ref_proxy& c) {$/;"	f	class:__rope_charT_ref_proxy	access:public	signature:(const __rope_charT_ref_proxy& c)
operator =	stl_rope.h	/^    __rope_const_iterator& operator= (const __rope_const_iterator & x) {$/;"	f	class:__rope_const_iterator	access:public	signature:(const __rope_const_iterator & x)
operator =	stl_rope.h	/^    __rope_iterator& operator= (const __rope_iterator & x) {$/;"	f	class:__rope_iterator	access:public	signature:(const __rope_iterator & x)
operator =	stl_rope.h	/^    __rope_self_destruct_ptr & operator= (__rope_RopeBase<charT,Alloc> * x)$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:(__rope_RopeBase<charT,Alloc> * x)
operator =	stl_set.h	/^  set<Key, Compare, Alloc>& operator=(const set<Key, Compare, Alloc>& x) { $/;"	f	class:set	access:public	signature:(const set<Key, Compare, Alloc>& x)
operator =	stl_slist.h	/^  slist& operator= (const slist& L);$/;"	p	class:slist	access:public	signature:(const slist& L)
operator =	stl_slist.h	/^slist<T, Alloc>& slist<T,Alloc>::operator=(const slist<T, Alloc>& L)$/;"	f	class:slist	signature:(const slist<T, Alloc>& L)
operator =	stl_tempbuf.h	/^  void operator=(const temporary_buffer&) {}$/;"	f	class:temporary_buffer	access:private	signature:(const temporary_buffer&)
operator =	stl_tree.h	/^  operator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x);$/;"	p	class:rb_tree	access:public	signature:(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x)
operator =	stl_tree.h	/^operator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) {$/;"	f	class:rb_tree	signature:(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x)
operator =	stl_vector.h	/^  vector<T, Alloc>& operator=(const vector<T, Alloc>& x);$/;"	p	class:vector	access:public	signature:(const vector<T, Alloc>& x)
operator =	stl_vector.h	/^vector<T, Alloc>& vector<T, Alloc>::operator=(const vector<T, Alloc>& x) {$/;"	f	class:vector	signature:(const vector<T, Alloc>& x)
operator ==	stl_bvector.h	/^  bool operator==(const __bit_reference& x) const {$/;"	f	struct:__bit_reference	access:public	signature:(const __bit_reference& x) const
operator ==	stl_bvector.h	/^  bool operator==(const const_iterator& x) const {$/;"	f	struct:__bit_const_iterator	access:public	signature:(const const_iterator& x) const
operator ==	stl_bvector.h	/^  bool operator==(const iterator& x) const {$/;"	f	struct:__bit_iterator	access:public	signature:(const iterator& x) const
operator ==	stl_bvector.h	/^inline bool operator==(const bit_vector& x, const bit_vector& y) {$/;"	f	signature:(const bit_vector& x, const bit_vector& y)
operator ==	stl_deque.h	/^  bool operator==(const deque<T, Alloc, 0>& x) const {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const deque<T, Alloc, 0>& x) const
operator ==	stl_deque.h	/^  bool operator==(const self& x) const { return cur == x.cur; }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(const self& x) const
operator ==	stl_deque.h	/^bool operator==(const deque<T, Alloc, BufSiz>& x,$/;"	f	struct:__deque_iterator	access:public	signature:(const deque<T, Alloc, BufSiz>& x, const deque<T, Alloc, BufSiz>& y)
operator ==	stl_hash_map.h	/^inline bool operator==(const hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,$/;"	f	signature:(const hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1, const hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm2)
operator ==	stl_hash_map.h	/^inline bool operator==(const hash_multimap<Key, T, HF, EqKey, Alloc>& hm1,$/;"	f	signature:(const hash_multimap<Key, T, HF, EqKey, Alloc>& hm1, const hash_multimap<Key, T, HF, EqKey, Alloc>& hm2)
operator ==	stl_hash_set.h	/^inline bool operator==(const hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs1,$/;"	f	signature:(const hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs1, const hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs2)
operator ==	stl_hash_set.h	/^inline bool operator==(const hash_set<Value, HashFcn, EqualKey, Alloc>& hs1,$/;"	f	signature:(const hash_set<Value, HashFcn, EqualKey, Alloc>& hs1, const hash_set<Value, HashFcn, EqualKey, Alloc>& hs2)
operator ==	stl_hashtable.h	/^  bool operator==(const const_iterator& it) const { return cur == it.cur; }$/;"	f	struct:__hashtable_const_iterator	access:public	signature:(const const_iterator& it) const
operator ==	stl_hashtable.h	/^  bool operator==(const iterator& it) const { return cur == it.cur; }$/;"	f	struct:__hashtable_iterator	access:public	signature:(const iterator& it) const
operator ==	stl_hashtable.h	/^bool operator==(const hashtable<V, K, HF, Ex, Eq, A>& ht1,$/;"	f	signature:(const hashtable<V, K, HF, Ex, Eq, A>& ht1, const hashtable<V, K, HF, Ex, Eq, A>& ht2)
operator ==	stl_iterator.h	/^inline bool operator==($/;"	f	signature:( const reverse_bidirectional_iterator<BidirectionalIterator, T, Reference, Distance>& x, const reverse_bidirectional_iterator<BidirectionalIterator, T, Reference, Distance>& y)
operator ==	stl_iterator.h	/^inline bool operator==(const istream_iterator<T, Distance>& x,$/;"	f	signature:(const istream_iterator<T, Distance>& x, const istream_iterator<T, Distance>& y)
operator ==	stl_iterator.h	/^inline bool operator==(const reverse_iterator<Iterator>& x, $/;"	f	signature:(const reverse_iterator<Iterator>& x, const reverse_iterator<Iterator>& y)
operator ==	stl_iterator.h	/^inline bool operator==(const reverse_iterator<RandomAccessIterator, T,$/;"	f	signature:(const reverse_iterator<RandomAccessIterator, T, Reference, Distance>& x, const reverse_iterator<RandomAccessIterator, T, Reference, Distance>& y)
operator ==	stl_list.h	/^  bool operator==(const self& x) const { return node == x.node; }$/;"	f	struct:__list_iterator	access:public	signature:(const self& x) const
operator ==	stl_list.h	/^inline bool operator==(const list<T,Alloc>& x, const list<T,Alloc>& y) {$/;"	f	signature:(const list<T,Alloc>& x, const list<T,Alloc>& y)
operator ==	stl_map.h	/^inline bool operator==(const map<Key, T, Compare, Alloc>& x, $/;"	f	signature:(const map<Key, T, Compare, Alloc>& x, const map<Key, T, Compare, Alloc>& y)
operator ==	stl_multimap.h	/^inline bool operator==(const multimap<Key, T, Compare, Alloc>& x, $/;"	f	signature:(const multimap<Key, T, Compare, Alloc>& x, const multimap<Key, T, Compare, Alloc>& y)
operator ==	stl_multiset.h	/^inline bool operator==(const multiset<Key, Compare, Alloc>& x, $/;"	f	signature:(const multiset<Key, Compare, Alloc>& x, const multiset<Key, Compare, Alloc>& y)
operator ==	stl_pair.h	/^inline bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y) { $/;"	f	signature:(const pair<T1, T2>& x, const pair<T1, T2>& y)
operator ==	stl_queue.h	/^bool operator==(const queue<T, Sequence>& x, const queue<T, Sequence>& y) {$/;"	f	signature:(const queue<T, Sequence>& x, const queue<T, Sequence>& y)
operator ==	stl_rope.h	/^inline bool operator== (const __rope_charT_ptr_proxy<charT,Alloc> & x,$/;"	f	signature:(const __rope_charT_ptr_proxy<charT,Alloc> & x, const __rope_charT_ptr_proxy<charT,Alloc> & y)
operator ==	stl_rope.h	/^inline bool operator== (const __rope_const_iterator<charT,Alloc> & x,$/;"	f	signature:(const __rope_const_iterator<charT,Alloc> & x, const __rope_const_iterator<charT,Alloc> & y)
operator ==	stl_rope.h	/^inline bool operator== (const __rope_iterator<charT,Alloc> & x,$/;"	f	signature:(const __rope_iterator<charT,Alloc> & x, const __rope_iterator<charT,Alloc> & y)
operator ==	stl_rope.h	/^operator== (const rope<charT,Alloc> &left, const rope<charT,Alloc> &right) {$/;"	f	signature:(const rope<charT,Alloc> &left, const rope<charT,Alloc> &right)
operator ==	stl_set.h	/^inline bool operator==(const set<Key, Compare, Alloc>& x, $/;"	f	signature:(const set<Key, Compare, Alloc>& x, const set<Key, Compare, Alloc>& y)
operator ==	stl_slist.h	/^  bool operator==(const __slist_iterator_base& x) const {$/;"	f	struct:__slist_iterator_base	access:public	signature:(const __slist_iterator_base& x) const
operator ==	stl_slist.h	/^bool operator==(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)$/;"	f	signature:(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)
operator ==	stl_stack.h	/^bool operator==(const stack<T, Sequence>& x, const stack<T, Sequence>& y) {$/;"	f	signature:(const stack<T, Sequence>& x, const stack<T, Sequence>& y)
operator ==	stl_tree.h	/^inline bool operator==(const __rb_tree_base_iterator& x,$/;"	f	signature:(const __rb_tree_base_iterator& x, const __rb_tree_base_iterator& y)
operator ==	stl_tree.h	/^inline bool operator==(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, $/;"	f	signature:(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& y)
operator ==	stl_vector.h	/^inline bool operator==(const vector<T, Alloc>& x, const vector<T, Alloc>& y) {$/;"	f	signature:(const vector<T, Alloc>& x, const vector<T, Alloc>& y)
operator >	stl_relops.h	/^inline bool operator>(const T& x, const T& y) {$/;"	f	signature:(const T& x, const T& y)
operator >=	stl_relops.h	/^inline bool operator>=(const T& x, const T& y) {$/;"	f	signature:(const T& x, const T& y)
operator []	stl_bvector.h	/^  const_reference operator[](difference_type i) { $/;"	f	struct:__bit_const_iterator	access:public	signature:(difference_type i)
operator []	stl_bvector.h	/^  const_reference operator[](size_type n) const {$/;"	f	class:vector	access:public	signature:(size_type n) const
operator []	stl_bvector.h	/^  reference operator[](difference_type i) { return *(*this + i); }$/;"	f	struct:__bit_iterator	access:public	signature:(difference_type i)
operator []	stl_bvector.h	/^  reference operator[](size_type n) {$/;"	f	class:vector	access:public	signature:(size_type n)
operator []	stl_deque.h	/^  const_reference operator[](size_type n) const {$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type n) const
operator []	stl_deque.h	/^  reference operator[](difference_type n) const { return *(*this + n); }$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(difference_type n) const
operator []	stl_deque.h	/^  reference operator[](size_type n) { return start[difference_type(n)]; }$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type n)
operator []	stl_hash_map.h	/^  T& operator[](const key_type& key) {$/;"	f	class:hash_map	access:public	signature:(const key_type& key)
operator []	stl_iterator.h	/^  Reference operator[](Distance n) const { return *(*this + n); }$/;"	f	class:reverse_iterator	access:public	signature:(Distance n) const
operator []	stl_iterator.h	/^  reference operator[](difference_type n) const { return *(*this + n); }  $/;"	f	class:reverse_iterator	access:public	signature:(difference_type n) const
operator []	stl_map.h	/^  T& operator[](const key_type& k) {$/;"	f	class:map	access:public	signature:(const key_type& k)
operator []	stl_rope.h	/^	    reference operator[] (size_type pos) {$/;"	f	class:rope	access:public	signature:(size_type pos)
operator []	stl_rope.h	/^	charT operator[] (size_type pos) const {$/;"	f	class:rope	access:public	signature:(size_type pos) const
operator []	stl_rope.h	/^    reference operator[](ptrdiff_t n) {$/;"	f	class:__rope_iterator	access:public	signature:(ptrdiff_t n)
operator []	stl_rope.h	/^    reference operator[](size_t n) {$/;"	f	class:__rope_const_iterator	access:public	signature:(size_t n)
operator []	stl_vector.h	/^  const_reference operator[](size_type n) const { return *(begin() + n); }$/;"	f	class:vector	access:public	signature:(size_type n) const
operator []	stl_vector.h	/^  reference operator[](size_type n) { return *(begin() + n); }$/;"	f	class:vector	access:public	signature:(size_type n)
operator __rope_RopeBase<charT,Alloc> *	stl_rope.h	/^    operator __rope_RopeBase<charT,Alloc> *() { return ptr; }$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:()
operator bool	stl_bvector.h	/^  operator bool() const { return !(!(*p & mask)); }$/;"	f	struct:__bit_reference	access:public	signature:() const
operator charT	ropeimpl.h	/^inline __rope_charT_ref_proxy<charT, Alloc>::operator charT () const$/;"	f	class:__rope_charT_ref_proxy	signature:() const
operator charT	stl_rope.h	/^    operator charT () const;$/;"	p	class:__rope_charT_ref_proxy	access:public	signature:() const
original_len	stl_tempbuf.h	/^  ptrdiff_t original_len;$/;"	m	class:temporary_buffer	access:private
ostream_iterator	stl_iterator.h	/^  ostream_iterator(ostream& s) : stream(&s), string(0) {}$/;"	f	class:ostream_iterator	access:public	signature:(ostream& s)
ostream_iterator	stl_iterator.h	/^  ostream_iterator(ostream& s, const char* c) : stream(&s), string(c)  {}$/;"	f	class:ostream_iterator	access:public	signature:(ostream& s, const char* c)
ostream_iterator	stl_iterator.h	/^class ostream_iterator {$/;"	c
ostream_iterator::difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:ostream_iterator	access:public
ostream_iterator::iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:ostream_iterator	access:public
ostream_iterator::operator *	stl_iterator.h	/^  ostream_iterator<T>& operator*() { return *this; }$/;"	f	class:ostream_iterator	access:public	signature:()
ostream_iterator::operator ++	stl_iterator.h	/^  ostream_iterator<T>& operator++() { return *this; } $/;"	f	class:ostream_iterator	access:public	signature:()
ostream_iterator::operator ++	stl_iterator.h	/^  ostream_iterator<T>& operator++(int) { return *this; } $/;"	f	class:ostream_iterator	access:public	signature:(int)
ostream_iterator::operator =	stl_iterator.h	/^  ostream_iterator<T>& operator=(const T& value) { $/;"	f	class:ostream_iterator	access:public	signature:(const T& value)
ostream_iterator::ostream_iterator	stl_iterator.h	/^  ostream_iterator(ostream& s) : stream(&s), string(0) {}$/;"	f	class:ostream_iterator	access:public	signature:(ostream& s)
ostream_iterator::ostream_iterator	stl_iterator.h	/^  ostream_iterator(ostream& s, const char* c) : stream(&s), string(c)  {}$/;"	f	class:ostream_iterator	access:public	signature:(ostream& s, const char* c)
ostream_iterator::pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:ostream_iterator	access:public
ostream_iterator::reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	class:ostream_iterator	access:public
ostream_iterator::stream	stl_iterator.h	/^  ostream* stream;$/;"	m	class:ostream_iterator	access:protected
ostream_iterator::string	stl_iterator.h	/^  const char* string;$/;"	m	class:ostream_iterator	access:protected
ostream_iterator::value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:ostream_iterator	access:public
output_iterator	stl_iterator.h	/^struct output_iterator {$/;"	s
output_iterator::difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	struct:output_iterator	access:public
output_iterator::iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	struct:output_iterator	access:public
output_iterator::pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	struct:output_iterator	access:public
output_iterator::reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	struct:output_iterator	access:public
output_iterator::value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	struct:output_iterator	access:public
output_iterator_tag	stl_iterator.h	/^struct output_iterator_tag {};$/;"	s
p	stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_const_iterator	access:public
p	stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_iterator	access:public
p	stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_reference	access:public
pair	stl_pair.h	/^  pair() : first(T1()), second(T2()) {}$/;"	f	struct:pair	access:public	signature:()
pair	stl_pair.h	/^  pair(const T1& a, const T2& b) : first(a), second(b) {}$/;"	f	struct:pair	access:public	signature:(const T1& a, const T2& b)
pair	stl_pair.h	/^  pair(const pair<U1, U2>& p) : first(p.first), second(p.second) {}$/;"	f	struct:pair	access:public	signature:(const pair<U1, U2>& p)
pair	stl_pair.h	/^struct pair {$/;"	s
pair::first	stl_pair.h	/^  T1 first;$/;"	m	struct:pair	access:public
pair::first_type	stl_pair.h	/^  typedef T1 first_type;$/;"	t	struct:pair	access:public
pair::pair	stl_pair.h	/^  pair() : first(T1()), second(T2()) {}$/;"	f	struct:pair	access:public	signature:()
pair::pair	stl_pair.h	/^  pair(const T1& a, const T2& b) : first(a), second(b) {}$/;"	f	struct:pair	access:public	signature:(const T1& a, const T2& b)
pair::pair	stl_pair.h	/^  pair(const pair<U1, U2>& p) : first(p.first), second(p.second) {}$/;"	f	struct:pair	access:public	signature:(const pair<U1, U2>& p)
pair::second	stl_pair.h	/^  T2 second;$/;"	m	struct:pair	access:public
pair::second_type	stl_pair.h	/^  typedef T2 second_type;$/;"	t	struct:pair	access:public
pair_iterator_bool	stl_set.h	/^  typedef  pair<iterator, bool> pair_iterator_bool; $/;"	t	class:set	access:public
parent	stl_tree.h	/^  base_ptr parent;$/;"	m	struct:__rb_tree_node_base	access:public
parent	stl_tree.h	/^  static link_type& parent(base_ptr x) { return (link_type&)(x->parent); }$/;"	f	class:rb_tree	access:protected	signature:(base_ptr x)
parent	stl_tree.h	/^  static link_type& parent(link_type x) { return (link_type&)(x->parent); }$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
partial_sort	stl_algo.h	/^inline void partial_sort(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last)
partial_sort	stl_algo.h	/^inline void partial_sort(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp)
partial_sort_copy	stl_algo.h	/^partial_sort_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last)
partial_sort_copy	stl_algo.h	/^partial_sort_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp)
partial_sum	stl_numeric.h	/^OutputIterator partial_sum(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result)
partial_sum	stl_numeric.h	/^OutputIterator partial_sum(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op)
partition	stl_algo.h	/^BidirectionalIterator partition(BidirectionalIterator first,$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator last, Predicate pred)
path_cache_len	stl_rope.h	/^    enum { path_cache_len = 4 }; \/\/ Must be <= 9.$/;"	e	enum:__rope_iterator_base::__anon11
path_directions	stl_rope.h	/^    unsigned char path_directions;$/;"	m	class:__rope_iterator_base	access:protected
path_end	stl_rope.h	/^    const RopeBase * path_end[path_cache_len];$/;"	m	class:__rope_iterator_base	access:protected
pattern	ropeimpl.h	/^	charT pattern;$/;"	m	class:__rope_find_char_char_consumer	access:private
plus	stl_function.h	/^struct plus : public binary_function<T, T, T> {$/;"	s	inherits:binary_function
plus::operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x + y; }$/;"	f	struct:plus	access:public	signature:(const T& x, const T& y) const
pointer	defalloc.h	/^    typedef T* pointer;$/;"	t	class:allocator	access:public
pointer	defalloc.h	/^    typedef void* pointer;$/;"	t	class:allocator	access:public
pointer	stl_bvector.h	/^  typedef __bit_reference* pointer;$/;"	t	class:vector	access:public
pointer	stl_bvector.h	/^  typedef __bit_reference* pointer;$/;"	t	struct:__bit_iterator	access:public
pointer	stl_bvector.h	/^  typedef const bool*          pointer;$/;"	t	struct:__bit_const_iterator	access:public
pointer	stl_deque.h	/^  typedef Ptr pointer;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
pointer	stl_deque.h	/^  typedef value_type* pointer;$/;"	t	class:__deque_iterator::deque	access:public
pointer	stl_hash_map.h	/^  typedef typename ht::pointer pointer;$/;"	t	class:hash_map	access:public
pointer	stl_hash_map.h	/^  typedef typename ht::pointer pointer;$/;"	t	class:hash_multimap	access:public
pointer	stl_hash_set.h	/^  typedef typename ht::const_pointer pointer;$/;"	t	class:hash_multiset	access:public
pointer	stl_hash_set.h	/^  typedef typename ht::const_pointer pointer;$/;"	t	class:hash_set	access:public
pointer	stl_hashtable.h	/^  typedef Value* pointer;$/;"	t	struct:__hashtable_iterator	access:public
pointer	stl_hashtable.h	/^  typedef const Value* pointer;$/;"	t	struct:__hashtable_const_iterator	access:public
pointer	stl_hashtable.h	/^  typedef value_type*       pointer;$/;"	t	class:hashtable	access:public
pointer	stl_iterator.h	/^          pointer;$/;"	t	class:reverse_iterator	access:public
pointer	stl_iterator.h	/^  typedef Pointer   pointer;$/;"	t	struct:iterator	access:public
pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	class:reverse_bidirectional_iterator	access:public
pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	class:reverse_iterator	access:public
pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:bidirectional_iterator	access:public
pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:iterator_traits	access:public
pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:random_access_iterator	access:public
pointer	stl_iterator.h	/^  typedef T*                   pointer;$/;"	t	struct:forward_iterator	access:public
pointer	stl_iterator.h	/^  typedef T*                 pointer;$/;"	t	struct:input_iterator	access:public
pointer	stl_iterator.h	/^  typedef const T*                   pointer;$/;"	t	struct:iterator_traits	access:public
pointer	stl_iterator.h	/^  typedef const T*           pointer;$/;"	t	class:istream_iterator	access:public
pointer	stl_iterator.h	/^  typedef typename Iterator::pointer           pointer;$/;"	t	struct:iterator_traits	access:public
pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:back_insert_iterator	access:public
pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:front_insert_iterator	access:public
pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:insert_iterator	access:public
pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:ostream_iterator	access:public
pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	struct:output_iterator	access:public
pointer	stl_list.h	/^  typedef Ptr pointer;$/;"	t	struct:__list_iterator	access:public
pointer	stl_list.h	/^  typedef value_type* pointer;$/;"	t	class:list	access:public
pointer	stl_map.h	/^  typedef typename rep_type::pointer pointer;$/;"	t	class:map	access:public
pointer	stl_multimap.h	/^  typedef typename rep_type::pointer pointer;$/;"	t	class:multimap	access:public
pointer	stl_multiset.h	/^  typedef typename rep_type::const_pointer pointer;$/;"	t	class:multiset	access:public
pointer	stl_raw_storage_iter.h	/^  typedef void                pointer;$/;"	t	class:raw_storage_iterator	access:public
pointer	stl_rope.h	/^	typedef __rope_charT_ptr_proxy<charT,Alloc> pointer;$/;"	t	class:rope	access:public
pointer	stl_rope.h	/^    typedef __rope_charT_ref_proxy<charT,Alloc>* pointer;$/;"	t	class:__rope_iterator	access:public
pointer	stl_rope.h	/^    typedef const charT* pointer;$/;"	t	class:__rope_const_iterator	access:public
pointer	stl_set.h	/^  typedef typename rep_type::const_pointer pointer;$/;"	t	class:set	access:public
pointer	stl_slist.h	/^  typedef Ptr pointer;$/;"	t	struct:__slist_iterator	access:public
pointer	stl_slist.h	/^  typedef value_type* pointer;$/;"	t	class:slist	access:public
pointer	stl_tree.h	/^  typedef Ptr pointer;$/;"	t	struct:__rb_tree_iterator	access:public
pointer	stl_tree.h	/^  typedef value_type* pointer;$/;"	t	class:rb_tree	access:public
pointer	stl_vector.h	/^  typedef value_type* pointer;$/;"	t	class:vector	access:public
pointer_to_binary_function	stl_function.h	/^    explicit pointer_to_binary_function(Result (*x)(Arg1, Arg2)) : ptr(x) {}$/;"	f	class:pointer_to_binary_function	access:public	signature:(Result (x)Arg1, Arg2))
pointer_to_binary_function	stl_function.h	/^    pointer_to_binary_function() {}$/;"	f	class:pointer_to_binary_function	access:public	signature:()
pointer_to_binary_function	stl_function.h	/^class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result> {$/;"	c	inherits:binary_function
pointer_to_binary_function::operator ()	stl_function.h	/^    Result operator()(Arg1 x, Arg2 y) const { return ptr(x, y); }$/;"	f	class:pointer_to_binary_function	access:public	signature:(Arg1 x, Arg2 y) const
pointer_to_binary_function::pointer_to_binary_function	stl_function.h	/^    explicit pointer_to_binary_function(Result (*x)(Arg1, Arg2)) : ptr(x) {}$/;"	f	class:pointer_to_binary_function	access:public	signature:(Result (x)Arg1, Arg2))
pointer_to_binary_function::pointer_to_binary_function	stl_function.h	/^    pointer_to_binary_function() {}$/;"	f	class:pointer_to_binary_function	access:public	signature:()
pointer_to_binary_function::ptr	stl_function.h	/^    Result (*ptr)(Arg1, Arg2);$/;"	m	class:pointer_to_binary_function	access:protected
pointer_to_unary_function	stl_function.h	/^  explicit pointer_to_unary_function(Result (*x)(Arg)) : ptr(x) {}$/;"	f	class:pointer_to_unary_function	access:public	signature:(Result (x)Arg))
pointer_to_unary_function	stl_function.h	/^  pointer_to_unary_function() {}$/;"	f	class:pointer_to_unary_function	access:public	signature:()
pointer_to_unary_function	stl_function.h	/^class pointer_to_unary_function : public unary_function<Arg, Result> {$/;"	c	inherits:unary_function
pointer_to_unary_function::operator ()	stl_function.h	/^  Result operator()(Arg x) const { return ptr(x); }$/;"	f	class:pointer_to_unary_function	access:public	signature:(Arg x) const
pointer_to_unary_function::pointer_to_unary_function	stl_function.h	/^  explicit pointer_to_unary_function(Result (*x)(Arg)) : ptr(x) {}$/;"	f	class:pointer_to_unary_function	access:public	signature:(Result (x)Arg))
pointer_to_unary_function::pointer_to_unary_function	stl_function.h	/^  pointer_to_unary_function() {}$/;"	f	class:pointer_to_unary_function	access:public	signature:()
pointer_to_unary_function::ptr	stl_function.h	/^  Result (*ptr)(Arg);$/;"	m	class:pointer_to_unary_function	access:protected
pop	stl_queue.h	/^  void pop() { c.pop_front(); }$/;"	f	class:queue	access:public	signature:()
pop	stl_queue.h	/^  void pop() {$/;"	f	class:priority_queue	access:public	signature:()
pop	stl_stack.h	/^  void pop() { c.pop_back(); }$/;"	f	class:stack	access:public	signature:()
pop_back	stl_bvector.h	/^  void pop_back() { --finish; }$/;"	f	class:vector	access:public	signature:()
pop_back	stl_deque.h	/^  void pop_back() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
pop_back	stl_list.h	/^  void pop_back() { $/;"	f	class:list	access:public	signature:()
pop_back	stl_rope.h	/^	void pop_back()$/;"	f	class:rope	access:public	signature:()
pop_back	stl_vector.h	/^  void pop_back() {$/;"	f	class:vector	access:public	signature:()
pop_back_aux	stl_deque.h	/^  void pop_back_aux();$/;"	p	class:__deque_iterator::deque	access:protected	signature:()
pop_back_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>:: pop_back_aux() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
pop_front	stl_deque.h	/^  void pop_front() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
pop_front	stl_list.h	/^  void pop_front() { erase(begin()); }$/;"	f	class:list	access:public	signature:()
pop_front	stl_rope.h	/^	void pop_front()$/;"	f	class:rope	access:public	signature:()
pop_front	stl_slist.h	/^  void pop_front() {$/;"	f	class:slist	access:public	signature:()
pop_front_aux	stl_deque.h	/^  void pop_front_aux();$/;"	p	class:__deque_iterator::deque	access:protected	signature:()
pop_front_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::pop_front_aux() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
pop_heap	stl_heap.h	/^inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last)
pop_heap	stl_heap.h	/^inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
pos	stl_rope.h	/^    size_t pos;$/;"	m	class:__rope_charT_ptr_proxy	access:private
pos	stl_rope.h	/^    size_t pos;$/;"	m	class:__rope_charT_ref_proxy	access:private
power	stl_numeric.h	/^T power(T x, Integer n, MonoidOperation op) {$/;"	f	signature:(T x, Integer n, MonoidOperation op)
power	stl_numeric.h	/^inline T power(T x, Integer n) {$/;"	f	signature:(T x, Integer n)
pred	stl_function.h	/^  Predicate pred;$/;"	m	class:binary_negate	access:protected
pred	stl_function.h	/^  Predicate pred;$/;"	m	class:unary_negate	access:protected
prefix	stl_rope.h	/^	sequence *prefix;$/;"	m	class:sequence_buffer	access:protected
prev	stl_list.h	/^  void_pointer prev;$/;"	m	struct:__list_node	access:public
prev_permutation	stl_algo.h	/^bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last,$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator last, Compare comp)
prev_permutation	stl_algo.h	/^bool prev_permutation(BidirectionalIterator first,$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator last)
previous	stl_slist.h	/^  const_iterator previous(const_iterator pos) const {$/;"	f	class:slist	access:public	signature:(const_iterator pos) const
previous	stl_slist.h	/^  iterator previous(const_iterator pos) {$/;"	f	class:slist	access:public	signature:(const_iterator pos)
priority_queue	stl_queue.h	/^  explicit priority_queue(const Compare& x) :  c(), comp(x) {}$/;"	f	class:priority_queue	access:public	signature:(const Compare& x)
priority_queue	stl_queue.h	/^  priority_queue() : c() {}$/;"	f	class:priority_queue	access:public	signature:()
priority_queue	stl_queue.h	/^  priority_queue(InputIterator first, InputIterator last) $/;"	f	class:priority_queue	access:public	signature:(InputIterator first, InputIterator last)
priority_queue	stl_queue.h	/^  priority_queue(InputIterator first, InputIterator last, const Compare& x)$/;"	f	class:priority_queue	access:public	signature:(InputIterator first, InputIterator last, const Compare& x)
priority_queue	stl_queue.h	/^  priority_queue(const value_type* first, const value_type* last) $/;"	f	class:priority_queue	access:public	signature:(const value_type* first, const value_type* last)
priority_queue	stl_queue.h	/^  priority_queue(const value_type* first, const value_type* last, $/;"	f	class:priority_queue	access:public	signature:(const value_type* first, const value_type* last, const Compare& x)
priority_queue	stl_queue.h	/^class  priority_queue {$/;"	c
priority_queue::c	stl_queue.h	/^  Sequence c;$/;"	m	class:priority_queue	access:protected
priority_queue::comp	stl_queue.h	/^  Compare comp;$/;"	m	class:priority_queue	access:protected
priority_queue::const_reference	stl_queue.h	/^  typedef typename Sequence::const_reference const_reference;$/;"	t	class:priority_queue	access:public
priority_queue::empty	stl_queue.h	/^  bool empty() const { return c.empty(); }$/;"	f	class:priority_queue	access:public	signature:() const
priority_queue::pop	stl_queue.h	/^  void pop() {$/;"	f	class:priority_queue	access:public	signature:()
priority_queue::priority_queue	stl_queue.h	/^  explicit priority_queue(const Compare& x) :  c(), comp(x) {}$/;"	f	class:priority_queue	access:public	signature:(const Compare& x)
priority_queue::priority_queue	stl_queue.h	/^  priority_queue() : c() {}$/;"	f	class:priority_queue	access:public	signature:()
priority_queue::priority_queue	stl_queue.h	/^  priority_queue(InputIterator first, InputIterator last) $/;"	f	class:priority_queue	access:public	signature:(InputIterator first, InputIterator last)
priority_queue::priority_queue	stl_queue.h	/^  priority_queue(InputIterator first, InputIterator last, const Compare& x)$/;"	f	class:priority_queue	access:public	signature:(InputIterator first, InputIterator last, const Compare& x)
priority_queue::priority_queue	stl_queue.h	/^  priority_queue(const value_type* first, const value_type* last) $/;"	f	class:priority_queue	access:public	signature:(const value_type* first, const value_type* last)
priority_queue::priority_queue	stl_queue.h	/^  priority_queue(const value_type* first, const value_type* last, $/;"	f	class:priority_queue	access:public	signature:(const value_type* first, const value_type* last, const Compare& x)
priority_queue::push	stl_queue.h	/^  void push(const value_type& x) {$/;"	f	class:priority_queue	access:public	signature:(const value_type& x)
priority_queue::reference	stl_queue.h	/^  typedef typename Sequence::reference reference;$/;"	t	class:priority_queue	access:public
priority_queue::size	stl_queue.h	/^  size_type size() const { return c.size(); }$/;"	f	class:priority_queue	access:public	signature:() const
priority_queue::size_type	stl_queue.h	/^  typedef typename Sequence::size_type size_type;$/;"	t	class:priority_queue	access:public
priority_queue::top	stl_queue.h	/^  const_reference top() const { return c.front(); }$/;"	f	class:priority_queue	access:public	signature:() const
priority_queue::value_type	stl_queue.h	/^  typedef typename Sequence::value_type value_type;$/;"	t	class:priority_queue	access:public
project1st	stl_function.h	/^struct project1st : public binary_function<Arg1, Arg2, Arg1> {$/;"	s	inherits:binary_function
project1st::operator ()	stl_function.h	/^  Arg1 operator()(const Arg1& x, const Arg2&) const { return x; }$/;"	f	struct:project1st	access:public	signature:(const Arg1& x, const Arg2&) const
project2nd	stl_function.h	/^struct project2nd : public binary_function<Arg1, Arg2, Arg2> {$/;"	s	inherits:binary_function
project2nd::operator ()	stl_function.h	/^  Arg2 operator()(const Arg1&, const Arg2& y) const { return y; }$/;"	f	struct:project2nd	access:public	signature:(const Arg1&, const Arg2& y) const
ptr	stl_function.h	/^    Result (*ptr)(Arg1, Arg2);$/;"	m	class:pointer_to_binary_function	access:protected
ptr	stl_function.h	/^  Result (*ptr)(Arg);$/;"	m	class:pointer_to_unary_function	access:protected
ptr	stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * ptr;$/;"	m	struct:__rope_self_destruct_ptr	access:public
ptr_fun	stl_function.h	/^inline pointer_to_unary_function<Arg, Result> ptr_fun(Result (*x)(Arg)) {$/;"	f	signature:(Result (x)Arg))
ptr_fun	stl_function.h	/^ptr_fun(Result (*x)(Arg1, Arg2)) {$/;"	f	signature:(Result (x)Arg1, Arg2))
push	stl_queue.h	/^  void push(const value_type& x) { c.push_back(x); }$/;"	f	class:queue	access:public	signature:(const value_type& x)
push	stl_queue.h	/^  void push(const value_type& x) {$/;"	f	class:priority_queue	access:public	signature:(const value_type& x)
push	stl_stack.h	/^  void push(const value_type& x) { c.push_back(x); }$/;"	f	class:stack	access:public	signature:(const value_type& x)
push_back	stl_bvector.h	/^  void push_back(bool x) {$/;"	f	class:vector	access:public	signature:(bool x)
push_back	stl_deque.h	/^  void push_back(const value_type& t) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const value_type& t)
push_back	stl_list.h	/^  void push_back(const T& x) { insert(end(), x); }$/;"	f	class:list	access:public	signature:(const T& x)
push_back	stl_rope.h	/^	void push_back(charT x)$/;"	f	class:rope	access:public	signature:(charT x)
push_back	stl_rope.h	/^	void push_back(value_type x)$/;"	f	class:sequence_buffer	access:public	signature:(value_type x)
push_back	stl_vector.h	/^  void push_back(const T& x) {$/;"	f	class:vector	access:public	signature:(const T& x)
push_back_aux	stl_deque.h	/^  void push_back_aux(const value_type& t);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(const value_type& t)
push_back_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::push_back_aux(const value_type& t) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const value_type& t)
push_front	stl_deque.h	/^  void push_front(const value_type& t) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const value_type& t)
push_front	stl_list.h	/^  void push_front(const T& x) { insert(begin(), x); }$/;"	f	class:list	access:public	signature:(const T& x)
push_front	stl_rope.h	/^	void push_front(charT x)$/;"	f	class:rope	access:public	signature:(charT x)
push_front	stl_slist.h	/^  void push_front(const value_type& x)   {$/;"	f	class:slist	access:public	signature:(const value_type& x)
push_front_aux	stl_deque.h	/^  void push_front_aux(const value_type& t);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(const value_type& t)
push_front_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::push_front_aux(const value_type& t) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(const value_type& t)
push_heap	stl_heap.h	/^inline void push_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last)
push_heap	stl_heap.h	/^inline void push_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
put	stl_rope.h	/^	sequence_buffer& put(value_type x)$/;"	f	class:sequence_buffer	access:public	signature:(value_type x)
put_node	stl_list.h	/^  void put_node(link_type p) { list_node_allocator::deallocate(p); }$/;"	f	class:list	access:protected	signature:(link_type p)
put_node	stl_tree.h	/^  void put_node(link_type p) { rb_tree_node_allocator::deallocate(p); }$/;"	f	class:rb_tree	access:protected	signature:(link_type p)
queue	stl_queue.h	/^class queue {$/;"	c
queue::__STL_NULL_TMPL_ARGS	stl_queue.h	/^  friend bool operator< __STL_NULL_TMPL_ARGS (const queue& x, const queue& y);$/;"	p	class:queue	access:friend	signature:(const queue& x, const queue& y)
queue::__STL_NULL_TMPL_ARGS	stl_queue.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const queue& x, const queue& y);$/;"	p	class:queue	access:friend	signature:(const queue& x, const queue& y)
queue::back	stl_queue.h	/^  const_reference back() const { return c.back(); }$/;"	f	class:queue	access:public	signature:() const
queue::back	stl_queue.h	/^  reference back() { return c.back(); }$/;"	f	class:queue	access:public	signature:()
queue::c	stl_queue.h	/^  Sequence c;$/;"	m	class:queue	access:protected
queue::const_reference	stl_queue.h	/^  typedef typename Sequence::const_reference const_reference;$/;"	t	class:queue	access:public
queue::empty	stl_queue.h	/^  bool empty() const { return c.empty(); }$/;"	f	class:queue	access:public	signature:() const
queue::front	stl_queue.h	/^  const_reference front() const { return c.front(); }$/;"	f	class:queue	access:public	signature:() const
queue::front	stl_queue.h	/^  reference front() { return c.front(); }$/;"	f	class:queue	access:public	signature:()
queue::pop	stl_queue.h	/^  void pop() { c.pop_front(); }$/;"	f	class:queue	access:public	signature:()
queue::push	stl_queue.h	/^  void push(const value_type& x) { c.push_back(x); }$/;"	f	class:queue	access:public	signature:(const value_type& x)
queue::reference	stl_queue.h	/^  typedef typename Sequence::reference reference;$/;"	t	class:queue	access:public
queue::size	stl_queue.h	/^  size_type size() const { return c.size(); }$/;"	f	class:queue	access:public	signature:() const
queue::size_type	stl_queue.h	/^  typedef typename Sequence::size_type size_type;$/;"	t	class:queue	access:public
queue::value_type	stl_queue.h	/^  typedef typename Sequence::value_type value_type;$/;"	t	class:queue	access:public
random_access_iterator	stl_iterator.h	/^template <class T, class Distance> struct random_access_iterator {$/;"	s
random_access_iterator::difference_type	stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	struct:random_access_iterator	access:public
random_access_iterator::iterator_category	stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	struct:random_access_iterator	access:public
random_access_iterator::pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:random_access_iterator	access:public
random_access_iterator::reference	stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:random_access_iterator	access:public
random_access_iterator::value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:random_access_iterator	access:public
random_access_iterator_tag	stl_iterator.h	/^struct random_access_iterator_tag : public bidirectional_iterator_tag {};$/;"	s	inherits:bidirectional_iterator_tag
random_sample	stl_algo.h	/^random_sample(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, RandomAccessIterator out_first, RandomAccessIterator out_last)
random_sample	stl_algo.h	/^random_sample(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, RandomAccessIterator out_first, RandomAccessIterator out_last, RandomNumberGenerator& rand)
random_sample_n	stl_algo.h	/^OutputIterator random_sample_n(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, OutputIterator out, const Distance n)
random_sample_n	stl_algo.h	/^OutputIterator random_sample_n(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, OutputIterator out, const Distance n, RandomNumberGenerator& rand)
random_shuffle	stl_algo.h	/^inline void random_shuffle(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last)
random_shuffle	stl_algo.h	/^void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator& rand)
range_initialize	stl_deque.h	/^  void range_initialize(ForwardIterator first, ForwardIterator last,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
range_initialize	stl_deque.h	/^  void range_initialize(InputIterator first, InputIterator last,$/;"	p	class:__deque_iterator::deque	access:protected	signature:(InputIterator first, InputIterator last, input_iterator_tag)
range_initialize	stl_deque.h	/^void deque<T, Alloc, BufSize>::range_initialize(ForwardIterator first,$/;"	f	class:__deque_iterator::deque	access:public	signature:(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
range_initialize	stl_deque.h	/^void deque<T, Alloc, BufSize>::range_initialize(InputIterator first,$/;"	f	class:__deque_iterator::deque	access:public	signature:(InputIterator first, InputIterator last, input_iterator_tag)
range_initialize	stl_list.h	/^  void range_initialize(InputIterator first, InputIterator last) {$/;"	f	class:list	access:protected	signature:(InputIterator first, InputIterator last)
range_initialize	stl_list.h	/^  void range_initialize(const T* first, const T* last) {$/;"	f	class:list	access:protected	signature:(const T* first, const T* last)
range_initialize	stl_list.h	/^  void range_initialize(const_iterator first, const_iterator last) {$/;"	f	class:list	access:protected	signature:(const_iterator first, const_iterator last)
range_initialize	stl_slist.h	/^  void range_initialize(InputIterator first, InputIterator last) {$/;"	f	class:slist	access:private	signature:(InputIterator first, InputIterator last)
range_initialize	stl_slist.h	/^  void range_initialize(const value_type* first, const value_type* last) {$/;"	f	class:slist	access:private	signature:(const value_type* first, const value_type* last)
range_initialize	stl_slist.h	/^  void range_initialize(const_iterator first, const_iterator last) {$/;"	f	class:slist	access:private	signature:(const_iterator first, const_iterator last)
range_initialize	stl_vector.h	/^  void range_initialize(ForwardIterator first, ForwardIterator last,$/;"	f	class:vector	access:protected	signature:(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
range_initialize	stl_vector.h	/^  void range_initialize(InputIterator first, InputIterator last,$/;"	f	class:vector	access:protected	signature:(InputIterator first, InputIterator last, input_iterator_tag)
range_insert	stl_vector.h	/^  void range_insert(iterator pos,$/;"	p	class:vector	access:protected	signature:(iterator pos, ForwardIterator first, ForwardIterator last, forward_iterator_tag)
range_insert	stl_vector.h	/^  void range_insert(iterator pos,$/;"	p	class:vector	access:protected	signature:(iterator pos, InputIterator first, InputIterator last, input_iterator_tag)
range_insert	stl_vector.h	/^void vector<T, Alloc>::range_insert(iterator pos,$/;"	f	class:vector	signature:(iterator pos, InputIterator first, InputIterator last, input_iterator_tag)
range_insert	stl_vector.h	/^void vector<T, Alloc>::range_insert(iterator position,$/;"	f	class:vector	signature:(iterator position, ForwardIterator first, ForwardIterator last, forward_iterator_tag)
raw_storage_iterator	stl_raw_storage_iter.h	/^  explicit raw_storage_iterator(ForwardIterator x) : iter(x) {}$/;"	f	class:raw_storage_iterator	access:public	signature:(ForwardIterator x)
raw_storage_iterator	stl_raw_storage_iter.h	/^class raw_storage_iterator {$/;"	c
raw_storage_iterator::difference_type	stl_raw_storage_iter.h	/^  typedef void                difference_type;$/;"	t	class:raw_storage_iterator	access:public
raw_storage_iterator::iter	stl_raw_storage_iter.h	/^  ForwardIterator iter;$/;"	m	class:raw_storage_iterator	access:protected
raw_storage_iterator::iterator_category	stl_raw_storage_iter.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:raw_storage_iterator	access:public
raw_storage_iterator::operator *	stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator*() { return *this; }$/;"	f	class:raw_storage_iterator	access:public	signature:()
raw_storage_iterator::operator ++	stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T> operator++(int) {$/;"	f	class:raw_storage_iterator	access:public	signature:(int)
raw_storage_iterator::operator ++	stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator++() {$/;"	f	class:raw_storage_iterator	access:public	signature:()
raw_storage_iterator::operator =	stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator=(const T& element) {$/;"	f	class:raw_storage_iterator	access:public	signature:(const T& element)
raw_storage_iterator::pointer	stl_raw_storage_iter.h	/^  typedef void                pointer;$/;"	t	class:raw_storage_iterator	access:public
raw_storage_iterator::raw_storage_iterator	stl_raw_storage_iter.h	/^  explicit raw_storage_iterator(ForwardIterator x) : iter(x) {}$/;"	f	class:raw_storage_iterator	access:public	signature:(ForwardIterator x)
raw_storage_iterator::reference	stl_raw_storage_iter.h	/^  typedef void                reference;$/;"	t	class:raw_storage_iterator	access:public
raw_storage_iterator::value_type	stl_raw_storage_iter.h	/^  typedef void                value_type;$/;"	t	class:raw_storage_iterator	access:public
rb_tree	stl_tree.h	/^  rb_tree(const Compare& comp = Compare())$/;"	f	class:rb_tree	access:public	signature:(const Compare& comp = Compare())
rb_tree	stl_tree.h	/^  rb_tree(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) $/;"	f	class:rb_tree	access:public	signature:(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x)
rb_tree	stl_tree.h	/^class rb_tree {$/;"	c
rb_tree::__copy	stl_tree.h	/^  link_type __copy(link_type x, link_type p);$/;"	p	class:rb_tree	access:private	signature:(link_type x, link_type p)
rb_tree::__copy	stl_tree.h	/^rb_tree<K, V, KeyOfValue, Compare, Alloc>::__copy(link_type x, link_type p) {$/;"	f	class:rb_tree	signature:(link_type x, link_type p)
rb_tree::__erase	stl_tree.h	/^  void __erase(link_type x);$/;"	p	class:rb_tree	access:private	signature:(link_type x)
rb_tree::__erase	stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__erase(link_type x) {$/;"	f	class:rb_tree	signature:(link_type x)
rb_tree::__insert	stl_tree.h	/^  iterator __insert(base_ptr x, base_ptr y, const value_type& v);$/;"	p	class:rb_tree	access:private	signature:(base_ptr x, base_ptr y, const value_type& v)
rb_tree::__insert	stl_tree.h	/^__insert(base_ptr x_, base_ptr y_, const Value& v) {$/;"	f	class:rb_tree	signature:(base_ptr x_, base_ptr y_, const Value& v)
rb_tree::__rb_verify	stl_tree.h	/^  bool __rb_verify() const;$/;"	p	class:rb_tree	access:public	signature:() const
rb_tree::__rb_verify	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__rb_verify() const$/;"	f	class:rb_tree	signature:() const
rb_tree::base_ptr	stl_tree.h	/^  typedef __rb_tree_node_base* base_ptr;$/;"	t	class:rb_tree	access:protected
rb_tree::begin	stl_tree.h	/^  const_iterator begin() const { return leftmost(); }$/;"	f	class:rb_tree	access:public	signature:() const
rb_tree::begin	stl_tree.h	/^  iterator begin() { return leftmost(); }$/;"	f	class:rb_tree	access:public	signature:()
rb_tree::clear	stl_tree.h	/^  void clear() {$/;"	f	class:rb_tree	access:public	signature:()
rb_tree::clone_node	stl_tree.h	/^  link_type clone_node(link_type x) {$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
rb_tree::color	stl_tree.h	/^  static color_type& color(base_ptr x) { return (color_type&)(link_type(x)->color); }$/;"	f	class:rb_tree	access:protected	signature:(base_ptr x)
rb_tree::color	stl_tree.h	/^  static color_type& color(link_type x) { return (color_type&)(x->color); }$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
rb_tree::color_type	stl_tree.h	/^  typedef __rb_tree_color_type color_type;$/;"	t	class:rb_tree	access:protected
rb_tree::const_iterator	stl_tree.h	/^          const_iterator;$/;"	t	class:rb_tree	access:public
rb_tree::const_pointer	stl_tree.h	/^  typedef const value_type* const_pointer;$/;"	t	class:rb_tree	access:public
rb_tree::const_reference	stl_tree.h	/^  typedef const value_type& const_reference;$/;"	t	class:rb_tree	access:public
rb_tree::const_reverse_iterator	stl_tree.h	/^          const_reverse_iterator;$/;"	t	class:rb_tree	access:public
rb_tree::const_reverse_iterator	stl_tree.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:rb_tree	access:public
rb_tree::count	stl_tree.h	/^  size_type count(const key_type& x) const;$/;"	p	class:rb_tree	access:public	signature:(const key_type& x) const
rb_tree::count	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::count(const Key& k) const {$/;"	f	class:rb_tree	signature:(const Key& k) const
rb_tree::create_node	stl_tree.h	/^  link_type create_node(const value_type& x) {$/;"	f	class:rb_tree	access:protected	signature:(const value_type& x)
rb_tree::destroy_node	stl_tree.h	/^  void destroy_node(link_type p) {$/;"	f	class:rb_tree	access:protected	signature:(link_type p)
rb_tree::difference_type	stl_tree.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:rb_tree	access:public
rb_tree::empty	stl_tree.h	/^  bool empty() const { return node_count == 0; }$/;"	f	class:rb_tree	access:public	signature:() const
rb_tree::end	stl_tree.h	/^  const_iterator end() const { return header; }$/;"	f	class:rb_tree	access:public	signature:() const
rb_tree::end	stl_tree.h	/^  iterator end() { return header; }$/;"	f	class:rb_tree	access:public	signature:()
rb_tree::equal_range	stl_tree.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& x) const;$/;"	p	class:rb_tree	access:public	signature:(const key_type& x) const
rb_tree::equal_range	stl_tree.h	/^  pair<iterator,iterator> equal_range(const key_type& x);$/;"	p	class:rb_tree	access:public	signature:(const key_type& x)
rb_tree::equal_range	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::equal_range(const Key& k) {$/;"	f	class:rb_tree	signature:(const Key& k)
rb_tree::equal_range	stl_tree.h	/^rb_tree<Key, Value, KoV, Compare, Alloc>::equal_range(const Key& k) const {$/;"	f	class:rb_tree	signature:(const Key& k) const
rb_tree::erase	stl_tree.h	/^  size_type erase(const key_type& x);$/;"	p	class:rb_tree	access:public	signature:(const key_type& x)
rb_tree::erase	stl_tree.h	/^  void erase(const key_type* first, const key_type* last);$/;"	p	class:rb_tree	access:public	signature:(const key_type* first, const key_type* last)
rb_tree::erase	stl_tree.h	/^  void erase(iterator first, iterator last);$/;"	p	class:rb_tree	access:public	signature:(iterator first, iterator last)
rb_tree::erase	stl_tree.h	/^  void erase(iterator position);$/;"	p	class:rb_tree	access:public	signature:(iterator position)
rb_tree::erase	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key& x) {$/;"	f	class:rb_tree	signature:(const Key& x)
rb_tree::erase	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator position) {$/;"	f	class:rb_tree	signature:(iterator position)
rb_tree::erase	stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key* first, $/;"	f	class:rb_tree	signature:(const Key* first, const Key* last)
rb_tree::erase	stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator first, $/;"	f	class:rb_tree	signature:(iterator first, iterator last)
rb_tree::find	stl_tree.h	/^  const_iterator find(const key_type& x) const;$/;"	p	class:rb_tree	access:public	signature:(const key_type& x) const
rb_tree::find	stl_tree.h	/^  iterator find(const key_type& x);$/;"	p	class:rb_tree	access:public	signature:(const key_type& x)
rb_tree::find	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) const {$/;"	f	class:rb_tree	signature:(const Key& k) const
rb_tree::find	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) {$/;"	f	class:rb_tree	signature:(const Key& k)
rb_tree::get_node	stl_tree.h	/^  link_type get_node() { return rb_tree_node_allocator::allocate(); }$/;"	f	class:rb_tree	access:protected	signature:()
rb_tree::header	stl_tree.h	/^  link_type header;  $/;"	m	class:rb_tree	access:protected
rb_tree::init	stl_tree.h	/^  void init() {$/;"	f	class:rb_tree	access:private	signature:()
rb_tree::insert_equal	stl_tree.h	/^  iterator insert_equal(const value_type& x);$/;"	p	class:rb_tree	access:public	signature:(const value_type& x)
rb_tree::insert_equal	stl_tree.h	/^  iterator insert_equal(iterator position, const value_type& x);$/;"	p	class:rb_tree	access:public	signature:(iterator position, const value_type& x)
rb_tree::insert_equal	stl_tree.h	/^  void insert_equal(InputIterator first, InputIterator last);$/;"	p	class:rb_tree	access:public	signature:(InputIterator first, InputIterator last)
rb_tree::insert_equal	stl_tree.h	/^  void insert_equal(const value_type* first, const value_type* last);$/;"	p	class:rb_tree	access:public	signature:(const value_type* first, const value_type* last)
rb_tree::insert_equal	stl_tree.h	/^  void insert_equal(const_iterator first, const_iterator last);$/;"	p	class:rb_tree	access:public	signature:(const_iterator first, const_iterator last)
rb_tree::insert_equal	stl_tree.h	/^rb_tree<K, V, KoV, Cmp, Al>::insert_equal(const V* first, const V* last) {$/;"	f	class:rb_tree	signature:(const V* first, const V* last)
rb_tree::insert_equal	stl_tree.h	/^rb_tree<K, V, KoV, Cmp, Al>::insert_equal(const_iterator first,$/;"	f	class:rb_tree	signature:(const_iterator first, const_iterator last)
rb_tree::insert_equal	stl_tree.h	/^rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_equal(iterator position,$/;"	f	class:rb_tree	signature:(iterator position, const Val& v)
rb_tree::insert_equal	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_equal(const Value& v)$/;"	f	class:rb_tree	signature:(const Value& v)
rb_tree::insert_equal	stl_tree.h	/^void rb_tree<K, V, KoV, Cmp, Al>::insert_equal(II first, II last) {$/;"	f	class:rb_tree	signature:(II first, II last)
rb_tree::insert_unique	stl_tree.h	/^  iterator insert_unique(iterator position, const value_type& x);$/;"	p	class:rb_tree	access:public	signature:(iterator position, const value_type& x)
rb_tree::insert_unique	stl_tree.h	/^  pair<iterator,bool> insert_unique(const value_type& x);$/;"	p	class:rb_tree	access:public	signature:(const value_type& x)
rb_tree::insert_unique	stl_tree.h	/^  void insert_unique(InputIterator first, InputIterator last);$/;"	p	class:rb_tree	access:public	signature:(InputIterator first, InputIterator last)
rb_tree::insert_unique	stl_tree.h	/^  void insert_unique(const value_type* first, const value_type* last);$/;"	p	class:rb_tree	access:public	signature:(const value_type* first, const value_type* last)
rb_tree::insert_unique	stl_tree.h	/^  void insert_unique(const_iterator first, const_iterator last);$/;"	p	class:rb_tree	access:public	signature:(const_iterator first, const_iterator last)
rb_tree::insert_unique	stl_tree.h	/^rb_tree<K, V, KoV, Cmp, A>::insert_unique(const V* first, const V* last) {$/;"	f	class:rb_tree	signature:(const V* first, const V* last)
rb_tree::insert_unique	stl_tree.h	/^rb_tree<K, V, KoV, Cmp, A>::insert_unique(const_iterator first,$/;"	f	class:rb_tree	signature:(const_iterator first, const_iterator last)
rb_tree::insert_unique	stl_tree.h	/^rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_unique(iterator position,$/;"	f	class:rb_tree	signature:(iterator position, const Val& v)
rb_tree::insert_unique	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_unique(const Value& v)$/;"	f	class:rb_tree	signature:(const Value& v)
rb_tree::insert_unique	stl_tree.h	/^void rb_tree<K, V, KoV, Cmp, Al>::insert_unique(II first, II last) {$/;"	f	class:rb_tree	signature:(II first, II last)
rb_tree::iterator	stl_tree.h	/^  typedef __rb_tree_iterator<value_type, reference, pointer> iterator;$/;"	t	class:rb_tree	access:public
rb_tree::key	stl_tree.h	/^  static const Key& key(base_ptr x) { return KeyOfValue()(value(link_type(x)));} $/;"	f	class:rb_tree	access:protected	signature:(base_ptr x)
rb_tree::key	stl_tree.h	/^  static const Key& key(link_type x) { return KeyOfValue()(value(x)); }$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
rb_tree::key_comp	stl_tree.h	/^  Compare key_comp() const { return key_compare; }$/;"	f	class:rb_tree	access:public	signature:() const
rb_tree::key_compare	stl_tree.h	/^  Compare key_compare;$/;"	m	class:rb_tree	access:protected
rb_tree::key_type	stl_tree.h	/^  typedef Key key_type;$/;"	t	class:rb_tree	access:public
rb_tree::left	stl_tree.h	/^  static link_type& left(base_ptr x) { return (link_type&)(x->left); }$/;"	f	class:rb_tree	access:protected	signature:(base_ptr x)
rb_tree::left	stl_tree.h	/^  static link_type& left(link_type x) { return (link_type&)(x->left); }$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
rb_tree::leftmost	stl_tree.h	/^  link_type& leftmost() const { return (link_type&) header->left; }$/;"	f	class:rb_tree	access:protected	signature:() const
rb_tree::link_type	stl_tree.h	/^  typedef rb_tree_node* link_type;$/;"	t	class:rb_tree	access:public
rb_tree::lower_bound	stl_tree.h	/^  const_iterator lower_bound(const key_type& x) const;$/;"	p	class:rb_tree	access:public	signature:(const key_type& x) const
rb_tree::lower_bound	stl_tree.h	/^  iterator lower_bound(const key_type& x);$/;"	p	class:rb_tree	access:public	signature:(const key_type& x)
rb_tree::lower_bound	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) const {$/;"	f	class:rb_tree	signature:(const Key& k) const
rb_tree::lower_bound	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) {$/;"	f	class:rb_tree	signature:(const Key& k)
rb_tree::max_size	stl_tree.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:rb_tree	access:public	signature:() const
rb_tree::maximum	stl_tree.h	/^  static link_type maximum(link_type x) {$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
rb_tree::minimum	stl_tree.h	/^  static link_type minimum(link_type x) { $/;"	f	class:rb_tree	access:protected	signature:(link_type x)
rb_tree::node_count	stl_tree.h	/^  size_type node_count; \/\/ keeps track of size of tree$/;"	m	class:rb_tree	access:protected
rb_tree::operator =	stl_tree.h	/^  operator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x);$/;"	p	class:rb_tree	access:public	signature:(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x)
rb_tree::operator =	stl_tree.h	/^operator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) {$/;"	f	class:rb_tree	signature:(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x)
rb_tree::parent	stl_tree.h	/^  static link_type& parent(base_ptr x) { return (link_type&)(x->parent); }$/;"	f	class:rb_tree	access:protected	signature:(base_ptr x)
rb_tree::parent	stl_tree.h	/^  static link_type& parent(link_type x) { return (link_type&)(x->parent); }$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
rb_tree::pointer	stl_tree.h	/^  typedef value_type* pointer;$/;"	t	class:rb_tree	access:public
rb_tree::put_node	stl_tree.h	/^  void put_node(link_type p) { rb_tree_node_allocator::deallocate(p); }$/;"	f	class:rb_tree	access:protected	signature:(link_type p)
rb_tree::rb_tree	stl_tree.h	/^  rb_tree(const Compare& comp = Compare())$/;"	f	class:rb_tree	access:public	signature:(const Compare& comp = Compare())
rb_tree::rb_tree	stl_tree.h	/^  rb_tree(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) $/;"	f	class:rb_tree	access:public	signature:(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x)
rb_tree::rb_tree_node	stl_tree.h	/^  typedef __rb_tree_node<Value> rb_tree_node;$/;"	t	class:rb_tree	access:protected
rb_tree::rb_tree_node_allocator	stl_tree.h	/^  typedef simple_alloc<rb_tree_node, Alloc> rb_tree_node_allocator;$/;"	t	class:rb_tree	access:protected
rb_tree::rbegin	stl_tree.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:rb_tree	access:public	signature:() const
rb_tree::rbegin	stl_tree.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:rb_tree	access:public	signature:()
rb_tree::reference	stl_tree.h	/^  typedef value_type& reference;$/;"	t	class:rb_tree	access:public
rb_tree::rend	stl_tree.h	/^  const_reverse_iterator rend() const { $/;"	f	class:rb_tree	access:public	signature:() const
rb_tree::rend	stl_tree.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:rb_tree	access:public	signature:()
rb_tree::reverse_iterator	stl_tree.h	/^          reverse_iterator; $/;"	t	class:rb_tree	access:public
rb_tree::reverse_iterator	stl_tree.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:rb_tree	access:public
rb_tree::right	stl_tree.h	/^  static link_type& right(base_ptr x) { return (link_type&)(x->right); }$/;"	f	class:rb_tree	access:protected	signature:(base_ptr x)
rb_tree::right	stl_tree.h	/^  static link_type& right(link_type x) { return (link_type&)(x->right); }$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
rb_tree::rightmost	stl_tree.h	/^  link_type& rightmost() const { return (link_type&) header->right; }$/;"	f	class:rb_tree	access:protected	signature:() const
rb_tree::root	stl_tree.h	/^  link_type& root() const { return (link_type&) header->parent; }$/;"	f	class:rb_tree	access:protected	signature:() const
rb_tree::size	stl_tree.h	/^  size_type size() const { return node_count; }$/;"	f	class:rb_tree	access:public	signature:() const
rb_tree::size_type	stl_tree.h	/^  typedef size_t size_type;$/;"	t	class:rb_tree	access:public
rb_tree::swap	stl_tree.h	/^  void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& t) {$/;"	f	class:rb_tree	access:public	signature:(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& t)
rb_tree::upper_bound	stl_tree.h	/^  const_iterator upper_bound(const key_type& x) const;$/;"	p	class:rb_tree	access:public	signature:(const key_type& x) const
rb_tree::upper_bound	stl_tree.h	/^  iterator upper_bound(const key_type& x);$/;"	p	class:rb_tree	access:public	signature:(const key_type& x)
rb_tree::upper_bound	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) const {$/;"	f	class:rb_tree	signature:(const Key& k) const
rb_tree::upper_bound	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) {$/;"	f	class:rb_tree	signature:(const Key& k)
rb_tree::value	stl_tree.h	/^  static reference value(base_ptr x) { return ((link_type)x)->value_field; }$/;"	f	class:rb_tree	access:protected	signature:(base_ptr x)
rb_tree::value	stl_tree.h	/^  static reference value(link_type x) { return x->value_field; }$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
rb_tree::value_type	stl_tree.h	/^  typedef Value value_type;$/;"	t	class:rb_tree	access:public
rb_tree::void_pointer	stl_tree.h	/^  typedef void* void_pointer;$/;"	t	class:rb_tree	access:protected
rb_tree::~rb_tree	stl_tree.h	/^  ~rb_tree() {$/;"	f	class:rb_tree	access:public	signature:()
rb_tree_node	stl_tree.h	/^  typedef __rb_tree_node<Value> rb_tree_node;$/;"	t	class:rb_tree	access:protected
rb_tree_node_allocator	stl_tree.h	/^  typedef simple_alloc<rb_tree_node, Alloc> rb_tree_node_allocator;$/;"	t	class:rb_tree	access:protected
rbegin	stl_bvector.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:vector	access:public	signature:() const
rbegin	stl_bvector.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:vector	access:public	signature:()
rbegin	stl_deque.h	/^  const_reverse_iterator rbegin() const {$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
rbegin	stl_deque.h	/^  reverse_iterator rbegin() { return reverse_iterator(finish); }$/;"	f	class:__deque_iterator::deque	access:public	signature:()
rbegin	stl_list.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:list	access:public	signature:() const
rbegin	stl_list.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:list	access:public	signature:()
rbegin	stl_map.h	/^  const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:map	access:public	signature:() const
rbegin	stl_map.h	/^  reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:map	access:public	signature:()
rbegin	stl_multimap.h	/^  const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:multimap	access:public	signature:() const
rbegin	stl_multimap.h	/^  reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:multimap	access:public	signature:()
rbegin	stl_multiset.h	/^  reverse_iterator rbegin() const { return t.rbegin(); } $/;"	f	class:multiset	access:public	signature:() const
rbegin	stl_rope.h	/^	    const_reverse_iterator rbegin() { return const_rbegin(); }$/;"	f	class:rope	access:public	signature:()
rbegin	stl_rope.h	/^	    reverse_iterator rbegin() { return mutable_rbegin(); }$/;"	f	class:rope	access:public	signature:()
rbegin	stl_rope.h	/^	const_reverse_iterator rbegin() const {$/;"	f	class:rope	access:public	signature:() const
rbegin	stl_set.h	/^  reverse_iterator rbegin() const { return t.rbegin(); } $/;"	f	class:set	access:public	signature:() const
rbegin	stl_tree.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:rb_tree	access:public	signature:() const
rbegin	stl_tree.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:rb_tree	access:public	signature:()
rbegin	stl_vector.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:vector	access:public	signature:() const
rbegin	stl_vector.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:vector	access:public	signature:()
read	stl_iterator.h	/^  void read() {$/;"	f	class:istream_iterator	access:protected	signature:()
reallocate	stl_alloc.h	/^  static void * reallocate(void *p, size_t old_sz, size_t new_sz);$/;"	p	class:__default_alloc_template	access:public	signature:(void *p, size_t old_sz, size_t new_sz)
reallocate	stl_alloc.h	/^__default_alloc_template<threads, inst>::reallocate(void *p,$/;"	f	class:__default_alloc_template	signature:(void *p, size_t old_sz, size_t new_sz)
reallocate	stl_alloc.h	/^static void * reallocate(void *p, size_t \/* old_sz *\/, size_t new_sz)$/;"	f	class:__malloc_alloc_template	access:public	signature:(void *p, size_t , size_t new_sz)
reallocate	stl_alloc.h	/^static void * reallocate(void *p, size_t old_sz, size_t new_sz)$/;"	f	class:debug_alloc	access:public	signature:(void *p, size_t old_sz, size_t new_sz)
reallocate_map	stl_deque.h	/^  void reallocate_map(size_type nodes_to_add, bool add_at_front);$/;"	p	class:__deque_iterator::deque	access:protected	signature:(size_type nodes_to_add, bool add_at_front)
reallocate_map	stl_deque.h	/^void deque<T, Alloc, BufSize>::reallocate_map(size_type nodes_to_add,$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type nodes_to_add, bool add_at_front)
ref	stl_rope.h	/^	  static void ref(RopeBase* t) {}$/;"	f	class:rope	access:protected	signature:(RopeBase* t)
ref	stl_rope.h	/^	  static void ref(RopeBase* t)$/;"	f	class:rope	access:protected	signature:(RopeBase* t)
ref	stl_rope.h	/^	  static void ref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase	access:public	signature:(__rope_RopeBase* t)
ref	stl_rope.h	/^	  static void ref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase	access:public	signature:(__rope_RopeBase* t)
ref_nonnil	stl_rope.h	/^	  void ref_nonnil() {}$/;"	f	struct:__rope_RopeBase	access:public	signature:()
ref_nonnil	stl_rope.h	/^	  void ref_nonnil()$/;"	f	struct:__rope_RopeBase	access:public	signature:()
refcount	stl_rope.h	/^	    long refcount;  	\/\/ InterlockedIncrement wants a long *$/;"	m	struct:__rope_RopeBase	access:public
refcount	stl_rope.h	/^	    size_t refcount;$/;"	m	struct:__rope_RopeBase	access:public
refcount_lock	stl_rope.h	/^	    pthread_mutex_t refcount_lock;$/;"	m	struct:__rope_RopeBase	access:public
reference	defalloc.h	/^    typedef T& reference;$/;"	t	class:allocator	access:public
reference	stl_bvector.h	/^  typedef __bit_reference  reference;$/;"	t	struct:__bit_iterator	access:public
reference	stl_bvector.h	/^  typedef __bit_reference reference;$/;"	t	class:vector	access:public
reference	stl_bvector.h	/^  typedef bool                 reference;$/;"	t	struct:__bit_const_iterator	access:public
reference	stl_deque.h	/^  typedef Ref reference;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
reference	stl_deque.h	/^  typedef value_type& reference;$/;"	t	class:__deque_iterator::deque	access:public
reference	stl_hash_map.h	/^  typedef typename ht::reference reference;$/;"	t	class:hash_map	access:public
reference	stl_hash_map.h	/^  typedef typename ht::reference reference;$/;"	t	class:hash_multimap	access:public
reference	stl_hash_set.h	/^  typedef typename ht::const_reference reference;$/;"	t	class:hash_multiset	access:public
reference	stl_hash_set.h	/^  typedef typename ht::const_reference reference;$/;"	t	class:hash_set	access:public
reference	stl_hashtable.h	/^  typedef Value& reference;$/;"	t	struct:__hashtable_iterator	access:public
reference	stl_hashtable.h	/^  typedef const Value& reference;$/;"	t	struct:__hashtable_const_iterator	access:public
reference	stl_hashtable.h	/^  typedef value_type&       reference;$/;"	t	class:hashtable	access:public
reference	stl_iterator.h	/^          reference;$/;"	t	class:reverse_iterator	access:public
reference	stl_iterator.h	/^  typedef Reference                  reference;$/;"	t	class:reverse_bidirectional_iterator	access:public
reference	stl_iterator.h	/^  typedef Reference                  reference;$/;"	t	class:reverse_iterator	access:public
reference	stl_iterator.h	/^  typedef Reference reference;$/;"	t	struct:iterator	access:public
reference	stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:bidirectional_iterator	access:public
reference	stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:iterator_traits	access:public
reference	stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:random_access_iterator	access:public
reference	stl_iterator.h	/^  typedef T&                   reference;$/;"	t	struct:forward_iterator	access:public
reference	stl_iterator.h	/^  typedef T&                 reference;$/;"	t	struct:input_iterator	access:public
reference	stl_iterator.h	/^  typedef const T&                   reference;$/;"	t	struct:iterator_traits	access:public
reference	stl_iterator.h	/^  typedef const T&           reference;$/;"	t	class:istream_iterator	access:public
reference	stl_iterator.h	/^  typedef typename Iterator::reference         reference;$/;"	t	struct:iterator_traits	access:public
reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	class:back_insert_iterator	access:public
reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	class:front_insert_iterator	access:public
reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	class:insert_iterator	access:public
reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	class:ostream_iterator	access:public
reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	struct:output_iterator	access:public
reference	stl_list.h	/^  typedef Ref reference;$/;"	t	struct:__list_iterator	access:public
reference	stl_list.h	/^  typedef value_type& reference;$/;"	t	class:list	access:public
reference	stl_map.h	/^  typedef typename rep_type::reference reference;$/;"	t	class:map	access:public
reference	stl_multimap.h	/^  typedef typename rep_type::reference reference;$/;"	t	class:multimap	access:public
reference	stl_multiset.h	/^  typedef typename rep_type::const_reference reference;$/;"	t	class:multiset	access:public
reference	stl_queue.h	/^  typedef typename Sequence::reference reference;$/;"	t	class:priority_queue	access:public
reference	stl_queue.h	/^  typedef typename Sequence::reference reference;$/;"	t	class:queue	access:public
reference	stl_raw_storage_iter.h	/^  typedef void                reference;$/;"	t	class:raw_storage_iterator	access:public
reference	stl_rope.h	/^	typedef __rope_charT_ref_proxy<charT,Alloc> reference;$/;"	t	class:rope	access:public
reference	stl_rope.h	/^    typedef __rope_charT_ref_proxy<charT,Alloc>  reference;$/;"	t	class:__rope_iterator	access:public
reference	stl_rope.h	/^    typedef charT reference;    \/\/ Really a value.  Returning a reference$/;"	t	class:__rope_const_iterator	access:public
reference	stl_set.h	/^  typedef typename rep_type::const_reference reference;$/;"	t	class:set	access:public
reference	stl_slist.h	/^  typedef Ref reference;$/;"	t	struct:__slist_iterator	access:public
reference	stl_slist.h	/^  typedef value_type& reference;$/;"	t	class:slist	access:public
reference	stl_stack.h	/^  typedef typename Sequence::reference reference;$/;"	t	class:stack	access:public
reference	stl_tree.h	/^  typedef Ref reference;$/;"	t	struct:__rb_tree_iterator	access:public
reference	stl_tree.h	/^  typedef value_type& reference;$/;"	t	class:rb_tree	access:public
reference	stl_vector.h	/^  typedef value_type& reference;$/;"	t	class:vector	access:public
refill	stl_alloc.h	/^  static void *refill(size_t n);$/;"	p	class:__default_alloc_template	access:private	signature:(size_t n)
refill	stl_alloc.h	/^void* __default_alloc_template<threads, inst>::refill(size_t n)$/;"	f	class:__default_alloc_template	signature:(size_t n)
remove	stl_algo.h	/^ForwardIterator remove(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value)
remove	stl_list.h	/^  void remove(const T& value);$/;"	p	class:list	access:public	signature:(const T& value)
remove	stl_list.h	/^void list<T, Alloc>::remove(const T& value) {$/;"	f	class:list	signature:(const T& value)
remove	stl_slist.h	/^  void remove(const T& val); $/;"	p	class:slist	access:public	signature:(const T& val)
remove	stl_slist.h	/^void slist<T,Alloc>::remove(const T& val)$/;"	f	class:slist	signature:(const T& val)
remove_copy	stl_algo.h	/^OutputIterator remove_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, const T& value)
remove_copy_if	stl_algo.h	/^OutputIterator remove_copy_if(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, Predicate pred)
remove_if	stl_algo.h	/^ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, Predicate pred)
remove_if	stl_list.h	/^  template <class Predicate> void remove_if(Predicate);$/;"	p	class:list	access:public	signature:(Predicate)
remove_if	stl_list.h	/^void list<T, Alloc>::remove_if(Predicate pred) {$/;"	f	class:list	signature:(Predicate pred)
remove_if	stl_slist.h	/^  template <class Predicate> void remove_if(Predicate pred);$/;"	p	class:slist	access:public	signature:(Predicate pred)
remove_if	stl_slist.h	/^template <class Predicate> void slist<T,Alloc>::remove_if(Predicate pred)$/;"	f	class:slist	signature:(Predicate pred)
rend	stl_bvector.h	/^  const_reverse_iterator rend() const { $/;"	f	class:vector	access:public	signature:() const
rend	stl_bvector.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:vector	access:public	signature:()
rend	stl_deque.h	/^  const_reverse_iterator rend() const {$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
rend	stl_deque.h	/^  reverse_iterator rend() { return reverse_iterator(start); }$/;"	f	class:__deque_iterator::deque	access:public	signature:()
rend	stl_list.h	/^  const_reverse_iterator rend() const { $/;"	f	class:list	access:public	signature:() const
rend	stl_list.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:list	access:public	signature:()
rend	stl_map.h	/^  const_reverse_iterator rend() const { return t.rend(); }$/;"	f	class:map	access:public	signature:() const
rend	stl_map.h	/^  reverse_iterator rend() { return t.rend(); }$/;"	f	class:map	access:public	signature:()
rend	stl_multimap.h	/^  const_reverse_iterator rend() const { return t.rend(); }$/;"	f	class:multimap	access:public	signature:() const
rend	stl_multimap.h	/^  reverse_iterator rend() { return t.rend(); }$/;"	f	class:multimap	access:public	signature:()
rend	stl_multiset.h	/^  reverse_iterator rend() const { return t.rend(); }$/;"	f	class:multiset	access:public	signature:() const
rend	stl_rope.h	/^	    const_reverse_iterator rend() { return const_rend(); }$/;"	f	class:rope	access:public	signature:()
rend	stl_rope.h	/^	    reverse_iterator rend() { return mutable_rend(); }$/;"	f	class:rope	access:public	signature:()
rend	stl_rope.h	/^	const_reverse_iterator rend() const {$/;"	f	class:rope	access:public	signature:() const
rend	stl_set.h	/^  reverse_iterator rend() const { return t.rend(); }$/;"	f	class:set	access:public	signature:() const
rend	stl_tree.h	/^  const_reverse_iterator rend() const { $/;"	f	class:rb_tree	access:public	signature:() const
rend	stl_tree.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:rb_tree	access:public	signature:()
rend	stl_vector.h	/^  const_reverse_iterator rend() const { $/;"	f	class:vector	access:public	signature:() const
rend	stl_vector.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:vector	access:public	signature:()
rep	stl_hash_map.h	/^  ht rep;$/;"	m	class:hash_map	access:private
rep	stl_hash_map.h	/^  ht rep;$/;"	m	class:hash_multimap	access:private
rep	stl_hash_set.h	/^  ht rep;$/;"	m	class:hash_multiset	access:private
rep	stl_hash_set.h	/^  ht rep;$/;"	m	class:hash_set	access:private
rep_type	stl_map.h	/^                  select1st<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:map	access:private
rep_type	stl_multimap.h	/^                  select1st<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:multimap	access:private
rep_type	stl_multiset.h	/^                  identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:multiset	access:private
rep_type	stl_set.h	/^                  identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:set	access:private
replace	stl_algo.h	/^void replace(ForwardIterator first, ForwardIterator last, const T& old_value,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value)
replace	stl_rope.h	/^	static RopeBase * replace(RopeBase *old, size_t pos1,$/;"	f	class:rope	access:protected	signature:(RopeBase *old, size_t pos1, size_t pos2, RopeBase *r)
replace	stl_rope.h	/^	void replace(const iterator& p, charT c)$/;"	f	class:rope	access:public	signature:(const iterator& p, charT c)
replace	stl_rope.h	/^	void replace(const iterator& p, const charT * c_string)$/;"	f	class:rope	access:public	signature:(const iterator& p, const charT * c_string)
replace	stl_rope.h	/^	void replace(const iterator& p, const charT *i, const charT *j)$/;"	f	class:rope	access:public	signature:(const iterator& p, const charT *i, const charT *j)
replace	stl_rope.h	/^	void replace(const iterator& p, const charT *i, size_t n)$/;"	f	class:rope	access:public	signature:(const iterator& p, const charT *i, size_t n)
replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q, charT c)$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, charT c)
replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, const charT * c_string)
replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, const charT *i, const charT *j)
replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, const charT *i, size_t n)
replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, const const_iterator& i, const const_iterator& j)
replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, const iterator& i, const iterator& j)
replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, const rope& r)
replace	stl_rope.h	/^	void replace(const iterator& p, const rope& r)$/;"	f	class:rope	access:public	signature:(const iterator& p, const rope& r)
replace	stl_rope.h	/^	void replace(const iterator& p, const_iterator i, const_iterator j)$/;"	f	class:rope	access:public	signature:(const iterator& p, const_iterator i, const_iterator j)
replace	stl_rope.h	/^	void replace(const iterator& p, iterator i, iterator j)$/;"	f	class:rope	access:public	signature:(const iterator& p, iterator i, iterator j)
replace	stl_rope.h	/^	void replace(size_t p, charT c) {$/;"	f	class:rope	access:public	signature:(size_t p, charT c)
replace	stl_rope.h	/^	void replace(size_t p, const charT *c_string) {$/;"	f	class:rope	access:public	signature:(size_t p, const charT *c_string)
replace	stl_rope.h	/^	void replace(size_t p, const charT *i, const charT *j) {$/;"	f	class:rope	access:public	signature:(size_t p, const charT *i, const charT *j)
replace	stl_rope.h	/^	void replace(size_t p, const charT *i, size_t i_len) {$/;"	f	class:rope	access:public	signature:(size_t p, const charT *i, size_t i_len)
replace	stl_rope.h	/^	void replace(size_t p, const const_iterator& i,$/;"	f	class:rope	access:public	signature:(size_t p, const const_iterator& i, const const_iterator& j)
replace	stl_rope.h	/^	void replace(size_t p, const iterator& i,$/;"	f	class:rope	access:public	signature:(size_t p, const iterator& i, const iterator& j)
replace	stl_rope.h	/^	void replace(size_t p, const rope& r) {$/;"	f	class:rope	access:public	signature:(size_t p, const rope& r)
replace	stl_rope.h	/^	void replace(size_t p, size_t n, charT c) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, charT c)
replace	stl_rope.h	/^	void replace(size_t p, size_t n, const charT *c_string) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, const charT *c_string)
replace	stl_rope.h	/^	void replace(size_t p, size_t n, const charT *i, const charT *j) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, const charT *i, const charT *j)
replace	stl_rope.h	/^	void replace(size_t p, size_t n, const charT *i, size_t i_len) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, const charT *i, size_t i_len)
replace	stl_rope.h	/^	void replace(size_t p, size_t n, const rope& r) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, const rope& r)
replace	stl_rope.h	/^	void replace(size_t p, size_t n,$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, const const_iterator& i, const const_iterator& j)
replace	stl_rope.h	/^	void replace(size_t p, size_t n,$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, const iterator& i, const iterator& j)
replace_copy	stl_algo.h	/^OutputIterator replace_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, const T& old_value, const T& new_value)
replace_copy_if	stl_algo.h	/^OutputIterator replace_copy_if(Iterator first, Iterator last,$/;"	f	signature:(Iterator first, Iterator last, OutputIterator result, Predicate pred, const T& new_value)
replace_if	stl_algo.h	/^void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value)
replace_with_c_str	ropeimpl.h	/^const charT * rope<charT,Alloc>::replace_with_c_str() {$/;"	f	class:rope	signature:()
replace_with_c_str	stl_rope.h	/^	const charT * replace_with_c_str();$/;"	p	class:rope	access:public	signature:()
requested_size	stl_tempbuf.h	/^  ptrdiff_t requested_size() const { return original_len; }$/;"	f	class:temporary_buffer	access:public	signature:() const
reserve	stl_bvector.h	/^  void reserve(size_type n) {$/;"	f	class:vector	access:public	signature:(size_type n)
reserve	stl_rope.h	/^	    void reserve(size_type res_arg = 0) {}$/;"	f	class:rope	access:public	signature:(size_type res_arg = 0)
reserve	stl_vector.h	/^  void reserve(size_type n) {$/;"	f	class:vector	access:public	signature:(size_type n)
reserve_elements_at_back	stl_deque.h	/^  iterator reserve_elements_at_back(size_type n) {$/;"	f	class:__deque_iterator::deque	access:protected	signature:(size_type n)
reserve_elements_at_front	stl_deque.h	/^  iterator reserve_elements_at_front(size_type n) {$/;"	f	class:__deque_iterator::deque	access:protected	signature:(size_type n)
reserve_map_at_back	stl_deque.h	/^  void reserve_map_at_back (size_type nodes_to_add = 1) {$/;"	f	class:__deque_iterator::deque	access:protected	signature:(size_type nodes_to_add = 1)
reserve_map_at_front	stl_deque.h	/^  void reserve_map_at_front (size_type nodes_to_add = 1) {$/;"	f	class:__deque_iterator::deque	access:protected	signature:(size_type nodes_to_add = 1)
resize	stl_bvector.h	/^  void resize(size_type new_size, bool x = bool()) {$/;"	f	class:vector	access:public	signature:(size_type new_size, bool x = bool())
resize	stl_deque.h	/^  void resize(size_type new_size) { resize(new_size, value_type()); }$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type new_size)
resize	stl_deque.h	/^  void resize(size_type new_size, const value_type& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(size_type new_size, const value_type& x)
resize	stl_hash_map.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_map	access:public	signature:(size_type hint)
resize	stl_hash_map.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_multimap	access:public	signature:(size_type hint)
resize	stl_hash_set.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_multiset	access:public	signature:(size_type hint)
resize	stl_hash_set.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_set	access:public	signature:(size_type hint)
resize	stl_hashtable.h	/^  void resize(size_type num_elements_hint);$/;"	p	class:hashtable	access:public	signature:(size_type num_elements_hint)
resize	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::resize(size_type num_elements_hint)$/;"	f	class:hashtable	signature:(size_type num_elements_hint)
resize	stl_list.h	/^  void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:list	access:public	signature:(size_type new_size)
resize	stl_list.h	/^  void resize(size_type new_size, const T& x);$/;"	p	class:list	access:public	signature:(size_type new_size, const T& x)
resize	stl_list.h	/^void list<T, Alloc>::resize(size_type new_size, const T& x)$/;"	f	class:list	signature:(size_type new_size, const T& x)
resize	stl_rope.h	/^	    void resize(size_type n) {}$/;"	f	class:rope	access:public	signature:(size_type n)
resize	stl_rope.h	/^	    void resize(size_type n, charT c) {}$/;"	f	class:rope	access:public	signature:(size_type n, charT c)
resize	stl_slist.h	/^  void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:slist	access:public	signature:(size_type new_size)
resize	stl_slist.h	/^  void resize(size_type new_size, const T& x);$/;"	p	class:slist	access:public	signature:(size_type new_size, const T& x)
resize	stl_slist.h	/^void slist<T, Alloc>::resize(size_type len, const T& x)$/;"	f	class:slist	signature:(size_type len, const T& x)
resize	stl_vector.h	/^  void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:vector	access:public	signature:(size_type new_size)
resize	stl_vector.h	/^  void resize(size_type new_size, const T& x) {$/;"	f	class:vector	access:public	signature:(size_type new_size, const T& x)
result_type	stl_function.h	/^    typedef Result result_type;$/;"	t	struct:binary_function	access:public
result_type	stl_function.h	/^    typedef Result result_type;$/;"	t	struct:unary_function	access:public
result_type	stl_function.h	/^  typedef Result result_type;$/;"	t	struct:constant_void_fun	access:public
return_temporary_buffer	stl_tempbuf.h	/^void return_temporary_buffer(T* p) {$/;"	f	signature:(T* p)
reverse	stl_algo.h	/^inline void reverse(BidirectionalIterator first, BidirectionalIterator last) {$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator last)
reverse	stl_list.h	/^  void reverse();$/;"	p	class:list	access:public	signature:()
reverse	stl_list.h	/^void list<T, Alloc>::reverse() {$/;"	f	class:list	signature:()
reverse	stl_slist.h	/^  void reverse() { if (head.next) head.next = __slist_reverse(head.next); }$/;"	f	class:slist	access:public	signature:()
reverse_bidirectional_iterator	stl_iterator.h	/^  explicit reverse_bidirectional_iterator(BidirectionalIterator x)$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:(BidirectionalIterator x)
reverse_bidirectional_iterator	stl_iterator.h	/^  reverse_bidirectional_iterator() {}$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:()
reverse_bidirectional_iterator	stl_iterator.h	/^class reverse_bidirectional_iterator {$/;"	c
reverse_bidirectional_iterator::base	stl_iterator.h	/^  BidirectionalIterator base() const { return current; }$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:() const
reverse_bidirectional_iterator::current	stl_iterator.h	/^  BidirectionalIterator current;$/;"	m	class:reverse_bidirectional_iterator	access:protected
reverse_bidirectional_iterator::difference_type	stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	class:reverse_bidirectional_iterator	access:public
reverse_bidirectional_iterator::iterator_category	stl_iterator.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	class:reverse_bidirectional_iterator	access:public
reverse_bidirectional_iterator::operator *	stl_iterator.h	/^  Reference operator*() const {$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:() const
reverse_bidirectional_iterator::operator ++	stl_iterator.h	/^  self operator++(int) {$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:(int)
reverse_bidirectional_iterator::operator ++	stl_iterator.h	/^  self& operator++() {$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:()
reverse_bidirectional_iterator::operator --	stl_iterator.h	/^  self operator--(int) {$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:(int)
reverse_bidirectional_iterator::operator --	stl_iterator.h	/^  self& operator--() {$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:()
reverse_bidirectional_iterator::operator ->	stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:() const
reverse_bidirectional_iterator::pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	class:reverse_bidirectional_iterator	access:public
reverse_bidirectional_iterator::reference	stl_iterator.h	/^  typedef Reference                  reference;$/;"	t	class:reverse_bidirectional_iterator	access:public
reverse_bidirectional_iterator::reverse_bidirectional_iterator	stl_iterator.h	/^  explicit reverse_bidirectional_iterator(BidirectionalIterator x)$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:(BidirectionalIterator x)
reverse_bidirectional_iterator::reverse_bidirectional_iterator	stl_iterator.h	/^  reverse_bidirectional_iterator() {}$/;"	f	class:reverse_bidirectional_iterator	access:public	signature:()
reverse_bidirectional_iterator::self	stl_iterator.h	/^                                         Distance> self;$/;"	t	class:reverse_bidirectional_iterator	access:private
reverse_bidirectional_iterator::value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	class:reverse_bidirectional_iterator	access:public
reverse_copy	stl_algo.h	/^OutputIterator reverse_copy(BidirectionalIterator first,$/;"	f	signature:(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result)
reverse_iterator	stl_bvector.h	/^          reverse_iterator;$/;"	t	class:vector	access:public
reverse_iterator	stl_bvector.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:vector	access:public
reverse_iterator	stl_deque.h	/^          reverse_iterator; $/;"	t	class:__deque_iterator::deque	access:public
reverse_iterator	stl_deque.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:__deque_iterator::deque	access:public
reverse_iterator	stl_iterator.h	/^  explicit reverse_iterator(RandomAccessIterator x) : current(x) {}$/;"	f	class:reverse_iterator	access:public	signature:(RandomAccessIterator x)
reverse_iterator	stl_iterator.h	/^  explicit reverse_iterator(iterator_type x) : current(x) {}$/;"	f	class:reverse_iterator	access:public	signature:(iterator_type x)
reverse_iterator	stl_iterator.h	/^  reverse_iterator() {}$/;"	f	class:reverse_iterator	access:public	signature:()
reverse_iterator	stl_iterator.h	/^  reverse_iterator(const reverse_iterator<Iter>& x) : current(x.current) {}$/;"	f	class:reverse_iterator	access:public	signature:(const reverse_iterator<Iter>& x)
reverse_iterator	stl_iterator.h	/^  reverse_iterator(const self& x) : current(x.current) {}$/;"	f	class:reverse_iterator	access:public	signature:(const self& x)
reverse_iterator	stl_iterator.h	/^class reverse_iterator $/;"	c
reverse_iterator	stl_iterator.h	/^class reverse_iterator {$/;"	c
reverse_iterator	stl_list.h	/^  reverse_iterator; $/;"	t	class:list	access:public
reverse_iterator	stl_list.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:list	access:public
reverse_iterator	stl_map.h	/^  typedef typename rep_type::reverse_iterator reverse_iterator;$/;"	t	class:map	access:public
reverse_iterator	stl_multimap.h	/^  typedef typename rep_type::reverse_iterator reverse_iterator;$/;"	t	class:multimap	access:public
reverse_iterator	stl_multiset.h	/^  typedef typename rep_type::const_reverse_iterator reverse_iterator;$/;"	t	class:multiset	access:public
reverse_iterator	stl_rope.h	/^				 difference_type>  reverse_iterator;$/;"	t	class:rope	access:public
reverse_iterator	stl_rope.h	/^        typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:rope	access:public
reverse_iterator	stl_set.h	/^  typedef typename rep_type::const_reverse_iterator reverse_iterator;$/;"	t	class:set	access:public
reverse_iterator	stl_tree.h	/^          reverse_iterator; $/;"	t	class:rb_tree	access:public
reverse_iterator	stl_tree.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:rb_tree	access:public
reverse_iterator	stl_vector.h	/^          reverse_iterator;$/;"	t	class:vector	access:public
reverse_iterator	stl_vector.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:vector	access:public
reverse_iterator::base	stl_iterator.h	/^  RandomAccessIterator base() const { return current; }$/;"	f	class:reverse_iterator	access:public	signature:() const
reverse_iterator::base	stl_iterator.h	/^  iterator_type base() const { return current; }$/;"	f	class:reverse_iterator	access:public	signature:() const
reverse_iterator::current	stl_iterator.h	/^  Iterator current;$/;"	m	class:reverse_iterator	access:protected
reverse_iterator::current	stl_iterator.h	/^  RandomAccessIterator current;$/;"	m	class:reverse_iterator	access:protected
reverse_iterator::difference_type	stl_iterator.h	/^          difference_type;$/;"	t	class:reverse_iterator	access:public
reverse_iterator::difference_type	stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	class:reverse_iterator	access:public
reverse_iterator::iterator_category	stl_iterator.h	/^          iterator_category;$/;"	t	class:reverse_iterator	access:public
reverse_iterator::iterator_category	stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	class:reverse_iterator	access:public
reverse_iterator::iterator_type	stl_iterator.h	/^  typedef Iterator iterator_type;$/;"	t	class:reverse_iterator	access:public
reverse_iterator::operator *	stl_iterator.h	/^  Reference operator*() const { return *(current - 1); }$/;"	f	class:reverse_iterator	access:public	signature:() const
reverse_iterator::operator *	stl_iterator.h	/^  reference operator*() const {$/;"	f	class:reverse_iterator	access:public	signature:() const
reverse_iterator::operator +	stl_iterator.h	/^  self operator+(Distance n) const {$/;"	f	class:reverse_iterator	access:public	signature:(Distance n) const
reverse_iterator::operator +	stl_iterator.h	/^  self operator+(difference_type n) const {$/;"	f	class:reverse_iterator	access:public	signature:(difference_type n) const
reverse_iterator::operator ++	stl_iterator.h	/^  self operator++(int) {$/;"	f	class:reverse_iterator	access:public	signature:(int)
reverse_iterator::operator ++	stl_iterator.h	/^  self& operator++() {$/;"	f	class:reverse_iterator	access:public	signature:()
reverse_iterator::operator +=	stl_iterator.h	/^  self& operator+=(Distance n) {$/;"	f	class:reverse_iterator	access:public	signature:(Distance n)
reverse_iterator::operator +=	stl_iterator.h	/^  self& operator+=(difference_type n) {$/;"	f	class:reverse_iterator	access:public	signature:(difference_type n)
reverse_iterator::operator -	stl_iterator.h	/^  self operator-(Distance n) const {$/;"	f	class:reverse_iterator	access:public	signature:(Distance n) const
reverse_iterator::operator -	stl_iterator.h	/^  self operator-(difference_type n) const {$/;"	f	class:reverse_iterator	access:public	signature:(difference_type n) const
reverse_iterator::operator --	stl_iterator.h	/^  self operator--(int) {$/;"	f	class:reverse_iterator	access:public	signature:(int)
reverse_iterator::operator --	stl_iterator.h	/^  self& operator--() {$/;"	f	class:reverse_iterator	access:public	signature:()
reverse_iterator::operator -=	stl_iterator.h	/^  self& operator-=(Distance n) {$/;"	f	class:reverse_iterator	access:public	signature:(Distance n)
reverse_iterator::operator -=	stl_iterator.h	/^  self& operator-=(difference_type n) {$/;"	f	class:reverse_iterator	access:public	signature:(difference_type n)
reverse_iterator::operator ->	stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:reverse_iterator	access:public	signature:() const
reverse_iterator::operator []	stl_iterator.h	/^  Reference operator[](Distance n) const { return *(*this + n); }$/;"	f	class:reverse_iterator	access:public	signature:(Distance n) const
reverse_iterator::operator []	stl_iterator.h	/^  reference operator[](difference_type n) const { return *(*this + n); }  $/;"	f	class:reverse_iterator	access:public	signature:(difference_type n) const
reverse_iterator::pointer	stl_iterator.h	/^          pointer;$/;"	t	class:reverse_iterator	access:public
reverse_iterator::pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	class:reverse_iterator	access:public
reverse_iterator::reference	stl_iterator.h	/^          reference;$/;"	t	class:reverse_iterator	access:public
reverse_iterator::reference	stl_iterator.h	/^  typedef Reference                  reference;$/;"	t	class:reverse_iterator	access:public
reverse_iterator::reverse_iterator	stl_iterator.h	/^  explicit reverse_iterator(RandomAccessIterator x) : current(x) {}$/;"	f	class:reverse_iterator	access:public	signature:(RandomAccessIterator x)
reverse_iterator::reverse_iterator	stl_iterator.h	/^  explicit reverse_iterator(iterator_type x) : current(x) {}$/;"	f	class:reverse_iterator	access:public	signature:(iterator_type x)
reverse_iterator::reverse_iterator	stl_iterator.h	/^  reverse_iterator() {}$/;"	f	class:reverse_iterator	access:public	signature:()
reverse_iterator::reverse_iterator	stl_iterator.h	/^  reverse_iterator(const reverse_iterator<Iter>& x) : current(x.current) {}$/;"	f	class:reverse_iterator	access:public	signature:(const reverse_iterator<Iter>& x)
reverse_iterator::reverse_iterator	stl_iterator.h	/^  reverse_iterator(const self& x) : current(x.current) {}$/;"	f	class:reverse_iterator	access:public	signature:(const self& x)
reverse_iterator::self	stl_iterator.h	/^        self;$/;"	t	class:reverse_iterator	access:private
reverse_iterator::self	stl_iterator.h	/^  typedef reverse_iterator<Iterator> self;$/;"	t	class:reverse_iterator	access:public
reverse_iterator::value_type	stl_iterator.h	/^          value_type;$/;"	t	class:reverse_iterator	access:public
reverse_iterator::value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	class:reverse_iterator	access:public
right	stl_rope.h	/^    __rope_RopeBase<charT,Alloc>* right;$/;"	m	struct:__rope_RopeConcatenation	access:public
right	stl_tree.h	/^  base_ptr right;$/;"	m	struct:__rb_tree_node_base	access:public
right	stl_tree.h	/^  static link_type& right(base_ptr x) { return (link_type&)(x->right); }$/;"	f	class:rb_tree	access:protected	signature:(base_ptr x)
right	stl_tree.h	/^  static link_type& right(link_type x) { return (link_type&)(x->right); }$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
rightmost	stl_tree.h	/^  link_type& rightmost() const { return (link_type&) header->right; }$/;"	f	class:rb_tree	access:protected	signature:() const
root	stl_rope.h	/^    RopeBase * root;     \/\/ The whole rope.$/;"	m	class:__rope_iterator_base	access:protected
root	stl_rope.h	/^    my_rope * root;     \/\/ The whole rope.$/;"	m	class:__rope_charT_ref_proxy	access:private
root	stl_rope.h	/^    rope<charT,Alloc> * root;     \/\/ The whole rope.$/;"	m	class:__rope_charT_ptr_proxy	access:private
root	stl_tree.h	/^  link_type& root() const { return (link_type&) header->parent; }$/;"	f	class:rb_tree	access:protected	signature:() const
root_rope	stl_rope.h	/^    rope<charT,Alloc> * root_rope;$/;"	m	class:__rope_iterator	access:protected
rope	ropeimpl.h	/^rope<charT, Alloc>::rope(size_t n, charT c)$/;"	f	class:rope	signature:(size_t n, charT c)
rope	stl_rope.h	/^	rope()$/;"	f	class:rope	access:public	signature:()
rope	stl_rope.h	/^	rope(RopeBase *t) : tree_ptr(t) { }$/;"	f	class:rope	access:protected	signature:(RopeBase *t)
rope	stl_rope.h	/^	rope(charT c)$/;"	f	class:rope	access:public	signature:(charT c)
rope	stl_rope.h	/^	rope(char_producer<charT> *fn, size_t len, bool delete_fn)$/;"	f	class:rope	access:public	signature:(char_producer<charT> *fn, size_t len, bool delete_fn)
rope	stl_rope.h	/^	rope(const charT *i, const charT *j)$/;"	f	class:rope	access:public	signature:(const charT *i, const charT *j)
rope	stl_rope.h	/^	rope(const charT *s)$/;"	f	class:rope	access:public	signature:(const charT *s)
rope	stl_rope.h	/^	rope(const charT *s, charT *e)$/;"	f	class:rope	access:public	signature:(const charT *s, charT *e)
rope	stl_rope.h	/^	rope(const charT *s, size_t len)$/;"	f	class:rope	access:public	signature:(const charT *s, size_t len)
rope	stl_rope.h	/^	rope(const const_iterator& s, const const_iterator& e)$/;"	f	class:rope	access:public	signature:(const const_iterator& s, const const_iterator& e)
rope	stl_rope.h	/^	rope(const iterator& s, const iterator& e)$/;"	f	class:rope	access:public	signature:(const iterator& s, const iterator& e)
rope	stl_rope.h	/^	rope(const rope &x)$/;"	f	class:rope	access:public	signature:(const rope &x)
rope	stl_rope.h	/^	rope(size_t n, charT c);$/;"	p	class:rope	access:public	signature:(size_t n, charT c)
rope	stl_rope.h	/^class rope {$/;"	c
rope::CAlloc	stl_rope.h	/^    	typedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;$/;"	t	class:rope	access:protected
rope::DataAlloc	stl_rope.h	/^    	typedef simple_alloc<charT, Alloc> DataAlloc;$/;"	t	class:rope	access:protected
rope::FAlloc	stl_rope.h	/^    	typedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;$/;"	t	class:rope	access:protected
rope::LAlloc	stl_rope.h	/^    	typedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;$/;"	t	class:rope	access:protected
rope::RopeBase	stl_rope.h	/^	typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:rope	access:protected
rope::RopeConcatenation	stl_rope.h	/^	typedef __rope_RopeConcatenation<charT,Alloc> RopeConcatenation;$/;"	t	class:rope	access:protected
rope::RopeFunction	stl_rope.h	/^	typedef __rope_RopeFunction<charT,Alloc> RopeFunction;$/;"	t	class:rope	access:protected
rope::RopeFunction_from_fn	ropeimpl.h	/^rope<charT,Alloc>::RopeFunction_from_fn$/;"	f	class:rope	signature:(char_producer<charT> *fn, size_t size, bool delete_fn)
rope::RopeFunction_from_fn	stl_rope.h	/^	static RopeFunction * RopeFunction_from_fn$/;"	p	class:rope	access:protected	signature:(char_producer<charT> *fn, size_t size, bool delete_fn)
rope::RopeLeaf	stl_rope.h	/^	typedef __rope_RopeLeaf<charT,Alloc> RopeLeaf;$/;"	t	class:rope	access:protected
rope::RopeLeaf_from_char_ptr	ropeimpl.h	/^rope<charT,Alloc>::RopeLeaf_from_char_ptr(__GC_CONST charT *s, size_t size)$/;"	f	class:rope	signature:(__GC_CONST charT *s, size_t size)
rope::RopeLeaf_from_char_ptr	stl_rope.h	/^	static RopeLeaf * RopeLeaf_from_char_ptr(__GC_CONST charT *s,$/;"	p	class:rope	access:protected	signature:(__GC_CONST charT *s, size_t size)
rope::RopeLeaf_from_unowned_char_ptr	stl_rope.h	/^	static RopeLeaf * RopeLeaf_from_unowned_char_ptr(const charT *s,$/;"	f	class:rope	access:protected	signature:(const charT *s, size_t size)
rope::RopeSubstring	stl_rope.h	/^	typedef __rope_RopeSubstring<charT,Alloc> RopeSubstring;$/;"	t	class:rope	access:protected
rope::SAlloc	stl_rope.h	/^    	typedef simple_alloc<__rope_RopeSubstring<charT,Alloc>, Alloc> SAlloc;$/;"	t	class:rope	access:protected
rope::__STL_NULL_TMPL_ARGS	stl_rope.h	/^        operator+ __STL_NULL_TMPL_ARGS (const rope<charT,Alloc> &left,$/;"	p	class:rope	access:friend	signature:(const rope<charT,Alloc> &left, charT right)
rope::__STL_NULL_TMPL_ARGS	stl_rope.h	/^        operator+ __STL_NULL_TMPL_ARGS (const rope<charT,Alloc> &left,$/;"	p	class:rope	access:friend	signature:(const rope<charT,Alloc> &left, const charT* right)
rope::__STL_NULL_TMPL_ARGS	stl_rope.h	/^        operator+ __STL_NULL_TMPL_ARGS (const rope<charT,Alloc> &left,$/;"	p	class:rope	access:friend	signature:(const rope<charT,Alloc> &left, const rope<charT,Alloc> &right)
rope::add_leaf_to_forest	ropeimpl.h	/^rope<charT,Alloc>::add_leaf_to_forest(RopeBase *r, RopeBase **forest)$/;"	f	class:rope	signature:(RopeBase *r, RopeBase **forest)
rope::add_leaf_to_forest	stl_rope.h	/^	static void add_leaf_to_forest(RopeBase *r, RopeBase **forest);$/;"	p	class:rope	access:protected	signature:(RopeBase *r, RopeBase **forest)
rope::add_to_forest	ropeimpl.h	/^rope<charT,Alloc>::add_to_forest(RopeBase *r, RopeBase **forest)$/;"	f	class:rope	signature:(RopeBase *r, RopeBase **forest)
rope::add_to_forest	stl_rope.h	/^	static void add_to_forest(RopeBase *r, RopeBase **forest);$/;"	p	class:rope	access:protected	signature:(RopeBase *r, RopeBase **forest)
rope::alloc_copy	stl_rope.h	/^	static charT * alloc_copy(const charT *s, size_t size)$/;"	f	class:rope	access:protected	signature:(const charT *s, size_t size)
rope::allocated_capacity	stl_rope.h	/^	static size_t allocated_capacity(size_t n) {$/;"	f	class:rope	access:protected	signature:(size_t n)
rope::append	stl_rope.h	/^	rope& append() { return append(charT()); }$/;"	f	class:rope	access:public	signature:()
rope::append	stl_rope.h	/^	rope& append(charT c) {$/;"	f	class:rope	access:public	signature:(charT c)
rope::append	stl_rope.h	/^	rope& append(const charT* c_string) {$/;"	f	class:rope	access:public	signature:(const charT* c_string)
rope::append	stl_rope.h	/^	rope& append(const charT* iter, size_t n) {$/;"	f	class:rope	access:public	signature:(const charT* iter, size_t n)
rope::append	stl_rope.h	/^	rope& append(const charT* s, const charT* e) {$/;"	f	class:rope	access:public	signature:(const charT* s, const charT* e)
rope::append	stl_rope.h	/^	rope& append(const rope& y) {$/;"	f	class:rope	access:public	signature:(const rope& y)
rope::append	stl_rope.h	/^	rope& append(const_iterator s, const_iterator e) {$/;"	f	class:rope	access:public	signature:(const_iterator s, const_iterator e)
rope::append	stl_rope.h	/^	rope& append(size_t n, charT c) {$/;"	f	class:rope	access:public	signature:(size_t n, charT c)
rope::apply_to_pieces	ropeimpl.h	/^bool rope<charT, Alloc>::apply_to_pieces($/;"	f	class:rope	signature:( __rope_char_consumer<charT>& c, const RopeBase * r, size_t begin, size_t end)
rope::apply_to_pieces	stl_rope.h	/^	static bool apply_to_pieces($/;"	p	class:rope	access:protected	signature:( __rope_char_consumer<charT>& c, const RopeBase * r, size_t begin, size_t end)
rope::apply_to_pieces	stl_rope.h	/^	void apply_to_pieces( size_t begin, size_t end,$/;"	f	class:rope	access:public	signature:( size_t begin, size_t end, __rope_char_consumer<charT>& c) const
rope::at	stl_rope.h	/^	    reference at(size_type pos) {$/;"	f	class:rope	access:public	signature:(size_type pos)
rope::at	stl_rope.h	/^	charT at(size_type pos) const {$/;"	f	class:rope	access:public	signature:(size_type pos) const
rope::atomic_swap	stl_rope.h	/^	    static cstrptr atomic_swap(cstrptr *p, cstrptr q) {$/;"	f	class:rope	access:protected	signature:(cstrptr *p, cstrptr q)
rope::back	stl_rope.h	/^	charT back() const$/;"	f	class:rope	access:public	signature:() const
rope::balance	ropeimpl.h	/^rope<charT,Alloc>::balance(RopeBase *r)$/;"	f	class:rope	signature:(RopeBase *r)
rope::balance	stl_rope.h	/^	static RopeBase * balance(RopeBase * r);$/;"	p	class:rope	access:protected	signature:(RopeBase * r)
rope::balance	stl_rope.h	/^	void balance()$/;"	f	class:rope	access:public	signature:()
rope::begin	stl_rope.h	/^	    const_iterator begin() { return const_begin(); }$/;"	f	class:rope	access:public	signature:()
rope::begin	stl_rope.h	/^	    iterator begin() { return mutable_begin(); }$/;"	f	class:rope	access:public	signature:()
rope::begin	stl_rope.h	/^	const_iterator begin() const {$/;"	f	class:rope	access:public	signature:() const
rope::c_str	ropeimpl.h	/^const charT * rope<charT,Alloc>::c_str() const {$/;"	f	class:rope	signature:() const
rope::c_str	stl_rope.h	/^	const charT * c_str() const;$/;"	p	class:rope	access:public	signature:() const
rope::capacity	stl_rope.h	/^	    size_type capacity() const {$/;"	f	class:rope	access:public	signature:() const
rope::char_ptr_len	ropeimpl.h	/^inline size_t rope<charT,Alloc>::char_ptr_len(const charT *s)$/;"	f	class:rope	signature:(const charT *s)
rope::char_ptr_len	stl_rope.h	/^	static size_t char_ptr_len(const charT * s);$/;"	p	class:rope	access:protected	signature:(const charT * s)
rope::compare	ropeimpl.h	/^rope<charT,Alloc>::compare (const RopeBase *left, const RopeBase *right)$/;"	f	class:rope	signature:(const RopeBase *left, const RopeBase *right)
rope::compare	stl_rope.h	/^	int compare(const rope &y) const {$/;"	f	class:rope	access:public	signature:(const rope &y) const
rope::compare	stl_rope.h	/^	static int compare(const RopeBase *x, const RopeBase *y);$/;"	p	class:rope	access:protected	signature:(const RopeBase *x, const RopeBase *y)
rope::concat	ropeimpl.h	/^rope<charT,Alloc>::concat(RopeBase * left, RopeBase * right)$/;"	f	class:rope	signature:(RopeBase * left, RopeBase * right)
rope::concat	stl_rope.h	/^	static RopeBase * concat(RopeBase *left, RopeBase *right);$/;"	p	class:rope	access:protected	signature:(RopeBase *left, RopeBase *right)
rope::concat_and_set_balanced	stl_rope.h	/^	static RopeBase * concat_and_set_balanced(RopeBase *left,$/;"	f	class:rope	access:protected	signature:(RopeBase *left, RopeBase *right)
rope::concat_char_iter	ropeimpl.h	/^rope<charT,Alloc>::RopeBase * rope<charT,Alloc>::concat_char_iter$/;"	f	class:rope	signature:(RopeBase * r, const charT *s, size_t slen)
rope::concat_char_iter	stl_rope.h	/^	static RopeBase * concat_char_iter(RopeBase * r,$/;"	p	class:rope	access:protected	signature:(RopeBase * r, const charT *iter, size_t slen)
rope::concat_fn	stl_rope.h	/^	struct concat_fn$/;"	s	class:rope	inherits:binary_function	access:protected
rope::concat_fn::operator ()	stl_rope.h	/^		rope operator() (const rope& x, const rope& y) {$/;"	f	struct:rope::concat_fn	access:public	signature:(const rope& x, const rope& y)
rope::const_begin	stl_rope.h	/^	const_iterator const_begin() const {$/;"	f	class:rope	access:public	signature:() const
rope::const_end	stl_rope.h	/^	const_iterator const_end() const {$/;"	f	class:rope	access:public	signature:() const
rope::const_iterator	stl_rope.h	/^	typedef __rope_const_iterator<charT,Alloc> const_iterator;$/;"	t	class:rope	access:public
rope::const_pointer	stl_rope.h	/^	typedef const charT* const_pointer;$/;"	t	class:rope	access:public
rope::const_rbegin	stl_rope.h	/^	const_reverse_iterator const_rbegin() const {$/;"	f	class:rope	access:public	signature:() const
rope::const_reference	stl_rope.h	/^	typedef charT const_reference;$/;"	t	class:rope	access:public
rope::const_rend	stl_rope.h	/^	const_reverse_iterator const_rend() const {$/;"	f	class:rope	access:public	signature:() const
rope::const_reverse_iterator	stl_rope.h	/^				 difference_type>  const_reverse_iterator;$/;"	t	class:rope	access:public
rope::const_reverse_iterator	stl_rope.h	/^        typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:rope	access:public
rope::copy	stl_rope.h	/^	      size_type copy(charT *buffer, size_type n, size_type pos = 0)$/;"	f	class:rope	access:public	signature:(charT *buffer, size_type n, size_type pos = 0) const
rope::copy	stl_rope.h	/^	size_type copy(size_type pos, size_type n, charT *buffer) const {$/;"	f	class:rope	access:public	signature:(size_type pos, size_type n, charT *buffer) const
rope::copy	stl_rope.h	/^	void copy(charT * buffer) const {$/;"	f	class:rope	access:public	signature:(charT * buffer) const
rope::copy_max	stl_rope.h	/^	enum { copy_max = 23 };$/;"	e	enum:rope::__anon13
rope::cstrptr	stl_rope.h	/^	typedef __GC_CONST charT * cstrptr;$/;"	t	class:rope	access:protected
rope::delete_c_str	stl_rope.h	/^	void delete_c_str () {$/;"	f	class:rope	access:public	signature:()
rope::destr_concat_char_iter	ropeimpl.h	/^::destr_concat_char_iter$/;"	f	class:rope	signature:(RopeBase * r, const charT *s, size_t slen)
rope::destr_concat_char_iter	stl_rope.h	/^	static RopeBase * destr_concat_char_iter(RopeBase * r,$/;"	f	class:rope	access:protected	signature:(RopeBase * r, const charT *iter, size_t slen)
rope::destr_leaf_concat_char_iter	ropeimpl.h	/^rope<charT,Alloc>::destr_leaf_concat_char_iter$/;"	f	class:rope	signature:(RopeLeaf * r, const charT * iter, size_t len)
rope::destr_leaf_concat_char_iter	stl_rope.h	/^	  static RopeLeaf * destr_leaf_concat_char_iter$/;"	p	class:rope	access:protected	signature:(RopeLeaf * r, const charT * iter, size_t slen)
rope::difference_type	stl_rope.h	/^	typedef ptrdiff_t difference_type;$/;"	t	class:rope	access:public
rope::dump	ropeimpl.h	/^rope<charT,Alloc>::dump(RopeBase * r, int indent)$/;"	f	class:rope	signature:(RopeBase * r, int indent)
rope::dump	stl_rope.h	/^	static void dump(RopeBase * r, int indent = 0);$/;"	p	class:rope	access:protected	signature:(RopeBase * r, int indent = 0)
rope::dump	stl_rope.h	/^	void dump() {$/;"	f	class:rope	access:public	signature:()
rope::empty	stl_rope.h	/^	bool empty() const { return 0 == tree_ptr; }$/;"	f	class:rope	access:public	signature:() const
rope::empty_c_str	ropeimpl.h	/^template<class charT, class Alloc> charT rope<charT,Alloc>::empty_c_str[1];$/;"	m	class:rope
rope::empty_c_str	stl_rope.h	/^	static charT empty_c_str[1];$/;"	m	class:rope	access:protected
rope::end	stl_rope.h	/^	    const_iterator end() { return const_end(); }$/;"	f	class:rope	access:public	signature:()
rope::end	stl_rope.h	/^	    iterator end() { return mutable_end(); }$/;"	f	class:rope	access:public	signature:()
rope::end	stl_rope.h	/^	const_iterator end() const {$/;"	f	class:rope	access:public	signature:() const
rope::erase	stl_rope.h	/^	iterator erase(const iterator &p, const iterator &q) {$/;"	f	class:rope	access:public	signature:(const iterator &p, const iterator &q)
rope::erase	stl_rope.h	/^	void erase(size_t p) {$/;"	f	class:rope	access:public	signature:(size_t p)
rope::erase	stl_rope.h	/^	void erase(size_t p, size_t n) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n)
rope::erase	stl_rope.h	/^        iterator erase(const iterator &p) {$/;"	f	class:rope	access:public	signature:(const iterator &p)
rope::fetch	ropeimpl.h	/^rope<charT,Alloc>::fetch(RopeBase *r, size_type i)$/;"	f	class:rope	signature:(RopeBase *r, size_type i)
rope::fetch	stl_rope.h	/^	static charT fetch(RopeBase * r, size_type pos);$/;"	p	class:rope	access:protected	signature:(RopeBase * r, size_type pos)
rope::fetch_ptr	ropeimpl.h	/^rope<charT,Alloc>::fetch_ptr(RopeBase *r, size_type i)$/;"	f	class:rope	signature:(RopeBase *r, size_type i)
rope::fetch_ptr	stl_rope.h	/^	    static charT * fetch_ptr(RopeBase * r, size_type pos);$/;"	p	class:rope	access:protected	signature:(RopeBase * r, size_type pos)
rope::find	ropeimpl.h	/^rope<charT,Alloc>::find(charT pattern, size_t start) const$/;"	f	class:rope	signature:(charT pattern, size_t start) const
rope::find	stl_rope.h	/^	size_type find(charT *s, size_type pos = 0) const {$/;"	f	class:rope	access:public	signature:(charT *s, size_type pos = 0) const
rope::find	stl_rope.h	/^	size_type find(charT c, size_type pos = 0) const;$/;"	p	class:rope	access:public	signature:(charT c, size_type pos = 0) const
rope::flatten	ropeimpl.h	/^rope<charT,Alloc>::flatten(RopeBase * r, charT * buffer)$/;"	f	class:rope	signature:(RopeBase * r, charT * buffer)
rope::flatten	ropeimpl.h	/^rope<charT,Alloc>::flatten(RopeBase * r,$/;"	f	class:rope	signature:(RopeBase * r, size_t start, size_t len, charT * buffer)
rope::flatten	stl_rope.h	/^	static charT * flatten(RopeBase * r, charT * buffer);$/;"	p	class:rope	access:protected	signature:(RopeBase * r, charT * buffer)
rope::flatten	stl_rope.h	/^	static charT * flatten(RopeBase * r,$/;"	p	class:rope	access:protected	signature:(RopeBase * r, size_t start, size_t len, charT * buffer)
rope::front	stl_rope.h	/^	charT front() const$/;"	f	class:rope	access:public	signature:() const
rope::identity_element	stl_rope.h	/^        friend rope identity_element(concat_fn) { return rope<charT,Alloc>(); }$/;"	f	class:rope	access:friend	signature:(concat_fn)
rope::insert	stl_rope.h	/^	iterator insert(const iterator& p ) $/;"	f	class:rope	access:public	signature:(const iterator& p )
rope::insert	stl_rope.h	/^	iterator insert(const iterator& p, charT c) $/;"	f	class:rope	access:public	signature:(const iterator& p, charT c)
rope::insert	stl_rope.h	/^	iterator insert(const iterator& p, const charT *c_string) $/;"	f	class:rope	access:public	signature:(const iterator& p, const charT *c_string)
rope::insert	stl_rope.h	/^	iterator insert(const iterator& p, const charT *i, const charT *j)$/;"	f	class:rope	access:public	signature:(const iterator& p, const charT *i, const charT *j)
rope::insert	stl_rope.h	/^	iterator insert(const iterator& p, const charT *i, size_t n)$/;"	f	class:rope	access:public	signature:(const iterator& p, const charT *i, size_t n)
rope::insert	stl_rope.h	/^	iterator insert(const iterator& p, const rope& r)$/;"	f	class:rope	access:public	signature:(const iterator& p, const rope& r)
rope::insert	stl_rope.h	/^	iterator insert(const iterator& p, size_t n, charT c)$/;"	f	class:rope	access:public	signature:(const iterator& p, size_t n, charT c)
rope::insert	stl_rope.h	/^	iterator insert(const iterator& p,$/;"	f	class:rope	access:public	signature:(const iterator& p, const const_iterator& i, const const_iterator& j)
rope::insert	stl_rope.h	/^	iterator insert(const iterator& p,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& i, const iterator& j)
rope::insert	stl_rope.h	/^	void insert(size_t p) {$/;"	f	class:rope	access:public	signature:(size_t p)
rope::insert	stl_rope.h	/^	void insert(size_t p, charT c) {$/;"	f	class:rope	access:public	signature:(size_t p, charT c)
rope::insert	stl_rope.h	/^	void insert(size_t p, const charT * c_string) {$/;"	f	class:rope	access:public	signature:(size_t p, const charT * c_string)
rope::insert	stl_rope.h	/^	void insert(size_t p, const charT * i, size_t n) {$/;"	f	class:rope	access:public	signature:(size_t p, const charT * i, size_t n)
rope::insert	stl_rope.h	/^	void insert(size_t p, const charT *i, const charT *j) {$/;"	f	class:rope	access:public	signature:(size_t p, const charT *i, const charT *j)
rope::insert	stl_rope.h	/^	void insert(size_t p, const const_iterator& i,$/;"	f	class:rope	access:public	signature:(size_t p, const const_iterator& i, const const_iterator& j)
rope::insert	stl_rope.h	/^	void insert(size_t p, const iterator& i,$/;"	f	class:rope	access:public	signature:(size_t p, const iterator& i, const iterator& j)
rope::insert	stl_rope.h	/^	void insert(size_t p, const rope& r) {$/;"	f	class:rope	access:public	signature:(size_t p, const rope& r)
rope::insert	stl_rope.h	/^	void insert(size_t p, size_t n, charT c) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, charT c)
rope::is0	stl_rope.h	/^	static bool is0(charT c) { return c == __eos((charT *)0); }$/;"	f	class:rope	access:protected	signature:(charT c)
rope::is_almost_balanced	stl_rope.h	/^	static bool is_almost_balanced(RopeBase *r)$/;"	f	class:rope	access:protected	signature:(RopeBase *r)
rope::is_balanced	stl_rope.h	/^	static bool is_balanced(RopeBase *r)$/;"	f	class:rope	access:protected	signature:(RopeBase *r)
rope::is_roughly_balanced	stl_rope.h	/^	static bool is_roughly_balanced(RopeBase *r)$/;"	f	class:rope	access:protected	signature:(RopeBase *r)
rope::iterator	stl_rope.h	/^	typedef __rope_iterator<charT,Alloc> iterator;$/;"	t	class:rope	access:public
rope::leaf_concat_char_iter	ropeimpl.h	/^rope<charT,Alloc>::leaf_concat_char_iter$/;"	f	class:rope	signature:(RopeLeaf * r, const charT * iter, size_t len)
rope::leaf_concat_char_iter	stl_rope.h	/^	static RopeLeaf * leaf_concat_char_iter$/;"	p	class:rope	access:protected	signature:(RopeLeaf * r, const charT * iter, size_t slen)
rope::length	stl_rope.h	/^	size_type length() const {$/;"	f	class:rope	access:public	signature:() const
rope::max_size	stl_rope.h	/^	size_type max_size() const {$/;"	f	class:rope	access:public	signature:() const
rope::min_len	ropeimpl.h	/^rope<charT,Alloc>::min_len[__rope_RopeBase<charT,Alloc>::max_rope_depth + 1] = {$/;"	m	class:rope
rope::min_len	stl_rope.h	/^	static const unsigned long min_len[RopeBase::max_rope_depth + 1];$/;"	m	class:rope	access:protected
rope::mutable_begin	stl_rope.h	/^	iterator mutable_begin() {$/;"	f	class:rope	access:public	signature:()
rope::mutable_end	stl_rope.h	/^	iterator mutable_end() {$/;"	f	class:rope	access:public	signature:()
rope::mutable_rbegin	stl_rope.h	/^	reverse_iterator mutable_rbegin() {$/;"	f	class:rope	access:public	signature:()
rope::mutable_reference_at	stl_rope.h	/^	reference mutable_reference_at(size_type pos) {$/;"	f	class:rope	access:public	signature:(size_type pos)
rope::mutable_rend	stl_rope.h	/^	reverse_iterator mutable_rend() {$/;"	f	class:rope	access:public	signature:()
rope::operator =	stl_rope.h	/^	rope& operator=(const rope& x)$/;"	f	class:rope	access:public	signature:(const rope& x)
rope::operator []	stl_rope.h	/^	    reference operator[] (size_type pos) {$/;"	f	class:rope	access:public	signature:(size_type pos)
rope::operator []	stl_rope.h	/^	charT operator[] (size_type pos) const {$/;"	f	class:rope	access:public	signature:(size_type pos) const
rope::pointer	stl_rope.h	/^	typedef __rope_charT_ptr_proxy<charT,Alloc> pointer;$/;"	t	class:rope	access:public
rope::pop_back	stl_rope.h	/^	void pop_back()$/;"	f	class:rope	access:public	signature:()
rope::pop_front	stl_rope.h	/^	void pop_front()$/;"	f	class:rope	access:public	signature:()
rope::push_back	stl_rope.h	/^	void push_back(charT x)$/;"	f	class:rope	access:public	signature:(charT x)
rope::push_front	stl_rope.h	/^	void push_front(charT x)$/;"	f	class:rope	access:public	signature:(charT x)
rope::rbegin	stl_rope.h	/^	    const_reverse_iterator rbegin() { return const_rbegin(); }$/;"	f	class:rope	access:public	signature:()
rope::rbegin	stl_rope.h	/^	    reverse_iterator rbegin() { return mutable_rbegin(); }$/;"	f	class:rope	access:public	signature:()
rope::rbegin	stl_rope.h	/^	const_reverse_iterator rbegin() const {$/;"	f	class:rope	access:public	signature:() const
rope::ref	stl_rope.h	/^	  static void ref(RopeBase* t) {}$/;"	f	class:rope	access:protected	signature:(RopeBase* t)
rope::ref	stl_rope.h	/^	  static void ref(RopeBase* t)$/;"	f	class:rope	access:protected	signature:(RopeBase* t)
rope::reference	stl_rope.h	/^	typedef __rope_charT_ref_proxy<charT,Alloc> reference;$/;"	t	class:rope	access:public
rope::rend	stl_rope.h	/^	    const_reverse_iterator rend() { return const_rend(); }$/;"	f	class:rope	access:public	signature:()
rope::rend	stl_rope.h	/^	    reverse_iterator rend() { return mutable_rend(); }$/;"	f	class:rope	access:public	signature:()
rope::rend	stl_rope.h	/^	const_reverse_iterator rend() const {$/;"	f	class:rope	access:public	signature:() const
rope::replace	stl_rope.h	/^	static RopeBase * replace(RopeBase *old, size_t pos1,$/;"	f	class:rope	access:protected	signature:(RopeBase *old, size_t pos1, size_t pos2, RopeBase *r)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, charT c)$/;"	f	class:rope	access:public	signature:(const iterator& p, charT c)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, const charT * c_string)$/;"	f	class:rope	access:public	signature:(const iterator& p, const charT * c_string)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, const charT *i, const charT *j)$/;"	f	class:rope	access:public	signature:(const iterator& p, const charT *i, const charT *j)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, const charT *i, size_t n)$/;"	f	class:rope	access:public	signature:(const iterator& p, const charT *i, size_t n)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q, charT c)$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, charT c)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, const charT * c_string)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, const charT *i, const charT *j)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, const charT *i, size_t n)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, const const_iterator& i, const const_iterator& j)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, const iterator& i, const iterator& j)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope	access:public	signature:(const iterator& p, const iterator& q, const rope& r)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, const rope& r)$/;"	f	class:rope	access:public	signature:(const iterator& p, const rope& r)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, const_iterator i, const_iterator j)$/;"	f	class:rope	access:public	signature:(const iterator& p, const_iterator i, const_iterator j)
rope::replace	stl_rope.h	/^	void replace(const iterator& p, iterator i, iterator j)$/;"	f	class:rope	access:public	signature:(const iterator& p, iterator i, iterator j)
rope::replace	stl_rope.h	/^	void replace(size_t p, charT c) {$/;"	f	class:rope	access:public	signature:(size_t p, charT c)
rope::replace	stl_rope.h	/^	void replace(size_t p, const charT *c_string) {$/;"	f	class:rope	access:public	signature:(size_t p, const charT *c_string)
rope::replace	stl_rope.h	/^	void replace(size_t p, const charT *i, const charT *j) {$/;"	f	class:rope	access:public	signature:(size_t p, const charT *i, const charT *j)
rope::replace	stl_rope.h	/^	void replace(size_t p, const charT *i, size_t i_len) {$/;"	f	class:rope	access:public	signature:(size_t p, const charT *i, size_t i_len)
rope::replace	stl_rope.h	/^	void replace(size_t p, const const_iterator& i,$/;"	f	class:rope	access:public	signature:(size_t p, const const_iterator& i, const const_iterator& j)
rope::replace	stl_rope.h	/^	void replace(size_t p, const iterator& i,$/;"	f	class:rope	access:public	signature:(size_t p, const iterator& i, const iterator& j)
rope::replace	stl_rope.h	/^	void replace(size_t p, const rope& r) {$/;"	f	class:rope	access:public	signature:(size_t p, const rope& r)
rope::replace	stl_rope.h	/^	void replace(size_t p, size_t n, charT c) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, charT c)
rope::replace	stl_rope.h	/^	void replace(size_t p, size_t n, const charT *c_string) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, const charT *c_string)
rope::replace	stl_rope.h	/^	void replace(size_t p, size_t n, const charT *i, const charT *j) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, const charT *i, const charT *j)
rope::replace	stl_rope.h	/^	void replace(size_t p, size_t n, const charT *i, size_t i_len) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, const charT *i, size_t i_len)
rope::replace	stl_rope.h	/^	void replace(size_t p, size_t n, const rope& r) {$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, const rope& r)
rope::replace	stl_rope.h	/^	void replace(size_t p, size_t n,$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, const const_iterator& i, const const_iterator& j)
rope::replace	stl_rope.h	/^	void replace(size_t p, size_t n,$/;"	f	class:rope	access:public	signature:(size_t p, size_t n, const iterator& i, const iterator& j)
rope::replace_with_c_str	ropeimpl.h	/^const charT * rope<charT,Alloc>::replace_with_c_str() {$/;"	f	class:rope	signature:()
rope::replace_with_c_str	stl_rope.h	/^	const charT * replace_with_c_str();$/;"	p	class:rope	access:public	signature:()
rope::reserve	stl_rope.h	/^	    void reserve(size_type res_arg = 0) {}$/;"	f	class:rope	access:public	signature:(size_type res_arg = 0)
rope::resize	stl_rope.h	/^	    void resize(size_type n) {}$/;"	f	class:rope	access:public	signature:(size_type n)
rope::resize	stl_rope.h	/^	    void resize(size_type n, charT c) {}$/;"	f	class:rope	access:public	signature:(size_type n, charT c)
rope::reverse_iterator	stl_rope.h	/^				 difference_type>  reverse_iterator;$/;"	t	class:rope	access:public
rope::reverse_iterator	stl_rope.h	/^        typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:rope	access:public
rope::rope	ropeimpl.h	/^rope<charT, Alloc>::rope(size_t n, charT c)$/;"	f	class:rope	signature:(size_t n, charT c)
rope::rope	stl_rope.h	/^	rope()$/;"	f	class:rope	access:public	signature:()
rope::rope	stl_rope.h	/^	rope(RopeBase *t) : tree_ptr(t) { }$/;"	f	class:rope	access:protected	signature:(RopeBase *t)
rope::rope	stl_rope.h	/^	rope(charT c)$/;"	f	class:rope	access:public	signature:(charT c)
rope::rope	stl_rope.h	/^	rope(char_producer<charT> *fn, size_t len, bool delete_fn)$/;"	f	class:rope	access:public	signature:(char_producer<charT> *fn, size_t len, bool delete_fn)
rope::rope	stl_rope.h	/^	rope(const charT *i, const charT *j)$/;"	f	class:rope	access:public	signature:(const charT *i, const charT *j)
rope::rope	stl_rope.h	/^	rope(const charT *s)$/;"	f	class:rope	access:public	signature:(const charT *s)
rope::rope	stl_rope.h	/^	rope(const charT *s, charT *e)$/;"	f	class:rope	access:public	signature:(const charT *s, charT *e)
rope::rope	stl_rope.h	/^	rope(const charT *s, size_t len)$/;"	f	class:rope	access:public	signature:(const charT *s, size_t len)
rope::rope	stl_rope.h	/^	rope(const const_iterator& s, const const_iterator& e)$/;"	f	class:rope	access:public	signature:(const const_iterator& s, const const_iterator& e)
rope::rope	stl_rope.h	/^	rope(const iterator& s, const iterator& e)$/;"	f	class:rope	access:public	signature:(const iterator& s, const iterator& e)
rope::rope	stl_rope.h	/^	rope(const rope &x)$/;"	f	class:rope	access:public	signature:(const rope &x)
rope::rope	stl_rope.h	/^	rope(size_t n, charT c);$/;"	p	class:rope	access:public	signature:(size_t n, charT c)
rope::rounded_up_size	stl_rope.h	/^	static size_t rounded_up_size(size_t n) {$/;"	f	class:rope	access:protected	signature:(size_t n)
rope::self_destruct_ptr	stl_rope.h	/^	    typedef __rope_RopeBase<charT,Alloc> * self_destruct_ptr;$/;"	t	class:rope	access:protected
rope::self_destruct_ptr	stl_rope.h	/^	    typedef __rope_self_destruct_ptr<charT,Alloc> self_destruct_ptr;$/;"	t	class:rope	access:protected
rope::size	stl_rope.h	/^	size_type size() const { $/;"	f	class:rope	access:public	signature:() const
rope::size_type	stl_rope.h	/^	typedef size_t size_type;$/;"	t	class:rope	access:public
rope::substr	stl_rope.h	/^	rope substr(const_iterator start, const_iterator end) const {$/;"	f	class:rope	access:public	signature:(const_iterator start, const_iterator end) const
rope::substr	stl_rope.h	/^	rope substr(iterator start) const {$/;"	f	class:rope	access:public	signature:(iterator start) const
rope::substr	stl_rope.h	/^	rope substr(iterator start, iterator end) const {$/;"	f	class:rope	access:public	signature:(iterator start, iterator end) const
rope::substr	stl_rope.h	/^	rope substr(size_t start, size_t len = 1) const {$/;"	f	class:rope	access:public	signature:(size_t start, size_t len = 1) const
rope::substr	stl_rope.h	/^	rope<charT,Alloc> substr(const_iterator start) {$/;"	f	class:rope	access:public	signature:(const_iterator start)
rope::substring	ropeimpl.h	/^rope<charT,Alloc>::substring(RopeBase * base, size_t start, size_t endp1)$/;"	f	class:rope	signature:(RopeBase * base, size_t start, size_t endp1)
rope::substring	stl_rope.h	/^	static RopeBase * substring(RopeBase * base,$/;"	p	class:rope	access:protected	signature:(RopeBase * base, size_t start, size_t endp1)
rope::swap	stl_rope.h	/^	void swap(rope& b) {$/;"	f	class:rope	access:public	signature:(rope& b)
rope::swap_lock	ropeimpl.h	/^    pthread_mutex_t rope<charT,Alloc>::swap_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	m	class:rope
rope::swap_lock	stl_rope.h	/^	    static pthread_mutex_t swap_lock;$/;"	m	class:rope	access:protected
rope::tree_concat	ropeimpl.h	/^rope<charT,Alloc>::tree_concat (RopeBase * left, RopeBase * right)$/;"	f	class:rope	signature:(RopeBase * left, RopeBase * right)
rope::tree_concat	stl_rope.h	/^	static RopeBase * tree_concat(RopeBase * left, RopeBase * right);$/;"	p	class:rope	access:protected	signature:(RopeBase * left, RopeBase * right)
rope::tree_ptr	stl_rope.h	/^	RopeBase *tree_ptr;$/;"	m	class:rope	access:protected
rope::unref	stl_rope.h	/^	  static void unref(RopeBase* t) {}$/;"	f	class:rope	access:protected	signature:(RopeBase* t)
rope::unref	stl_rope.h	/^	  static void unref(RopeBase* t)$/;"	f	class:rope	access:protected	signature:(RopeBase* t)
rope::value_type	stl_rope.h	/^	typedef charT value_type;$/;"	t	class:rope	access:public
rope::~rope	stl_rope.h	/^	~rope()$/;"	f	class:rope	access:public	signature:()
rotate	ropeimpl.h	/^inline void rotate(__rope_iterator<char,__ALLOC> first,$/;"	f	signature:(__rope_iterator<char,__ALLOC> first, __rope_iterator<char,__ALLOC> middle, __rope_iterator<char,__ALLOC> last)
rotate	stl_algo.h	/^inline void rotate(ForwardIterator first, ForwardIterator middle,$/;"	f	signature:(ForwardIterator first, ForwardIterator middle, ForwardIterator last)
rotate_copy	stl_algo.h	/^OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle,$/;"	f	signature:(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result)
rounded_up_size	stl_rope.h	/^	static size_t rounded_up_size(size_t n) {$/;"	f	class:rope	access:protected	signature:(size_t n)
rounded_up_size	stl_rope.h	/^    static size_t rounded_up_size(size_t n) {$/;"	f	struct:__rope_RopeBase	access:public	signature:(size_t n)
search	stl_algo.h	/^inline ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f	signature:(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
search	stl_algo.h	/^inline ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f	signature:(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate binary_pred)
search_n	stl_algo.h	/^ForwardIterator search_n(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, Integer count, const T& value)
search_n	stl_algo.h	/^ForwardIterator search_n(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, Integer count, const T& value, BinaryPredicate binary_pred)
second	stl_pair.h	/^  T2 second;$/;"	m	struct:pair	access:public
second_argument_type	stl_function.h	/^    typedef Arg2 second_argument_type;$/;"	t	struct:binary_function	access:public
second_type	stl_pair.h	/^  typedef T2 second_type;$/;"	t	struct:pair	access:public
select1st	stl_function.h	/^struct select1st : public unary_function<Pair, typename Pair::first_type> {$/;"	s	inherits:unary_function
select1st::operator ()	stl_function.h	/^  const typename Pair::first_type& operator()(const Pair& x) const$/;"	f	struct:select1st	access:public	signature:(const Pair& x) const
select2nd	stl_function.h	/^struct select2nd : public unary_function<Pair, typename Pair::second_type> {$/;"	s	inherits:unary_function
select2nd::operator ()	stl_function.h	/^  const typename Pair::second_type& operator()(const Pair& x) const$/;"	f	struct:select2nd	access:public	signature:(const Pair& x) const
self	stl_deque.h	/^  typedef __deque_iterator self;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
self	stl_iterator.h	/^                                         Distance> self;$/;"	t	class:reverse_bidirectional_iterator	access:private
self	stl_iterator.h	/^        self;$/;"	t	class:reverse_iterator	access:private
self	stl_iterator.h	/^  typedef reverse_iterator<Iterator> self;$/;"	t	class:reverse_iterator	access:public
self	stl_list.h	/^  typedef __list_iterator<T, Ref, Ptr>           self;$/;"	t	struct:__list_iterator	access:public
self	stl_slist.h	/^  typedef __slist_iterator<T, Ref, Ptr>           self;$/;"	t	struct:__slist_iterator	access:public
self	stl_tree.h	/^  typedef __rb_tree_iterator<Value, Ref, Ptr>                   self;$/;"	t	struct:__rb_tree_iterator	access:public
self_destruct_ptr	stl_rope.h	/^	    typedef __rope_RopeBase<charT,Alloc> * self_destruct_ptr;$/;"	t	class:rope	access:protected
self_destruct_ptr	stl_rope.h	/^	    typedef __rope_self_destruct_ptr<charT,Alloc> self_destruct_ptr;$/;"	t	class:rope	access:protected
self_destruct_ptr	stl_rope.h	/^	typedef __rope_RopeBase<charT,Alloc> * self_destruct_ptr;$/;"	t	class:__rope_charT_ref_proxy	access:private
self_destruct_ptr	stl_rope.h	/^    	typedef __rope_self_destruct_ptr<charT,Alloc> self_destruct_ptr;$/;"	t	class:__rope_charT_ref_proxy	access:private
sequence_buffer	stl_rope.h	/^	sequence_buffer() : prefix(0), buf_count(0) {}$/;"	f	class:sequence_buffer	access:public	signature:()
sequence_buffer	stl_rope.h	/^	sequence_buffer(const sequence_buffer & x) {$/;"	f	class:sequence_buffer	access:public	signature:(const sequence_buffer & x)
sequence_buffer	stl_rope.h	/^	sequence_buffer(sequence& s) : prefix(&s), buf_count(0) {}$/;"	f	class:sequence_buffer	access:public	signature:(sequence& s)
sequence_buffer	stl_rope.h	/^	sequence_buffer(sequence_buffer & x) {$/;"	f	class:sequence_buffer	access:public	signature:(sequence_buffer & x)
sequence_buffer	stl_rope.h	/^class sequence_buffer : public output_iterator {$/;"	c	inherits:output_iterator
sequence_buffer::append	stl_rope.h	/^	void append(value_type *s, size_t len)$/;"	f	class:sequence_buffer	access:public	signature:(value_type *s, size_t len)
sequence_buffer::buf_count	stl_rope.h	/^	size_t buf_count;$/;"	m	class:sequence_buffer	access:protected
sequence_buffer::buffer	stl_rope.h	/^	value_type buffer[buf_sz];$/;"	m	class:sequence_buffer	access:protected
sequence_buffer::flush	stl_rope.h	/^	void flush() {$/;"	f	class:sequence_buffer	access:public	signature:()
sequence_buffer::operator *	stl_rope.h	/^	sequence_buffer& operator*() { return *this; }$/;"	f	class:sequence_buffer	access:public	signature:()
sequence_buffer::operator ++	stl_rope.h	/^	sequence_buffer& operator++() { return *this; }$/;"	f	class:sequence_buffer	access:public	signature:()
sequence_buffer::operator ++	stl_rope.h	/^	sequence_buffer& operator++(int) { return *this; }$/;"	f	class:sequence_buffer	access:public	signature:(int)
sequence_buffer::operator =	stl_rope.h	/^	sequence_buffer& operator= (const sequence_buffer& x) {$/;"	f	class:sequence_buffer	access:public	signature:(const sequence_buffer& x)
sequence_buffer::operator =	stl_rope.h	/^	sequence_buffer& operator= (sequence_buffer& x) {$/;"	f	class:sequence_buffer	access:public	signature:(sequence_buffer& x)
sequence_buffer::operator =	stl_rope.h	/^	sequence_buffer& operator=(const value_type& rhs)$/;"	f	class:sequence_buffer	access:public	signature:(const value_type& rhs)
sequence_buffer::prefix	stl_rope.h	/^	sequence *prefix;$/;"	m	class:sequence_buffer	access:protected
sequence_buffer::push_back	stl_rope.h	/^	void push_back(value_type x)$/;"	f	class:sequence_buffer	access:public	signature:(value_type x)
sequence_buffer::put	stl_rope.h	/^	sequence_buffer& put(value_type x)$/;"	f	class:sequence_buffer	access:public	signature:(value_type x)
sequence_buffer::sequence_buffer	stl_rope.h	/^	sequence_buffer() : prefix(0), buf_count(0) {}$/;"	f	class:sequence_buffer	access:public	signature:()
sequence_buffer::sequence_buffer	stl_rope.h	/^	sequence_buffer(const sequence_buffer & x) {$/;"	f	class:sequence_buffer	access:public	signature:(const sequence_buffer & x)
sequence_buffer::sequence_buffer	stl_rope.h	/^	sequence_buffer(sequence& s) : prefix(&s), buf_count(0) {}$/;"	f	class:sequence_buffer	access:public	signature:(sequence& s)
sequence_buffer::sequence_buffer	stl_rope.h	/^	sequence_buffer(sequence_buffer & x) {$/;"	f	class:sequence_buffer	access:public	signature:(sequence_buffer & x)
sequence_buffer::value_type	stl_rope.h	/^	    typedef typename sequence::value_type value_type;$/;"	t	class:sequence_buffer	access:public
sequence_buffer::write	stl_rope.h	/^	sequence_buffer& write(value_type *s, size_t len)$/;"	f	class:sequence_buffer	access:public	signature:(value_type *s, size_t len)
sequence_buffer::~sequence_buffer	stl_rope.h	/^	~sequence_buffer() { flush(); }$/;"	f	class:sequence_buffer	access:public	signature:()
set	stl_set.h	/^  explicit set(const Compare& comp) : t(comp) {}$/;"	f	class:set	access:public	signature:(const Compare& comp)
set	stl_set.h	/^  set() : t(Compare()) {}$/;"	f	class:set	access:public	signature:()
set	stl_set.h	/^  set(InputIterator first, InputIterator last)$/;"	f	class:set	access:public	signature:(InputIterator first, InputIterator last)
set	stl_set.h	/^  set(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:set	access:public	signature:(InputIterator first, InputIterator last, const Compare& comp)
set	stl_set.h	/^  set(const set<Key, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:set	access:public	signature:(const set<Key, Compare, Alloc>& x)
set	stl_set.h	/^  set(const value_type* first, const value_type* last) $/;"	f	class:set	access:public	signature:(const value_type* first, const value_type* last)
set	stl_set.h	/^  set(const value_type* first, const value_type* last, const Compare& comp)$/;"	f	class:set	access:public	signature:(const value_type* first, const value_type* last, const Compare& comp)
set	stl_set.h	/^  set(const_iterator first, const_iterator last)$/;"	f	class:set	access:public	signature:(const_iterator first, const_iterator last)
set	stl_set.h	/^  set(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:set	access:public	signature:(const_iterator first, const_iterator last, const Compare& comp)
set	stl_set.h	/^class set {$/;"	c
set::__STL_NULL_TMPL_ARGS	stl_set.h	/^  friend bool operator< __STL_NULL_TMPL_ARGS (const set&, const set&);$/;"	p	class:set	access:friend	signature:(const set&, const set&)
set::__STL_NULL_TMPL_ARGS	stl_set.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const set&, const set&);$/;"	p	class:set	access:friend	signature:(const set&, const set&)
set::begin	stl_set.h	/^  iterator begin() const { return t.begin(); }$/;"	f	class:set	access:public	signature:() const
set::clear	stl_set.h	/^  void clear() { t.clear(); }$/;"	f	class:set	access:public	signature:()
set::const_iterator	stl_set.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:set	access:public
set::const_pointer	stl_set.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:set	access:public
set::const_reference	stl_set.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:set	access:public
set::const_reverse_iterator	stl_set.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:set	access:public
set::count	stl_set.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:set	access:public	signature:(const key_type& x) const
set::difference_type	stl_set.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:set	access:public
set::empty	stl_set.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:set	access:public	signature:() const
set::end	stl_set.h	/^  iterator end() const { return t.end(); }$/;"	f	class:set	access:public	signature:() const
set::equal_range	stl_set.h	/^  pair<iterator,iterator> equal_range(const key_type& x) const {$/;"	f	class:set	access:public	signature:(const key_type& x) const
set::erase	stl_set.h	/^  size_type erase(const key_type& x) { $/;"	f	class:set	access:public	signature:(const key_type& x)
set::erase	stl_set.h	/^  void erase(iterator first, iterator last) { $/;"	f	class:set	access:public	signature:(iterator first, iterator last)
set::erase	stl_set.h	/^  void erase(iterator position) { $/;"	f	class:set	access:public	signature:(iterator position)
set::find	stl_set.h	/^  iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:set	access:public	signature:(const key_type& x) const
set::insert	stl_set.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:set	access:public	signature:(iterator position, const value_type& x)
set::insert	stl_set.h	/^  pair<iterator,bool> insert(const value_type& x) { $/;"	f	class:set	access:public	signature:(const value_type& x)
set::insert	stl_set.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:set	access:public	signature:(InputIterator first, InputIterator last)
set::insert	stl_set.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:set	access:public	signature:(const value_type* first, const value_type* last)
set::insert	stl_set.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:set	access:public	signature:(const_iterator first, const_iterator last)
set::iterator	stl_set.h	/^  typedef typename rep_type::const_iterator iterator;$/;"	t	class:set	access:public
set::key_comp	stl_set.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:set	access:public	signature:() const
set::key_compare	stl_set.h	/^  typedef Compare key_compare;$/;"	t	class:set	access:public
set::key_type	stl_set.h	/^  typedef Key key_type;$/;"	t	class:set	access:public
set::lower_bound	stl_set.h	/^  iterator lower_bound(const key_type& x) const {$/;"	f	class:set	access:public	signature:(const key_type& x) const
set::max_size	stl_set.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:set	access:public	signature:() const
set::operator =	stl_set.h	/^  set<Key, Compare, Alloc>& operator=(const set<Key, Compare, Alloc>& x) { $/;"	f	class:set	access:public	signature:(const set<Key, Compare, Alloc>& x)
set::pair_iterator_bool	stl_set.h	/^  typedef  pair<iterator, bool> pair_iterator_bool; $/;"	t	class:set	access:public
set::pointer	stl_set.h	/^  typedef typename rep_type::const_pointer pointer;$/;"	t	class:set	access:public
set::rbegin	stl_set.h	/^  reverse_iterator rbegin() const { return t.rbegin(); } $/;"	f	class:set	access:public	signature:() const
set::reference	stl_set.h	/^  typedef typename rep_type::const_reference reference;$/;"	t	class:set	access:public
set::rend	stl_set.h	/^  reverse_iterator rend() const { return t.rend(); }$/;"	f	class:set	access:public	signature:() const
set::rep_type	stl_set.h	/^                  identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:set	access:private
set::reverse_iterator	stl_set.h	/^  typedef typename rep_type::const_reverse_iterator reverse_iterator;$/;"	t	class:set	access:public
set::set	stl_set.h	/^  explicit set(const Compare& comp) : t(comp) {}$/;"	f	class:set	access:public	signature:(const Compare& comp)
set::set	stl_set.h	/^  set() : t(Compare()) {}$/;"	f	class:set	access:public	signature:()
set::set	stl_set.h	/^  set(InputIterator first, InputIterator last)$/;"	f	class:set	access:public	signature:(InputIterator first, InputIterator last)
set::set	stl_set.h	/^  set(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:set	access:public	signature:(InputIterator first, InputIterator last, const Compare& comp)
set::set	stl_set.h	/^  set(const set<Key, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:set	access:public	signature:(const set<Key, Compare, Alloc>& x)
set::set	stl_set.h	/^  set(const value_type* first, const value_type* last) $/;"	f	class:set	access:public	signature:(const value_type* first, const value_type* last)
set::set	stl_set.h	/^  set(const value_type* first, const value_type* last, const Compare& comp)$/;"	f	class:set	access:public	signature:(const value_type* first, const value_type* last, const Compare& comp)
set::set	stl_set.h	/^  set(const_iterator first, const_iterator last)$/;"	f	class:set	access:public	signature:(const_iterator first, const_iterator last)
set::set	stl_set.h	/^  set(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:set	access:public	signature:(const_iterator first, const_iterator last, const Compare& comp)
set::size	stl_set.h	/^  size_type size() const { return t.size(); }$/;"	f	class:set	access:public	signature:() const
set::size_type	stl_set.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:set	access:public
set::swap	stl_set.h	/^  void swap(set<Key, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:set	access:public	signature:(set<Key, Compare, Alloc>& x)
set::t	stl_set.h	/^  rep_type t;  \/\/ red-black tree representing set$/;"	m	class:set	access:private
set::upper_bound	stl_set.h	/^  iterator upper_bound(const key_type& x) const {$/;"	f	class:set	access:public	signature:(const key_type& x) const
set::value_comp	stl_set.h	/^  value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:set	access:public	signature:() const
set::value_compare	stl_set.h	/^  typedef Compare value_compare;$/;"	t	class:set	access:public
set::value_type	stl_set.h	/^  typedef Key value_type;$/;"	t	class:set	access:public
set_difference	stl_algo.h	/^OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)
set_difference	stl_algo.h	/^OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp)
set_intersection	stl_algo.h	/^OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)
set_intersection	stl_algo.h	/^OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp)
set_malloc_handler	stl_alloc.h	/^static void (* set_malloc_handler(void (*f)()))()$/;"	f	class:__malloc_alloc_template	access:public	signature:(void (*f)())
set_node	stl_deque.h	/^  void set_node(map_pointer new_node) {$/;"	f	struct:__deque_iterator::__deque_iterator	access:public	signature:(map_pointer new_node)
set_symmetric_difference	stl_algo.h	/^OutputIterator set_symmetric_difference(InputIterator1 first1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)
set_symmetric_difference	stl_algo.h	/^OutputIterator set_symmetric_difference(InputIterator1 first1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp)
set_union	stl_algo.h	/^OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)
set_union	stl_algo.h	/^OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp)
setbuf	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setbuf$/;"	f	class:__rope_iterator_base	signature:(__rope_iterator_base<charT,Alloc> &x)
setbuf	stl_rope.h	/^    static void setbuf(__rope_iterator_base &x);$/;"	p	class:__rope_iterator_base	access:protected	signature:(__rope_iterator_base &x)
setcache	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setcache$/;"	f	class:__rope_iterator_base	signature:(__rope_iterator_base<charT,Alloc> &x)
setcache	stl_rope.h	/^    static void setcache(__rope_iterator_base &x);$/;"	p	class:__rope_iterator_base	access:protected	signature:(__rope_iterator_base &x)
setcache_for_incr	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setcache_for_incr$/;"	f	class:__rope_iterator_base	signature:(__rope_iterator_base<charT,Alloc> &x)
setcache_for_incr	stl_rope.h	/^    static void setcache_for_incr(__rope_iterator_base &x);$/;"	p	class:__rope_iterator_base	access:protected	signature:(__rope_iterator_base &x)
simple_alloc	stl_alloc.h	/^class simple_alloc {$/;"	c
simple_alloc::allocate	stl_alloc.h	/^    static T *allocate(size_t n)$/;"	f	class:simple_alloc	access:public	signature:(size_t n)
simple_alloc::allocate	stl_alloc.h	/^    static T *allocate(void)$/;"	f	class:simple_alloc	access:public	signature:(void)
simple_alloc::deallocate	stl_alloc.h	/^    static void deallocate(T *p)$/;"	f	class:simple_alloc	access:public	signature:(T *p)
simple_alloc::deallocate	stl_alloc.h	/^    static void deallocate(T *p, size_t n)$/;"	f	class:simple_alloc	access:public	signature:(T *p, size_t n)
single_client_alloc	stl_alloc.h	/^typedef __default_alloc_template<false, 0> single_client_alloc;$/;"	t
single_client_alloc	stl_alloc.h	/^typedef malloc_alloc single_client_alloc;$/;"	t
size	stl_bvector.h	/^  size_type size() const { return size_type(end() - begin()); }$/;"	f	class:vector	access:public	signature:() const
size	stl_deque.h	/^  size_type size() const { return finish - start;; }$/;"	f	class:__deque_iterator::deque	access:public	signature:() const
size	stl_hash_map.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_map	access:public	signature:() const
size	stl_hash_map.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_multimap	access:public	signature:() const
size	stl_hash_set.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_multiset	access:public	signature:() const
size	stl_hash_set.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_set	access:public	signature:() const
size	stl_hashtable.h	/^  size_type size() const { return num_elements; }$/;"	f	class:hashtable	access:public	signature:() const
size	stl_list.h	/^  size_type size() const {$/;"	f	class:list	access:public	signature:() const
size	stl_map.h	/^  size_type size() const { return t.size(); }$/;"	f	class:map	access:public	signature:() const
size	stl_multimap.h	/^  size_type size() const { return t.size(); }$/;"	f	class:multimap	access:public	signature:() const
size	stl_multiset.h	/^  size_type size() const { return t.size(); }$/;"	f	class:multiset	access:public	signature:() const
size	stl_queue.h	/^  size_type size() const { return c.size(); }$/;"	f	class:priority_queue	access:public	signature:() const
size	stl_queue.h	/^  size_type size() const { return c.size(); }$/;"	f	class:queue	access:public	signature:() const
size	stl_rope.h	/^	size_type size() const { $/;"	f	class:rope	access:public	signature:() const
size	stl_rope.h	/^    size_t size;$/;"	m	struct:__rope_RopeBase	access:public
size	stl_set.h	/^  size_type size() const { return t.size(); }$/;"	f	class:set	access:public	signature:() const
size	stl_slist.h	/^  size_type size() const { return __slist_size(head.next); }$/;"	f	class:slist	access:public	signature:() const
size	stl_stack.h	/^  size_type size() const { return c.size(); }$/;"	f	class:stack	access:public	signature:() const
size	stl_tempbuf.h	/^  ptrdiff_t size() const { return len; }$/;"	f	class:temporary_buffer	access:public	signature:() const
size	stl_tree.h	/^  size_type size() const { return node_count; }$/;"	f	class:rb_tree	access:public	signature:() const
size	stl_vector.h	/^  size_type size() const { return size_type(end() - begin()); }$/;"	f	class:vector	access:public	signature:() const
size_type	defalloc.h	/^    typedef size_t size_type;$/;"	t	class:allocator	access:public
size_type	stl_bvector.h	/^  typedef size_t size_type;$/;"	t	class:vector	access:public
size_type	stl_deque.h	/^  typedef size_t size_type;$/;"	t	class:__deque_iterator::deque	access:public
size_type	stl_deque.h	/^  typedef size_t size_type;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
size_type	stl_hash_map.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_map	access:public
size_type	stl_hash_map.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_multimap	access:public
size_type	stl_hash_set.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_multiset	access:public
size_type	stl_hash_set.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_set	access:public
size_type	stl_hashtable.h	/^  typedef size_t            size_type;$/;"	t	class:hashtable	access:public
size_type	stl_hashtable.h	/^  typedef size_t size_type;$/;"	t	struct:__hashtable_const_iterator	access:public
size_type	stl_hashtable.h	/^  typedef size_t size_type;$/;"	t	struct:__hashtable_iterator	access:public
size_type	stl_list.h	/^  typedef size_t size_type;$/;"	t	class:list	access:public
size_type	stl_list.h	/^  typedef size_t size_type;$/;"	t	struct:__list_iterator	access:public
size_type	stl_map.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:map	access:public
size_type	stl_multimap.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:multimap	access:public
size_type	stl_multiset.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:multiset	access:public
size_type	stl_queue.h	/^  typedef typename Sequence::size_type size_type;$/;"	t	class:priority_queue	access:public
size_type	stl_queue.h	/^  typedef typename Sequence::size_type size_type;$/;"	t	class:queue	access:public
size_type	stl_rope.h	/^	typedef size_t size_type;$/;"	t	class:rope	access:public
size_type	stl_set.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:set	access:public
size_type	stl_slist.h	/^  typedef size_t size_type;$/;"	t	class:slist	access:public
size_type	stl_slist.h	/^  typedef size_t size_type;$/;"	t	struct:__slist_iterator_base	access:public
size_type	stl_stack.h	/^  typedef typename Sequence::size_type size_type;$/;"	t	class:stack	access:public
size_type	stl_tree.h	/^  typedef size_t size_type;$/;"	t	class:rb_tree	access:public
size_type	stl_vector.h	/^  typedef size_t size_type;$/;"	t	class:vector	access:public
slist	stl_slist.h	/^  explicit slist(size_type n) { fill_initialize(n, value_type()); }$/;"	f	class:slist	access:public	signature:(size_type n)
slist	stl_slist.h	/^  slist() { head.next = 0; }$/;"	f	class:slist	access:public	signature:()
slist	stl_slist.h	/^  slist(InputIterator first, InputIterator last) {$/;"	f	class:slist	access:public	signature:(InputIterator first, InputIterator last)
slist	stl_slist.h	/^  slist(const slist& L) { range_initialize(L.begin(), L.end()); }$/;"	f	class:slist	access:public	signature:(const slist& L)
slist	stl_slist.h	/^  slist(const value_type* first, const value_type* last) {$/;"	f	class:slist	access:public	signature:(const value_type* first, const value_type* last)
slist	stl_slist.h	/^  slist(const_iterator first, const_iterator last) {$/;"	f	class:slist	access:public	signature:(const_iterator first, const_iterator last)
slist	stl_slist.h	/^  slist(int n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:slist	access:public	signature:(int n, const value_type& x)
slist	stl_slist.h	/^  slist(long n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:slist	access:public	signature:(long n, const value_type& x)
slist	stl_slist.h	/^  slist(size_type n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:slist	access:public	signature:(size_type n, const value_type& x)
slist	stl_slist.h	/^class slist$/;"	c
slist::__STL_NULL_TMPL_ARGS	stl_slist.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS(const slist<T, Alloc>& L1,$/;"	p	class:slist	access:friend	signature:(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)
slist::_insert_after	stl_slist.h	/^  list_node* _insert_after(list_node_base* pos, const value_type& x) {$/;"	f	class:slist	access:private	signature:(list_node_base* pos, const value_type& x)
slist::_insert_after_fill	stl_slist.h	/^  void _insert_after_fill(list_node_base* pos,$/;"	f	class:slist	access:private	signature:(list_node_base* pos, size_type n, const value_type& x)
slist::_insert_after_range	stl_slist.h	/^  void _insert_after_range(list_node_base* pos, InIter first, InIter last) {$/;"	f	class:slist	access:private	signature:(list_node_base* pos, InIter first, InIter last)
slist::_insert_after_range	stl_slist.h	/^  void _insert_after_range(list_node_base* pos,$/;"	f	class:slist	access:private	signature:(list_node_base* pos, const value_type* first, const value_type* last)
slist::_insert_after_range	stl_slist.h	/^  void _insert_after_range(list_node_base* pos,$/;"	f	class:slist	access:private	signature:(list_node_base* pos, const_iterator first, const_iterator last)
slist::begin	stl_slist.h	/^  const_iterator begin() const { return const_iterator((list_node*)head.next);}$/;"	f	class:slist	access:public	signature:() const
slist::begin	stl_slist.h	/^  iterator begin() { return iterator((list_node*)head.next); }$/;"	f	class:slist	access:public	signature:()
slist::clear	stl_slist.h	/^  void clear() { erase_after(&head, 0); }$/;"	f	class:slist	access:public	signature:()
slist::const_iterator	stl_slist.h	/^  typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	class:slist	access:public
slist::const_pointer	stl_slist.h	/^  typedef const value_type* const_pointer;$/;"	t	class:slist	access:public
slist::const_reference	stl_slist.h	/^  typedef const value_type& const_reference;$/;"	t	class:slist	access:public
slist::create_node	stl_slist.h	/^  static list_node* create_node(const value_type& x) {$/;"	f	class:slist	access:private	signature:(const value_type& x)
slist::destroy_node	stl_slist.h	/^  static void destroy_node(list_node* node) {$/;"	f	class:slist	access:private	signature:(list_node* node)
slist::difference_type	stl_slist.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:slist	access:public
slist::empty	stl_slist.h	/^  bool empty() const { return head.next == 0; }$/;"	f	class:slist	access:public	signature:() const
slist::end	stl_slist.h	/^  const_iterator end() const { return const_iterator(0); }$/;"	f	class:slist	access:public	signature:() const
slist::end	stl_slist.h	/^  iterator end() { return iterator(0); }$/;"	f	class:slist	access:public	signature:()
slist::erase	stl_slist.h	/^  iterator erase(iterator first, iterator last) {$/;"	f	class:slist	access:public	signature:(iterator first, iterator last)
slist::erase	stl_slist.h	/^  iterator erase(iterator pos) {$/;"	f	class:slist	access:public	signature:(iterator pos)
slist::erase_after	stl_slist.h	/^  iterator erase_after(iterator before_first, iterator last) {$/;"	f	class:slist	access:public	signature:(iterator before_first, iterator last)
slist::erase_after	stl_slist.h	/^  iterator erase_after(iterator pos) {$/;"	f	class:slist	access:public	signature:(iterator pos)
slist::erase_after	stl_slist.h	/^  list_node_base* erase_after(list_node_base* before_first,$/;"	f	class:slist	access:private	signature:(list_node_base* before_first, list_node_base* last_node)
slist::erase_after	stl_slist.h	/^  list_node_base* erase_after(list_node_base* pos) {$/;"	f	class:slist	access:private	signature:(list_node_base* pos)
slist::fill_initialize	stl_slist.h	/^  void fill_initialize(size_type n, const value_type& x) {$/;"	f	class:slist	access:private	signature:(size_type n, const value_type& x)
slist::front	stl_slist.h	/^  const_reference front() const { return ((list_node*) head.next)->data; }$/;"	f	class:slist	access:public	signature:() const
slist::front	stl_slist.h	/^  reference front() { return ((list_node*) head.next)->data; }$/;"	f	class:slist	access:public	signature:()
slist::head	stl_slist.h	/^  list_node_base head;$/;"	m	class:slist	access:private
slist::insert	stl_slist.h	/^  iterator insert(iterator pos) {$/;"	f	class:slist	access:public	signature:(iterator pos)
slist::insert	stl_slist.h	/^  iterator insert(iterator pos, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, const value_type& x)
slist::insert	stl_slist.h	/^  void insert(iterator pos, InIter first, InIter last) {$/;"	f	class:slist	access:public	signature:(iterator pos, InIter first, InIter last)
slist::insert	stl_slist.h	/^  void insert(iterator pos, const value_type* first, const value_type* last) {$/;"	f	class:slist	access:public	signature:(iterator pos, const value_type* first, const value_type* last)
slist::insert	stl_slist.h	/^  void insert(iterator pos, const_iterator first, const_iterator last) {$/;"	f	class:slist	access:public	signature:(iterator pos, const_iterator first, const_iterator last)
slist::insert	stl_slist.h	/^  void insert(iterator pos, int n, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, int n, const value_type& x)
slist::insert	stl_slist.h	/^  void insert(iterator pos, long n, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, long n, const value_type& x)
slist::insert	stl_slist.h	/^  void insert(iterator pos, size_type n, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, size_type n, const value_type& x)
slist::insert_after	stl_slist.h	/^  iterator insert_after(iterator pos) {$/;"	f	class:slist	access:public	signature:(iterator pos)
slist::insert_after	stl_slist.h	/^  iterator insert_after(iterator pos, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, const value_type& x)
slist::insert_after	stl_slist.h	/^  void insert_after(iterator pos, InIter first, InIter last) {$/;"	f	class:slist	access:public	signature:(iterator pos, InIter first, InIter last)
slist::insert_after	stl_slist.h	/^  void insert_after(iterator pos, const_iterator first, const_iterator last) {$/;"	f	class:slist	access:public	signature:(iterator pos, const_iterator first, const_iterator last)
slist::insert_after	stl_slist.h	/^  void insert_after(iterator pos, int n, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, int n, const value_type& x)
slist::insert_after	stl_slist.h	/^  void insert_after(iterator pos, long n, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, long n, const value_type& x)
slist::insert_after	stl_slist.h	/^  void insert_after(iterator pos, size_type n, const value_type& x) {$/;"	f	class:slist	access:public	signature:(iterator pos, size_type n, const value_type& x)
slist::insert_after	stl_slist.h	/^  void insert_after(iterator pos,$/;"	f	class:slist	access:public	signature:(iterator pos, const value_type* first, const value_type* last)
slist::iterator	stl_slist.h	/^  typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	class:slist	access:public
slist::iterator_base	stl_slist.h	/^  typedef __slist_iterator_base iterator_base;$/;"	t	class:slist	access:private
slist::list_node	stl_slist.h	/^  typedef __slist_node<T> list_node;$/;"	t	class:slist	access:private
slist::list_node_allocator	stl_slist.h	/^  typedef simple_alloc<list_node, Alloc> list_node_allocator;$/;"	t	class:slist	access:private
slist::list_node_base	stl_slist.h	/^  typedef __slist_node_base list_node_base;$/;"	t	class:slist	access:private
slist::max_size	stl_slist.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:slist	access:public	signature:() const
slist::merge	stl_slist.h	/^  template <class StrictWeakOrdering> void merge(slist&, StrictWeakOrdering); $/;"	p	class:slist	access:public	signature:(slist&, StrictWeakOrdering)
slist::merge	stl_slist.h	/^  void merge(slist& L);$/;"	p	class:slist	access:public	signature:(slist& L)
slist::merge	stl_slist.h	/^void slist<T,Alloc>::merge(slist<T,Alloc>& L)$/;"	f	class:slist	signature:(slist<T,Alloc>& L)
slist::merge	stl_slist.h	/^void slist<T,Alloc>::merge(slist<T,Alloc>& L, StrictWeakOrdering comp)$/;"	f	class:slist	signature:(slist<T,Alloc>& L, StrictWeakOrdering comp)
slist::operator =	stl_slist.h	/^  slist& operator= (const slist& L);$/;"	p	class:slist	access:public	signature:(const slist& L)
slist::operator =	stl_slist.h	/^slist<T, Alloc>& slist<T,Alloc>::operator=(const slist<T, Alloc>& L)$/;"	f	class:slist	signature:(const slist<T, Alloc>& L)
slist::pointer	stl_slist.h	/^  typedef value_type* pointer;$/;"	t	class:slist	access:public
slist::pop_front	stl_slist.h	/^  void pop_front() {$/;"	f	class:slist	access:public	signature:()
slist::previous	stl_slist.h	/^  const_iterator previous(const_iterator pos) const {$/;"	f	class:slist	access:public	signature:(const_iterator pos) const
slist::previous	stl_slist.h	/^  iterator previous(const_iterator pos) {$/;"	f	class:slist	access:public	signature:(const_iterator pos)
slist::push_front	stl_slist.h	/^  void push_front(const value_type& x)   {$/;"	f	class:slist	access:public	signature:(const value_type& x)
slist::range_initialize	stl_slist.h	/^  void range_initialize(InputIterator first, InputIterator last) {$/;"	f	class:slist	access:private	signature:(InputIterator first, InputIterator last)
slist::range_initialize	stl_slist.h	/^  void range_initialize(const value_type* first, const value_type* last) {$/;"	f	class:slist	access:private	signature:(const value_type* first, const value_type* last)
slist::range_initialize	stl_slist.h	/^  void range_initialize(const_iterator first, const_iterator last) {$/;"	f	class:slist	access:private	signature:(const_iterator first, const_iterator last)
slist::reference	stl_slist.h	/^  typedef value_type& reference;$/;"	t	class:slist	access:public
slist::remove	stl_slist.h	/^  void remove(const T& val); $/;"	p	class:slist	access:public	signature:(const T& val)
slist::remove	stl_slist.h	/^void slist<T,Alloc>::remove(const T& val)$/;"	f	class:slist	signature:(const T& val)
slist::remove_if	stl_slist.h	/^  template <class Predicate> void remove_if(Predicate pred);$/;"	p	class:slist	access:public	signature:(Predicate pred)
slist::remove_if	stl_slist.h	/^template <class Predicate> void slist<T,Alloc>::remove_if(Predicate pred)$/;"	f	class:slist	signature:(Predicate pred)
slist::resize	stl_slist.h	/^  void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:slist	access:public	signature:(size_type new_size)
slist::resize	stl_slist.h	/^  void resize(size_type new_size, const T& x);$/;"	p	class:slist	access:public	signature:(size_type new_size, const T& x)
slist::resize	stl_slist.h	/^void slist<T, Alloc>::resize(size_type len, const T& x)$/;"	f	class:slist	signature:(size_type len, const T& x)
slist::reverse	stl_slist.h	/^  void reverse() { if (head.next) head.next = __slist_reverse(head.next); }$/;"	f	class:slist	access:public	signature:()
slist::size	stl_slist.h	/^  size_type size() const { return __slist_size(head.next); }$/;"	f	class:slist	access:public	signature:() const
slist::size_type	stl_slist.h	/^  typedef size_t size_type;$/;"	t	class:slist	access:public
slist::slist	stl_slist.h	/^  explicit slist(size_type n) { fill_initialize(n, value_type()); }$/;"	f	class:slist	access:public	signature:(size_type n)
slist::slist	stl_slist.h	/^  slist() { head.next = 0; }$/;"	f	class:slist	access:public	signature:()
slist::slist	stl_slist.h	/^  slist(InputIterator first, InputIterator last) {$/;"	f	class:slist	access:public	signature:(InputIterator first, InputIterator last)
slist::slist	stl_slist.h	/^  slist(const slist& L) { range_initialize(L.begin(), L.end()); }$/;"	f	class:slist	access:public	signature:(const slist& L)
slist::slist	stl_slist.h	/^  slist(const value_type* first, const value_type* last) {$/;"	f	class:slist	access:public	signature:(const value_type* first, const value_type* last)
slist::slist	stl_slist.h	/^  slist(const_iterator first, const_iterator last) {$/;"	f	class:slist	access:public	signature:(const_iterator first, const_iterator last)
slist::slist	stl_slist.h	/^  slist(int n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:slist	access:public	signature:(int n, const value_type& x)
slist::slist	stl_slist.h	/^  slist(long n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:slist	access:public	signature:(long n, const value_type& x)
slist::slist	stl_slist.h	/^  slist(size_type n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:slist	access:public	signature:(size_type n, const value_type& x)
slist::sort	stl_slist.h	/^  template <class StrictWeakOrdering> void sort(StrictWeakOrdering comp); $/;"	p	class:slist	access:public	signature:(StrictWeakOrdering comp)
slist::sort	stl_slist.h	/^  void sort();     $/;"	p	class:slist	access:public	signature:()
slist::sort	stl_slist.h	/^void slist<T,Alloc>::sort()$/;"	f	class:slist	signature:()
slist::sort	stl_slist.h	/^void slist<T,Alloc>::sort(StrictWeakOrdering comp)$/;"	f	class:slist	signature:(StrictWeakOrdering comp)
slist::splice	stl_slist.h	/^  void splice(iterator pos, slist& L) {$/;"	f	class:slist	access:public	signature:(iterator pos, slist& L)
slist::splice	stl_slist.h	/^  void splice(iterator pos, slist& L, iterator first, iterator last)$/;"	f	class:slist	access:public	signature:(iterator pos, slist& L, iterator first, iterator last)
slist::splice	stl_slist.h	/^  void splice(iterator pos, slist& L, iterator i) {$/;"	f	class:slist	access:public	signature:(iterator pos, slist& L, iterator i)
slist::splice_after	stl_slist.h	/^  void splice_after(iterator pos, $/;"	f	class:slist	access:public	signature:(iterator pos, iterator before_first, iterator before_last)
slist::splice_after	stl_slist.h	/^  void splice_after(iterator pos, iterator prev)$/;"	f	class:slist	access:public	signature:(iterator pos, iterator prev)
slist::swap	stl_slist.h	/^  void swap(slist& L)$/;"	f	class:slist	access:public	signature:(slist& L)
slist::unique	stl_slist.h	/^  template <class BinaryPredicate> void unique(BinaryPredicate pred); $/;"	p	class:slist	access:public	signature:(BinaryPredicate pred)
slist::unique	stl_slist.h	/^  void unique(); $/;"	p	class:slist	access:public	signature:()
slist::unique	stl_slist.h	/^void slist<T,Alloc>::unique()$/;"	f	class:slist	signature:()
slist::unique	stl_slist.h	/^void slist<T,Alloc>::unique(BinaryPredicate pred)$/;"	f	class:slist	signature:(BinaryPredicate pred)
slist::value_type	stl_slist.h	/^  typedef T value_type;$/;"	t	class:slist	access:public
slist::~slist	stl_slist.h	/^  ~slist() { clear(); }$/;"	f	class:slist	access:public	signature:()
sort	stl_algo.h	/^inline void sort(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last)
sort	stl_algo.h	/^inline void sort(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
sort	stl_list.h	/^  template <class StrictWeakOrdering> void sort(StrictWeakOrdering);$/;"	p	class:list	access:public	signature:(StrictWeakOrdering)
sort	stl_list.h	/^  void sort();$/;"	p	class:list	access:public	signature:()
sort	stl_list.h	/^void list<T, Alloc>::sort() {$/;"	f	class:list	signature:()
sort	stl_list.h	/^void list<T, Alloc>::sort(StrictWeakOrdering comp) {$/;"	f	class:list	signature:(StrictWeakOrdering comp)
sort	stl_slist.h	/^  template <class StrictWeakOrdering> void sort(StrictWeakOrdering comp); $/;"	p	class:slist	access:public	signature:(StrictWeakOrdering comp)
sort	stl_slist.h	/^  void sort();     $/;"	p	class:slist	access:public	signature:()
sort	stl_slist.h	/^void slist<T,Alloc>::sort()$/;"	f	class:slist	signature:()
sort	stl_slist.h	/^void slist<T,Alloc>::sort(StrictWeakOrdering comp)$/;"	f	class:slist	signature:(StrictWeakOrdering comp)
sort_heap	stl_heap.h	/^void sort_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last)
sort_heap	stl_heap.h	/^void sort_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
splice	stl_list.h	/^  void splice(iterator position, list& x) {$/;"	f	class:list	access:public	signature:(iterator position, list& x)
splice	stl_list.h	/^  void splice(iterator position, list&, iterator first, iterator last) {$/;"	f	class:list	access:public	signature:(iterator position, list&, iterator first, iterator last)
splice	stl_list.h	/^  void splice(iterator position, list&, iterator i) {$/;"	f	class:list	access:public	signature:(iterator position, list&, iterator i)
splice	stl_slist.h	/^  void splice(iterator pos, slist& L) {$/;"	f	class:slist	access:public	signature:(iterator pos, slist& L)
splice	stl_slist.h	/^  void splice(iterator pos, slist& L, iterator first, iterator last)$/;"	f	class:slist	access:public	signature:(iterator pos, slist& L, iterator first, iterator last)
splice	stl_slist.h	/^  void splice(iterator pos, slist& L, iterator i) {$/;"	f	class:slist	access:public	signature:(iterator pos, slist& L, iterator i)
splice_after	stl_slist.h	/^  void splice_after(iterator pos, $/;"	f	class:slist	access:public	signature:(iterator pos, iterator before_first, iterator before_last)
splice_after	stl_slist.h	/^  void splice_after(iterator pos, iterator prev)$/;"	f	class:slist	access:public	signature:(iterator pos, iterator prev)
stable_partition	stl_algo.h	/^inline ForwardIterator stable_partition(ForwardIterator first,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, Predicate pred)
stable_sort	stl_algo.h	/^inline void stable_sort(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last)
stable_sort	stl_algo.h	/^inline void stable_sort(RandomAccessIterator first,$/;"	f	signature:(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
stack	stl_stack.h	/^class stack {$/;"	c
stack::__STL_NULL_TMPL_ARGS	stl_stack.h	/^  friend bool operator< __STL_NULL_TMPL_ARGS (const stack&, const stack&);$/;"	p	class:stack	access:friend	signature:(const stack&, const stack&)
stack::__STL_NULL_TMPL_ARGS	stl_stack.h	/^  friend bool operator== __STL_NULL_TMPL_ARGS (const stack&, const stack&);$/;"	p	class:stack	access:friend	signature:(const stack&, const stack&)
stack::c	stl_stack.h	/^  Sequence c;$/;"	m	class:stack	access:protected
stack::const_reference	stl_stack.h	/^  typedef typename Sequence::const_reference const_reference;$/;"	t	class:stack	access:public
stack::empty	stl_stack.h	/^  bool empty() const { return c.empty(); }$/;"	f	class:stack	access:public	signature:() const
stack::pop	stl_stack.h	/^  void pop() { c.pop_back(); }$/;"	f	class:stack	access:public	signature:()
stack::push	stl_stack.h	/^  void push(const value_type& x) { c.push_back(x); }$/;"	f	class:stack	access:public	signature:(const value_type& x)
stack::reference	stl_stack.h	/^  typedef typename Sequence::reference reference;$/;"	t	class:stack	access:public
stack::size	stl_stack.h	/^  size_type size() const { return c.size(); }$/;"	f	class:stack	access:public	signature:() const
stack::size_type	stl_stack.h	/^  typedef typename Sequence::size_type size_type;$/;"	t	class:stack	access:public
stack::top	stl_stack.h	/^  const_reference top() const { return c.back(); }$/;"	f	class:stack	access:public	signature:() const
stack::top	stl_stack.h	/^  reference top() { return c.back(); }$/;"	f	class:stack	access:public	signature:()
stack::value_type	stl_stack.h	/^  typedef typename Sequence::value_type value_type;$/;"	t	class:stack	access:public
start	stl_bvector.h	/^  iterator start;$/;"	m	class:vector	access:protected
start	stl_deque.h	/^  iterator start;$/;"	m	class:__deque_iterator::deque	access:protected
start	stl_rope.h	/^    size_t start;$/;"	m	struct:__rope_RopeSubstring	access:public
start	stl_vector.h	/^  iterator start;$/;"	m	class:vector	access:protected
start_free	stl_alloc.h	/^  static char *start_free;$/;"	m	class:__default_alloc_template	access:private
start_free	stl_alloc.h	/^char *__default_alloc_template<threads, inst>::start_free = 0;$/;"	m	class:__default_alloc_template
stream	stl_iterator.h	/^  istream* stream;$/;"	m	class:istream_iterator	access:protected
stream	stl_iterator.h	/^  ostream* stream;$/;"	m	class:ostream_iterator	access:protected
string	stl_iterator.h	/^  const char* string;$/;"	m	class:ostream_iterator	access:protected
substr	stl_rope.h	/^	rope substr(const_iterator start, const_iterator end) const {$/;"	f	class:rope	access:public	signature:(const_iterator start, const_iterator end) const
substr	stl_rope.h	/^	rope substr(iterator start) const {$/;"	f	class:rope	access:public	signature:(iterator start) const
substr	stl_rope.h	/^	rope substr(iterator start, iterator end) const {$/;"	f	class:rope	access:public	signature:(iterator start, iterator end) const
substr	stl_rope.h	/^	rope substr(size_t start, size_t len = 1) const {$/;"	f	class:rope	access:public	signature:(size_t start, size_t len = 1) const
substr	stl_rope.h	/^	rope<charT,Alloc> substr(const_iterator start) {$/;"	f	class:rope	access:public	signature:(const_iterator start)
substring	ropeimpl.h	/^rope<charT,Alloc>::substring(RopeBase * base, size_t start, size_t endp1)$/;"	f	class:rope	signature:(RopeBase * base, size_t start, size_t endp1)
substring	stl_rope.h	/^	static RopeBase * substring(RopeBase * base,$/;"	p	class:rope	access:protected	signature:(RopeBase * base, size_t start, size_t endp1)
substringfn	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon9
subtractive_rng	stl_function.h	/^  subtractive_rng() { initialize(161803398u); }$/;"	f	class:subtractive_rng	access:public	signature:()
subtractive_rng	stl_function.h	/^  subtractive_rng(unsigned int seed) { initialize(seed); }$/;"	f	class:subtractive_rng	access:public	signature:(unsigned int seed)
subtractive_rng	stl_function.h	/^class subtractive_rng : public unary_function<unsigned int, unsigned int> {$/;"	c	inherits:unary_function
subtractive_rng::index1	stl_function.h	/^  size_t index1;$/;"	m	class:subtractive_rng	access:private
subtractive_rng::index2	stl_function.h	/^  size_t index2;$/;"	m	class:subtractive_rng	access:private
subtractive_rng::initialize	stl_function.h	/^  void initialize(unsigned int seed)$/;"	f	class:subtractive_rng	access:public	signature:(unsigned int seed)
subtractive_rng::operator ()	stl_function.h	/^  unsigned int operator()(unsigned int limit) {$/;"	f	class:subtractive_rng	access:public	signature:(unsigned int limit)
subtractive_rng::subtractive_rng	stl_function.h	/^  subtractive_rng() { initialize(161803398u); }$/;"	f	class:subtractive_rng	access:public	signature:()
subtractive_rng::subtractive_rng	stl_function.h	/^  subtractive_rng(unsigned int seed) { initialize(seed); }$/;"	f	class:subtractive_rng	access:public	signature:(unsigned int seed)
subtractive_rng::table	stl_function.h	/^  unsigned int table[55];$/;"	m	class:subtractive_rng	access:private
swap	stl_algobase.h	/^inline void swap(T& a, T& b) {$/;"	f	signature:(T& a, T& b)
swap	stl_bvector.h	/^  void swap(__BVECTOR& x) {$/;"	f	class:vector	access:public	signature:(__BVECTOR& x)
swap	stl_bvector.h	/^inline void swap(__bit_reference x, __bit_reference y) {$/;"	f	signature:(__bit_reference x, __bit_reference y)
swap	stl_deque.h	/^  void swap(deque& x) {$/;"	f	class:__deque_iterator::deque	access:public	signature:(deque& x)
swap	stl_deque.h	/^inline void swap(deque<T, Alloc, BufSiz>& x, deque<T, Alloc, BufSiz>& y) {$/;"	f	struct:__deque_iterator	access:public	signature:(deque<T, Alloc, BufSiz>& x, deque<T, Alloc, BufSiz>& y)
swap	stl_hash_map.h	/^  void swap(hash_map& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_map	access:public	signature:(hash_map& hs)
swap	stl_hash_map.h	/^  void swap(hash_multimap& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_multimap	access:public	signature:(hash_multimap& hs)
swap	stl_hash_map.h	/^inline void swap(hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,$/;"	f	signature:(hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1, hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm2)
swap	stl_hash_map.h	/^inline void swap(hash_multimap<Key, T, HashFcn, EqualKey, Alloc>& hm1,$/;"	f	signature:(hash_multimap<Key, T, HashFcn, EqualKey, Alloc>& hm1, hash_multimap<Key, T, HashFcn, EqualKey, Alloc>& hm2)
swap	stl_hash_set.h	/^  hs1.swap(hs2);$/;"	p	signature:(hs2)
swap	stl_hash_set.h	/^  void swap(hash_multiset& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_multiset	access:public	signature:(hash_multiset& hs)
swap	stl_hash_set.h	/^  void swap(hash_set& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_set	access:public	signature:(hash_set& hs)
swap	stl_hash_set.h	/^inline void swap(hash_set<Val, HashFcn, EqualKey, Alloc>& hs1,$/;"	f	signature:(hash_set<Val, HashFcn, EqualKey, Alloc>& hs1, hash_set<Val, HashFcn, EqualKey, Alloc>& hs2)
swap	stl_hashtable.h	/^  void swap(hashtable& ht)$/;"	f	class:hashtable	access:public	signature:(hashtable& ht)
swap	stl_hashtable.h	/^inline void swap(hashtable<Val, Key, HF, Extract, EqKey, A>& ht1,$/;"	f	signature:(hashtable<Val, Key, HF, Extract, EqKey, A>& ht1, hashtable<Val, Key, HF, Extract, EqKay, A>& ht2)
swap	stl_list.h	/^  void swap(list<T, Alloc>& x) { __STD::swap(node, x.node); }$/;"	f	class:list	access:public	signature:(list<T, Alloc>& x)
swap	stl_list.h	/^inline void swap(list<T, Alloc>& x, list<T, Alloc>& y) {$/;"	f	signature:(list<T, Alloc>& x, list<T, Alloc>& y)
swap	stl_map.h	/^  void swap(map<Key, T, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:map	access:public	signature:(map<Key, T, Compare, Alloc>& x)
swap	stl_map.h	/^inline void swap(map<Key, T, Compare, Alloc>& x, $/;"	f	signature:(map<Key, T, Compare, Alloc>& x, map<Key, T, Compare, Alloc>& y)
swap	stl_multimap.h	/^  void swap(multimap<Key, T, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:multimap	access:public	signature:(multimap<Key, T, Compare, Alloc>& x)
swap	stl_multimap.h	/^inline void swap(multimap<Key, T, Compare, Alloc>& x, $/;"	f	signature:(multimap<Key, T, Compare, Alloc>& x, multimap<Key, T, Compare, Alloc>& y)
swap	stl_multiset.h	/^  void swap(multiset<Key, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:multiset	access:public	signature:(multiset<Key, Compare, Alloc>& x)
swap	stl_multiset.h	/^inline void swap(multiset<Key, Compare, Alloc>& x, $/;"	f	signature:(multiset<Key, Compare, Alloc>& x, multiset<Key, Compare, Alloc>& y)
swap	stl_rope.h	/^	void swap(rope& b) {$/;"	f	class:rope	access:public	signature:(rope& b)
swap	stl_rope.h	/^inline void swap(crope x, crope y) { x.swap(y); }$/;"	f	signature:(crope x, crope y)
swap	stl_rope.h	/^inline void swap(rope<charT, Alloc>& x, rope<charT, Alloc>& y) {$/;"	f	signature:(rope<charT, Alloc>& x, rope<charT, Alloc>& y)
swap	stl_rope.h	/^inline void swap(wrope x, wrope y) { x.swap(y); }$/;"	f	signature:(wrope x, wrope y)
swap	stl_set.h	/^  void swap(set<Key, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:set	access:public	signature:(set<Key, Compare, Alloc>& x)
swap	stl_set.h	/^inline void swap(set<Key, Compare, Alloc>& x, $/;"	f	signature:(set<Key, Compare, Alloc>& x, set<Key, Compare, Alloc>& y)
swap	stl_slist.h	/^  void swap(slist& L)$/;"	f	class:slist	access:public	signature:(slist& L)
swap	stl_slist.h	/^inline void swap(slist<T, Alloc>& x, slist<T, Alloc>& y) {$/;"	f	signature:(slist<T, Alloc>& x, slist<T, Alloc>& y)
swap	stl_tree.h	/^  void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& t) {$/;"	f	class:rb_tree	access:public	signature:(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& t)
swap	stl_tree.h	/^inline void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, $/;"	f	signature:(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& y)
swap	stl_vector.h	/^  void swap(vector<T, Alloc>& x) {$/;"	f	class:vector	access:public	signature:(vector<T, Alloc>& x)
swap	stl_vector.h	/^inline void swap(vector<T, Alloc>& x, vector<T, Alloc>& y) {$/;"	f	signature:(vector<T, Alloc>& x, vector<T, Alloc>& y)
swap_lock	ropeimpl.h	/^    pthread_mutex_t rope<charT,Alloc>::swap_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	m	class:rope
swap_lock	stl_rope.h	/^	    static pthread_mutex_t swap_lock;$/;"	m	class:rope	access:protected
swap_ranges	stl_algo.h	/^ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f	signature:(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2)
t	stl_map.h	/^  rep_type t;  \/\/ red-black tree representing map$/;"	m	class:map	access:private
t	stl_multimap.h	/^  rep_type t;  \/\/ red-black tree representing multimap$/;"	m	class:multimap	access:private
t	stl_multiset.h	/^  rep_type t;  \/\/ red-black tree representing multiset$/;"	m	class:multiset	access:private
t	stl_set.h	/^  rep_type t;  \/\/ red-black tree representing set$/;"	m	class:set	access:private
table	stl_function.h	/^  unsigned int table[55];$/;"	m	class:subtractive_rng	access:private
tag	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	m	struct:__rope_RopeBase	typeref:enum:__rope_RopeBase::__anon9	access:public
temporary_buffer	stl_tempbuf.h	/^  temporary_buffer(ForwardIterator first, ForwardIterator last) {$/;"	f	class:temporary_buffer	access:public	signature:(ForwardIterator first, ForwardIterator last)
temporary_buffer	stl_tempbuf.h	/^  temporary_buffer(const temporary_buffer&) {}$/;"	f	class:temporary_buffer	access:private	signature:(const temporary_buffer&)
temporary_buffer	stl_tempbuf.h	/^class temporary_buffer {$/;"	c
temporary_buffer::allocate_buffer	stl_tempbuf.h	/^  void allocate_buffer() {$/;"	f	class:temporary_buffer	access:private	signature:()
temporary_buffer::begin	stl_tempbuf.h	/^  T* begin() { return buffer; }$/;"	f	class:temporary_buffer	access:public	signature:()
temporary_buffer::buffer	stl_tempbuf.h	/^  T* buffer;$/;"	m	class:temporary_buffer	access:private
temporary_buffer::end	stl_tempbuf.h	/^  T* end() { return buffer + len; }$/;"	f	class:temporary_buffer	access:public	signature:()
temporary_buffer::initialize_buffer	stl_tempbuf.h	/^  void initialize_buffer(const T& val, __false_type) {$/;"	f	class:temporary_buffer	access:private	signature:(const T& val, __false_type)
temporary_buffer::initialize_buffer	stl_tempbuf.h	/^  void initialize_buffer(const T&, __true_type) {}$/;"	f	class:temporary_buffer	access:private	signature:(const T&, __true_type)
temporary_buffer::len	stl_tempbuf.h	/^  ptrdiff_t len;$/;"	m	class:temporary_buffer	access:private
temporary_buffer::operator =	stl_tempbuf.h	/^  void operator=(const temporary_buffer&) {}$/;"	f	class:temporary_buffer	access:private	signature:(const temporary_buffer&)
temporary_buffer::original_len	stl_tempbuf.h	/^  ptrdiff_t original_len;$/;"	m	class:temporary_buffer	access:private
temporary_buffer::requested_size	stl_tempbuf.h	/^  ptrdiff_t requested_size() const { return original_len; }$/;"	f	class:temporary_buffer	access:public	signature:() const
temporary_buffer::size	stl_tempbuf.h	/^  ptrdiff_t size() const { return len; }$/;"	f	class:temporary_buffer	access:public	signature:() const
temporary_buffer::temporary_buffer	stl_tempbuf.h	/^  temporary_buffer(ForwardIterator first, ForwardIterator last) {$/;"	f	class:temporary_buffer	access:public	signature:(ForwardIterator first, ForwardIterator last)
temporary_buffer::temporary_buffer	stl_tempbuf.h	/^  temporary_buffer(const temporary_buffer&) {}$/;"	f	class:temporary_buffer	access:private	signature:(const temporary_buffer&)
temporary_buffer::~temporary_buffer	stl_tempbuf.h	/^  ~temporary_buffer() {  $/;"	f	class:temporary_buffer	access:public	signature:()
this_dummy_member_must_be_first	type_traits.h	/^   typedef __true_type     this_dummy_member_must_be_first;$/;"	t	struct:__type_traits	access:public
tmp_buf	stl_rope.h	/^    charT tmp_buf[iterator_buf_len];$/;"	m	class:__rope_iterator_base	access:protected
top	stl_queue.h	/^  const_reference top() const { return c.front(); }$/;"	f	class:priority_queue	access:public	signature:() const
top	stl_stack.h	/^  const_reference top() const { return c.back(); }$/;"	f	class:stack	access:public	signature:() const
top	stl_stack.h	/^  reference top() { return c.back(); }$/;"	f	class:stack	access:public	signature:()
transfer	stl_list.h	/^  void transfer(iterator position, iterator first, iterator last) {$/;"	f	class:list	access:protected	signature:(iterator position, iterator first, iterator last)
transform	stl_algo.h	/^OutputIterator transform(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op)
transform	stl_algo.h	/^OutputIterator transform(InputIterator1 first1, InputIterator1 last1,$/;"	f	signature:(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation binary_op)
tree_concat	ropeimpl.h	/^rope<charT,Alloc>::tree_concat (RopeBase * left, RopeBase * right)$/;"	f	class:rope	signature:(RopeBase * left, RopeBase * right)
tree_concat	stl_rope.h	/^	static RopeBase * tree_concat(RopeBase * left, RopeBase * right);$/;"	p	class:rope	access:protected	signature:(RopeBase * left, RopeBase * right)
tree_ptr	stl_rope.h	/^	RopeBase *tree_ptr;$/;"	m	class:rope	access:protected
true	stl_config.h	172;"	d
typename	stl_config.h	177;"	d
unary_compose	stl_function.h	/^  unary_compose(const Operation1& x, const Operation2& y) : op1(x), op2(y) {}$/;"	f	class:unary_compose	access:public	signature:(const Operation1& x, const Operation2& y)
unary_compose	stl_function.h	/^class unary_compose : public unary_function<typename Operation2::argument_type,$/;"	c	inherits:unary_function
unary_compose::op1	stl_function.h	/^  Operation1 op1;$/;"	m	class:unary_compose	access:protected
unary_compose::op2	stl_function.h	/^  Operation2 op2;$/;"	m	class:unary_compose	access:protected
unary_compose::operator ()	stl_function.h	/^  operator()(const typename Operation2::argument_type& x) const {$/;"	f	class:unary_compose	access:public	signature:(const typename Operation2::argument_type& x) const
unary_compose::unary_compose	stl_function.h	/^  unary_compose(const Operation1& x, const Operation2& y) : op1(x), op2(y) {}$/;"	f	class:unary_compose	access:public	signature:(const Operation1& x, const Operation2& y)
unary_function	stl_function.h	/^struct unary_function {$/;"	s
unary_function::argument_type	stl_function.h	/^    typedef Arg argument_type;$/;"	t	struct:unary_function	access:public
unary_function::result_type	stl_function.h	/^    typedef Result result_type;$/;"	t	struct:unary_function	access:public
unary_negate	stl_function.h	/^  explicit unary_negate(const Predicate& x) : pred(x) {}$/;"	f	class:unary_negate	access:public	signature:(const Predicate& x)
unary_negate	stl_function.h	/^class unary_negate$/;"	c	inherits:unary_function
unary_negate::operator ()	stl_function.h	/^  bool operator()(const typename Predicate::argument_type& x) const {$/;"	f	class:unary_negate	access:public	signature:(const typename Predicate::argument_type& x) const
unary_negate::pred	stl_function.h	/^  Predicate pred;$/;"	m	class:unary_negate	access:protected
unary_negate::unary_negate	stl_function.h	/^  explicit unary_negate(const Predicate& x) : pred(x) {}$/;"	f	class:unary_negate	access:public	signature:(const Predicate& x)
uninitialized_copy	stl_uninitialized.h	/^  uninitialized_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, ForwardIterator result)
uninitialized_copy	stl_uninitialized.h	/^inline char* uninitialized_copy(const char* first, const char* last,$/;"	f	signature:(const char* first, const char* last, char* result)
uninitialized_copy	stl_uninitialized.h	/^inline wchar_t* uninitialized_copy(const wchar_t* first, const wchar_t* last,$/;"	f	signature:(const wchar_t* first, const wchar_t* last, wchar_t* result)
uninitialized_copy_n	stl_uninitialized.h	/^uninitialized_copy_n(InputIterator first, Size count,$/;"	f	signature:(InputIterator first, Size count, ForwardIterator result)
uninitialized_fill	stl_uninitialized.h	/^inline void uninitialized_fill(ForwardIterator first, ForwardIterator last, $/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& x)
uninitialized_fill_n	stl_uninitialized.h	/^inline ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n,$/;"	f	signature:(ForwardIterator first, Size n, const T& x)
unique	stl_algo.h	/^ForwardIterator unique(ForwardIterator first, ForwardIterator last) {$/;"	f	signature:(ForwardIterator first, ForwardIterator last)
unique	stl_algo.h	/^ForwardIterator unique(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred)
unique	stl_list.h	/^  template <class BinaryPredicate> void unique(BinaryPredicate);$/;"	p	class:list	access:public	signature:(BinaryPredicate)
unique	stl_list.h	/^  void unique();$/;"	p	class:list	access:public	signature:()
unique	stl_list.h	/^void list<T, Alloc>::unique() {$/;"	f	class:list	signature:()
unique	stl_list.h	/^void list<T, Alloc>::unique(BinaryPredicate binary_pred) {$/;"	f	class:list	signature:(BinaryPredicate binary_pred)
unique	stl_slist.h	/^  template <class BinaryPredicate> void unique(BinaryPredicate pred); $/;"	p	class:slist	access:public	signature:(BinaryPredicate pred)
unique	stl_slist.h	/^  void unique(); $/;"	p	class:slist	access:public	signature:()
unique	stl_slist.h	/^void slist<T,Alloc>::unique()$/;"	f	class:slist	signature:()
unique	stl_slist.h	/^void slist<T,Alloc>::unique(BinaryPredicate pred)$/;"	f	class:slist	signature:(BinaryPredicate pred)
unique_copy	stl_algo.h	/^inline OutputIterator unique_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result)
unique_copy	stl_algo.h	/^inline OutputIterator unique_copy(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate binary_pred)
unref	stl_rope.h	/^	  static void unref(RopeBase* t) {}$/;"	f	class:rope	access:protected	signature:(RopeBase* t)
unref	stl_rope.h	/^	  static void unref(RopeBase* t)$/;"	f	class:rope	access:protected	signature:(RopeBase* t)
unref	stl_rope.h	/^	  static void unref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase	access:public	signature:(__rope_RopeBase* t)
unref	stl_rope.h	/^	  static void unref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase	access:public	signature:(__rope_RopeBase* t)
unref_nonnil	stl_rope.h	/^	  void unref_nonnil() {}$/;"	f	struct:__rope_RopeBase	access:public	signature:()
unref_nonnil	stl_rope.h	/^	  void unref_nonnil()$/;"	f	struct:__rope_RopeBase	access:public	signature:()
upper_bound	stl_algo.h	/^inline ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value)
upper_bound	stl_algo.h	/^inline ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const T& value, Compare comp)
upper_bound	stl_map.h	/^  const_iterator upper_bound(const key_type& x) const {$/;"	f	class:map	access:public	signature:(const key_type& x) const
upper_bound	stl_map.h	/^  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }$/;"	f	class:map	access:public	signature:(const key_type& x)
upper_bound	stl_multimap.h	/^  const_iterator upper_bound(const key_type& x) const {$/;"	f	class:multimap	access:public	signature:(const key_type& x) const
upper_bound	stl_multimap.h	/^  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }$/;"	f	class:multimap	access:public	signature:(const key_type& x)
upper_bound	stl_multiset.h	/^  iterator upper_bound(const key_type& x) const {$/;"	f	class:multiset	access:public	signature:(const key_type& x) const
upper_bound	stl_set.h	/^  iterator upper_bound(const key_type& x) const {$/;"	f	class:set	access:public	signature:(const key_type& x) const
upper_bound	stl_tree.h	/^  const_iterator upper_bound(const key_type& x) const;$/;"	p	class:rb_tree	access:public	signature:(const key_type& x) const
upper_bound	stl_tree.h	/^  iterator upper_bound(const key_type& x);$/;"	p	class:rb_tree	access:public	signature:(const key_type& x)
upper_bound	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) const {$/;"	f	class:rb_tree	signature:(const Key& k) const
upper_bound	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) {$/;"	f	class:rb_tree	signature:(const Key& k)
val	stl_function.h	/^  Result val;$/;"	m	struct:constant_binary_fun	access:public
val	stl_function.h	/^  Result val;$/;"	m	struct:constant_unary_fun	access:public
val	stl_function.h	/^  result_type val;$/;"	m	struct:constant_void_fun	access:public
val	stl_hashtable.h	/^  Value val;$/;"	m	struct:__hashtable_node	access:public
value	stl_function.h	/^  typename Operation::first_argument_type value;$/;"	m	class:binder1st	access:protected
value	stl_function.h	/^  typename Operation::second_argument_type value;$/;"	m	class:binder2nd	access:protected
value	stl_iterator.h	/^  T value;$/;"	m	class:istream_iterator	access:protected
value	stl_tree.h	/^  static reference value(base_ptr x) { return ((link_type)x)->value_field; }$/;"	f	class:rb_tree	access:protected	signature:(base_ptr x)
value	stl_tree.h	/^  static reference value(link_type x) { return x->value_field; }$/;"	f	class:rb_tree	access:protected	signature:(link_type x)
value_comp	stl_map.h	/^  value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:map	access:public	signature:() const
value_comp	stl_multimap.h	/^  value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:multimap	access:public	signature:() const
value_comp	stl_multiset.h	/^  value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:multiset	access:public	signature:() const
value_comp	stl_set.h	/^  value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:set	access:public	signature:() const
value_compare	stl_map.h	/^    value_compare(Compare c) : comp(c) {}$/;"	f	class:map::value_compare	access:protected	signature:(Compare c)
value_compare	stl_map.h	/^  class value_compare$/;"	c	class:map	inherits:binary_function	access:public
value_compare	stl_multimap.h	/^    value_compare(Compare c) : comp(c) {}$/;"	f	class:multimap::value_compare	access:protected	signature:(Compare c)
value_compare	stl_multimap.h	/^  class value_compare : public binary_function<value_type, value_type, bool> {$/;"	c	class:multimap	inherits:binary_function	access:public
value_compare	stl_multiset.h	/^  typedef Compare value_compare;$/;"	t	class:multiset	access:public
value_compare	stl_set.h	/^  typedef Compare value_compare;$/;"	t	class:set	access:public
value_field	stl_tree.h	/^  Value value_field;$/;"	m	struct:__rb_tree_node	access:public
value_type	defalloc.h	/^    typedef T value_type;$/;"	t	class:allocator	access:public
value_type	stl_bvector.h	/^  typedef bool value_type;$/;"	t	class:vector	access:public
value_type	stl_deque.h	/^  typedef T value_type;$/;"	t	class:__deque_iterator::deque	access:public
value_type	stl_deque.h	/^  typedef T value_type;$/;"	t	struct:__deque_iterator::__deque_iterator	access:public
value_type	stl_deque.h	/^inline T* value_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {$/;"	f	struct:__deque_iterator	access:public	signature:(const __deque_iterator<T, Ref, Ptr, BufSiz>&)
value_type	stl_deque.h	/^inline T* value_type(const __deque_iterator<T, Ref, Ptr>&) { return 0; }$/;"	f	struct:__deque_iterator	access:public	signature:(const __deque_iterator<T, Ref, Ptr>&)
value_type	stl_hash_map.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_map	access:public
value_type	stl_hash_map.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_multimap	access:public
value_type	stl_hash_set.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_multiset	access:public
value_type	stl_hash_set.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_set	access:public
value_type	stl_hashtable.h	/^  typedef Value value_type;$/;"	t	class:hashtable	access:public
value_type	stl_hashtable.h	/^  typedef Value value_type;$/;"	t	struct:__hashtable_const_iterator	access:public
value_type	stl_hashtable.h	/^  typedef Value value_type;$/;"	t	struct:__hashtable_iterator	access:public
value_type	stl_hashtable.h	/^inline V* value_type(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f	signature:(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)
value_type	stl_hashtable.h	/^value_type(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f	signature:(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)
value_type	stl_iterator.h	/^          value_type;$/;"	t	class:reverse_iterator	access:public
value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	class:reverse_bidirectional_iterator	access:public
value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	class:reverse_iterator	access:public
value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:bidirectional_iterator	access:public
value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:iterator_traits	access:public
value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:random_access_iterator	access:public
value_type	stl_iterator.h	/^  typedef T                    value_type;$/;"	t	struct:forward_iterator	access:public
value_type	stl_iterator.h	/^  typedef T                  value_type;$/;"	t	class:istream_iterator	access:public
value_type	stl_iterator.h	/^  typedef T                  value_type;$/;"	t	struct:input_iterator	access:public
value_type	stl_iterator.h	/^  typedef T         value_type;$/;"	t	struct:iterator	access:public
value_type	stl_iterator.h	/^  typedef typename Iterator::value_type        value_type;$/;"	t	struct:iterator_traits	access:public
value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:back_insert_iterator	access:public
value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:front_insert_iterator	access:public
value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:insert_iterator	access:public
value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:ostream_iterator	access:public
value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	struct:output_iterator	access:public
value_type	stl_iterator.h	/^inline T* value_type(const T*) { return (T*)(0); }$/;"	f	signature:(const T*)
value_type	stl_iterator.h	/^inline T* value_type(const bidirectional_iterator<T, Distance>&) {$/;"	f	signature:(const bidirectional_iterator<T, Distance>&)
value_type	stl_iterator.h	/^inline T* value_type(const forward_iterator<T, Distance>&) {$/;"	f	signature:(const forward_iterator<T, Distance>&)
value_type	stl_iterator.h	/^inline T* value_type(const input_iterator<T, Distance>&) {$/;"	f	signature:(const input_iterator<T, Distance>&)
value_type	stl_iterator.h	/^inline T* value_type(const istream_iterator<T, Distance>&) { return (T*) 0; }$/;"	f	signature:(const istream_iterator<T, Distance>&)
value_type	stl_iterator.h	/^inline T* value_type(const random_access_iterator<T, Distance>&) {$/;"	f	signature:(const random_access_iterator<T, Distance>&)
value_type	stl_iterator.h	/^inline T* value_type(const reverse_iterator<RandomAccessIterator, T,$/;"	f	signature:(const reverse_iterator<RandomAccessIterator, T, Reference, Distance>&)
value_type	stl_iterator.h	/^value_type(const Iterator&) {$/;"	f	signature:(const Iterator&)
value_type	stl_iterator.h	/^value_type(const reverse_bidirectional_iterator<BidirectionalIterator, T,$/;"	f	signature:(const reverse_bidirectional_iterator<BidirectionalIterator, T, Reference, Distance>&)
value_type	stl_list.h	/^  typedef T value_type;$/;"	t	class:list	access:public
value_type	stl_list.h	/^  typedef T value_type;$/;"	t	struct:__list_iterator	access:public
value_type	stl_list.h	/^value_type(const __list_iterator<T, Ref, Ptr>&) {$/;"	f	signature:(const __list_iterator<T, Ref, Ptr>&)
value_type	stl_map.h	/^  typedef pair<const Key, T> value_type;$/;"	t	class:map	access:public
value_type	stl_multimap.h	/^  typedef pair<const Key, T> value_type;$/;"	t	class:multimap	access:public
value_type	stl_multiset.h	/^  typedef Key value_type;$/;"	t	class:multiset	access:public
value_type	stl_queue.h	/^  typedef typename Sequence::value_type value_type;$/;"	t	class:priority_queue	access:public
value_type	stl_queue.h	/^  typedef typename Sequence::value_type value_type;$/;"	t	class:queue	access:public
value_type	stl_raw_storage_iter.h	/^  typedef void                value_type;$/;"	t	class:raw_storage_iterator	access:public
value_type	stl_rope.h	/^	    typedef typename sequence::value_type value_type;$/;"	t	class:sequence_buffer	access:public
value_type	stl_rope.h	/^	typedef charT value_type;$/;"	t	class:rope	access:public
value_type	stl_set.h	/^  typedef Key value_type;$/;"	t	class:set	access:public
value_type	stl_slist.h	/^  typedef T value_type;$/;"	t	class:slist	access:public
value_type	stl_slist.h	/^  typedef T value_type;$/;"	t	struct:__slist_iterator	access:public
value_type	stl_slist.h	/^value_type(const __slist_iterator<T, Ref, Ptr>&) {$/;"	f	signature:(const __slist_iterator<T, Ref, Ptr>&)
value_type	stl_stack.h	/^  typedef typename Sequence::value_type value_type;$/;"	t	class:stack	access:public
value_type	stl_tree.h	/^  typedef Value value_type;$/;"	t	class:rb_tree	access:public
value_type	stl_tree.h	/^  typedef Value value_type;$/;"	t	struct:__rb_tree_iterator	access:public
value_type	stl_tree.h	/^inline Value* value_type(const __rb_tree_iterator<Value, Ref, Ptr>&) {$/;"	f	signature:(const __rb_tree_iterator<Value, Ref, Ptr>&)
value_type	stl_vector.h	/^  typedef T value_type;$/;"	t	class:vector	access:public
vector	stl_bvector.h	/^template<class Alloc> class vector<bool, Alloc>$/;"	c
vector	stl_vector.h	/^  explicit vector(size_type n) { fill_initialize(n, T()); }$/;"	f	class:vector	access:public	signature:(size_type n)
vector	stl_vector.h	/^  vector() : start(0), finish(0), end_of_storage(0) {}$/;"	f	class:vector	access:public	signature:()
vector	stl_vector.h	/^  vector(InputIterator first, InputIterator last) :$/;"	f	class:vector	access:public	signature:(InputIterator first, InputIterator last)
vector	stl_vector.h	/^  vector(const vector<T, Alloc>& x) {$/;"	f	class:vector	access:public	signature:(const vector<T, Alloc>& x)
vector	stl_vector.h	/^  vector(const_iterator first, const_iterator last) {$/;"	f	class:vector	access:public	signature:(const_iterator first, const_iterator last)
vector	stl_vector.h	/^  vector(int n, const T& value) { fill_initialize(n, value); }$/;"	f	class:vector	access:public	signature:(int n, const T& value)
vector	stl_vector.h	/^  vector(long n, const T& value) { fill_initialize(n, value); }$/;"	f	class:vector	access:public	signature:(long n, const T& value)
vector	stl_vector.h	/^  vector(size_type n, const T& value) { fill_initialize(n, value); }$/;"	f	class:vector	access:public	signature:(size_type n, const T& value)
vector	stl_vector.h	/^class vector {$/;"	c
vector::__BVECTOR	stl_bvector.h	/^  __BVECTOR() : start(iterator()), finish(iterator()), end_of_storage(0) {}$/;"	f	class:vector	access:public	signature:()
vector::__BVECTOR	stl_bvector.h	/^  __BVECTOR(InputIterator first, InputIterator last) {$/;"	f	class:vector	access:public	signature:(InputIterator first, InputIterator last)
vector::__BVECTOR	stl_bvector.h	/^  __BVECTOR(const __BVECTOR& x) {$/;"	f	class:vector	access:public	signature:(const __BVECTOR& x)
vector::__BVECTOR	stl_bvector.h	/^  __BVECTOR(const bool* first, const bool* last) {$/;"	f	class:vector	access:public	signature:(const bool* first, const bool* last)
vector::__BVECTOR	stl_bvector.h	/^  __BVECTOR(const_iterator first, const_iterator last) {$/;"	f	class:vector	access:public	signature:(const_iterator first, const_iterator last)
vector::__BVECTOR	stl_bvector.h	/^  __BVECTOR(int n, bool value) {$/;"	f	class:vector	access:public	signature:(int n, bool value)
vector::__BVECTOR	stl_bvector.h	/^  __BVECTOR(long n, bool value) {$/;"	f	class:vector	access:public	signature:(long n, bool value)
vector::__BVECTOR	stl_bvector.h	/^  __BVECTOR(size_type n, bool value) {$/;"	f	class:vector	access:public	signature:(size_type n, bool value)
vector::__BVECTOR	stl_bvector.h	/^  explicit __BVECTOR(size_type n) {$/;"	f	class:vector	access:public	signature:(size_type n)
vector::allocate_and_copy	stl_vector.h	/^  iterator allocate_and_copy(size_type n,$/;"	f	class:vector	access:protected	signature:(size_type n, ForwardIterator first, ForwardIterator last)
vector::allocate_and_copy	stl_vector.h	/^  iterator allocate_and_copy(size_type n,$/;"	f	class:vector	access:protected	signature:(size_type n, const_iterator first, const_iterator last)
vector::allocate_and_fill	stl_vector.h	/^  iterator allocate_and_fill(size_type n, const T& x) {$/;"	f	class:vector	access:protected	signature:(size_type n, const T& x)
vector::back	stl_bvector.h	/^  const_reference back() const { return *(end() - 1); }$/;"	f	class:vector	access:public	signature:() const
vector::back	stl_bvector.h	/^  reference back() { return *(end() - 1); }$/;"	f	class:vector	access:public	signature:()
vector::back	stl_vector.h	/^  const_reference back() const { return *(end() - 1); }$/;"	f	class:vector	access:public	signature:() const
vector::back	stl_vector.h	/^  reference back() { return *(end() - 1); }$/;"	f	class:vector	access:public	signature:()
vector::begin	stl_bvector.h	/^  const_iterator begin() const { return start; }$/;"	f	class:vector	access:public	signature:() const
vector::begin	stl_bvector.h	/^  iterator begin() { return start; }$/;"	f	class:vector	access:public	signature:()
vector::begin	stl_vector.h	/^  const_iterator begin() const { return start; }$/;"	f	class:vector	access:public	signature:() const
vector::begin	stl_vector.h	/^  iterator begin() { return start; }$/;"	f	class:vector	access:public	signature:()
vector::bit_alloc	stl_bvector.h	/^  unsigned int* bit_alloc(size_type n) {$/;"	f	class:vector	access:protected	signature:(size_type n)
vector::capacity	stl_bvector.h	/^  size_type capacity() const {$/;"	f	class:vector	access:public	signature:() const
vector::capacity	stl_vector.h	/^  size_type capacity() const { return size_type(end_of_storage - begin()); }$/;"	f	class:vector	access:public	signature:() const
vector::clear	stl_bvector.h	/^  void clear() { erase(begin(), end()); }$/;"	f	class:vector	access:public	signature:()
vector::clear	stl_vector.h	/^  void clear() { erase(begin(), end()); }$/;"	f	class:vector	access:public	signature:()
vector::const_iterator	stl_bvector.h	/^  typedef __bit_const_iterator          const_iterator;$/;"	t	class:vector	access:public
vector::const_iterator	stl_vector.h	/^  typedef const value_type* const_iterator;$/;"	t	class:vector	access:public
vector::const_pointer	stl_bvector.h	/^  typedef const bool* const_pointer;$/;"	t	class:vector	access:public
vector::const_pointer	stl_vector.h	/^  typedef const value_type* const_pointer;$/;"	t	class:vector	access:public
vector::const_reference	stl_bvector.h	/^  typedef bool const_reference;$/;"	t	class:vector	access:public
vector::const_reference	stl_vector.h	/^  typedef const value_type& const_reference;$/;"	t	class:vector	access:public
vector::const_reverse_iterator	stl_bvector.h	/^                           difference_type> const_reverse_iterator;$/;"	t	class:vector	access:public
vector::const_reverse_iterator	stl_bvector.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:vector	access:public
vector::const_reverse_iterator	stl_vector.h	/^                           difference_type>  const_reverse_iterator;$/;"	t	class:vector	access:public
vector::const_reverse_iterator	stl_vector.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:vector	access:public
vector::data_allocator	stl_bvector.h	/^  typedef simple_alloc<unsigned int, Alloc> data_allocator;$/;"	t	class:vector	access:private
vector::data_allocator	stl_vector.h	/^  typedef simple_alloc<value_type, Alloc> data_allocator;$/;"	t	class:vector	access:protected
vector::deallocate	stl_bvector.h	/^  void deallocate() {$/;"	f	class:vector	access:protected	signature:()
vector::deallocate	stl_vector.h	/^  void deallocate() {$/;"	f	class:vector	access:protected	signature:()
vector::difference_type	stl_bvector.h	/^  typedef ptrdiff_t difference_type; $/;"	t	class:vector	access:public
vector::difference_type	stl_vector.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:vector	access:public
vector::empty	stl_bvector.h	/^  bool empty() const { return begin() == end(); }$/;"	f	class:vector	access:public	signature:() const
vector::empty	stl_vector.h	/^  bool empty() const { return begin() == end(); }$/;"	f	class:vector	access:public	signature:() const
vector::end	stl_bvector.h	/^  const_iterator end() const { return finish; }$/;"	f	class:vector	access:public	signature:() const
vector::end	stl_bvector.h	/^  iterator end() { return finish; }$/;"	f	class:vector	access:public	signature:()
vector::end	stl_vector.h	/^  const_iterator end() const { return finish; }$/;"	f	class:vector	access:public	signature:() const
vector::end	stl_vector.h	/^  iterator end() { return finish; }$/;"	f	class:vector	access:public	signature:()
vector::end_of_storage	stl_bvector.h	/^  unsigned int* end_of_storage;$/;"	m	class:vector	access:protected
vector::end_of_storage	stl_vector.h	/^  iterator end_of_storage;$/;"	m	class:vector	access:protected
vector::erase	stl_bvector.h	/^  iterator erase(iterator first, iterator last) {$/;"	f	class:vector	access:public	signature:(iterator first, iterator last)
vector::erase	stl_bvector.h	/^  iterator erase(iterator position) {$/;"	f	class:vector	access:public	signature:(iterator position)
vector::erase	stl_vector.h	/^  iterator erase(iterator first, iterator last) {$/;"	f	class:vector	access:public	signature:(iterator first, iterator last)
vector::erase	stl_vector.h	/^  iterator erase(iterator position) {$/;"	f	class:vector	access:public	signature:(iterator position)
vector::fill_initialize	stl_vector.h	/^  void fill_initialize(size_type n, const T& value) {$/;"	f	class:vector	access:protected	signature:(size_type n, const T& value)
vector::finish	stl_bvector.h	/^  iterator finish;$/;"	m	class:vector	access:protected
vector::finish	stl_vector.h	/^  iterator finish;$/;"	m	class:vector	access:protected
vector::front	stl_bvector.h	/^  const_reference front() const { return *begin(); }$/;"	f	class:vector	access:public	signature:() const
vector::front	stl_bvector.h	/^  reference front() { return *begin(); }$/;"	f	class:vector	access:public	signature:()
vector::front	stl_vector.h	/^  const_reference front() const { return *begin(); }$/;"	f	class:vector	access:public	signature:() const
vector::front	stl_vector.h	/^  reference front() { return *begin(); }$/;"	f	class:vector	access:public	signature:()
vector::initialize	stl_bvector.h	/^  void initialize(size_type n) {$/;"	f	class:vector	access:protected	signature:(size_type n)
vector::initialize_range	stl_bvector.h	/^  void initialize_range(ForwardIterator first, ForwardIterator last,$/;"	f	class:vector	access:protected	signature:(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
vector::initialize_range	stl_bvector.h	/^  void initialize_range(InputIterator first, InputIterator last,$/;"	f	class:vector	access:protected	signature:(InputIterator first, InputIterator last, input_iterator_tag)
vector::insert	stl_bvector.h	/^  iterator insert(iterator position, bool x = bool()) {$/;"	f	class:vector	access:public	signature:(iterator position, bool x = bool())
vector::insert	stl_bvector.h	/^  template <class InputIterator> void insert(iterator position,$/;"	f	class:vector	access:public	signature:(iterator position, InputIterator first, InputIterator last)
vector::insert	stl_bvector.h	/^  void insert(iterator pos, int n, bool x)  { insert(pos, (size_type)n, x); }$/;"	f	class:vector	access:public	signature:(iterator pos, int n, bool x)
vector::insert	stl_bvector.h	/^  void insert(iterator pos, long n, bool x) { insert(pos, (size_type)n, x); }$/;"	f	class:vector	access:public	signature:(iterator pos, long n, bool x)
vector::insert	stl_bvector.h	/^  void insert(iterator position, const bool* first, const bool* last) {$/;"	f	class:vector	access:public	signature:(iterator position, const bool* first, const bool* last)
vector::insert	stl_bvector.h	/^  void insert(iterator position, const_iterator first, $/;"	f	class:vector	access:public	signature:(iterator position, const_iterator first, const_iterator last)
vector::insert	stl_bvector.h	/^  void insert(iterator position, size_type n, bool x) {$/;"	f	class:vector	access:public	signature:(iterator position, size_type n, bool x)
vector::insert	stl_vector.h	/^  iterator insert(iterator position) { return insert(position, T()); }$/;"	f	class:vector	access:public	signature:(iterator position)
vector::insert	stl_vector.h	/^  iterator insert(iterator position, const T& x) {$/;"	f	class:vector	access:public	signature:(iterator position, const T& x)
vector::insert	stl_vector.h	/^  void insert (iterator pos, int n, const T& x) {$/;"	f	class:vector	access:public	signature:(iterator pos, int n, const T& x)
vector::insert	stl_vector.h	/^  void insert (iterator pos, long n, const T& x) {$/;"	f	class:vector	access:public	signature:(iterator pos, long n, const T& x)
vector::insert	stl_vector.h	/^  void insert (iterator pos, size_type n, const T& x);$/;"	p	class:vector	access:public	signature:(iterator pos, size_type n, const T& x)
vector::insert	stl_vector.h	/^  void insert(iterator position, InputIterator first, InputIterator last) {$/;"	f	class:vector	access:public	signature:(iterator position, InputIterator first, InputIterator last)
vector::insert	stl_vector.h	/^  void insert(iterator position,$/;"	p	class:vector	access:public	signature:(iterator position, const_iterator first, const_iterator last)
vector::insert	stl_vector.h	/^void vector<T, Alloc>::insert(iterator position, $/;"	f	class:vector	signature:(iterator position, const_iterator first, const_iterator last)
vector::insert	stl_vector.h	/^void vector<T, Alloc>::insert(iterator position, size_type n, const T& x) {$/;"	f	class:vector	signature:(iterator position, size_type n, const T& x)
vector::insert_aux	stl_bvector.h	/^  void insert_aux(iterator position, bool x) {$/;"	f	class:vector	access:protected	signature:(iterator position, bool x)
vector::insert_aux	stl_vector.h	/^  void insert_aux(iterator position, const T& x);$/;"	p	class:vector	access:protected	signature:(iterator position, const T& x)
vector::insert_aux	stl_vector.h	/^void vector<T, Alloc>::insert_aux(iterator position, const T& x) {$/;"	f	class:vector	signature:(iterator position, const T& x)
vector::insert_range	stl_bvector.h	/^  void insert_range(iterator pos,$/;"	f	class:vector	access:protected	signature:(iterator pos, InputIterator first, InputIterator last, input_iterator_tag)
vector::insert_range	stl_bvector.h	/^  void insert_range(iterator position,$/;"	f	class:vector	access:protected	signature:(iterator position, ForwardIterator first, ForwardIterator last, forward_iterator_tag)
vector::iterator	stl_bvector.h	/^  typedef __bit_iterator                iterator;$/;"	t	class:vector	access:public
vector::iterator	stl_vector.h	/^  typedef value_type* iterator;$/;"	t	class:vector	access:public
vector::max_size	stl_bvector.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:vector	access:public	signature:() const
vector::max_size	stl_vector.h	/^  size_type max_size() const { return size_type(-1) \/ sizeof(T); }$/;"	f	class:vector	access:public	signature:() const
vector::operator =	stl_bvector.h	/^  __BVECTOR& operator=(const __BVECTOR& x) {$/;"	f	class:vector	access:public	signature:(const __BVECTOR& x)
vector::operator =	stl_vector.h	/^  vector<T, Alloc>& operator=(const vector<T, Alloc>& x);$/;"	p	class:vector	access:public	signature:(const vector<T, Alloc>& x)
vector::operator =	stl_vector.h	/^vector<T, Alloc>& vector<T, Alloc>::operator=(const vector<T, Alloc>& x) {$/;"	f	class:vector	signature:(const vector<T, Alloc>& x)
vector::operator []	stl_bvector.h	/^  const_reference operator[](size_type n) const {$/;"	f	class:vector	access:public	signature:(size_type n) const
vector::operator []	stl_bvector.h	/^  reference operator[](size_type n) {$/;"	f	class:vector	access:public	signature:(size_type n)
vector::operator []	stl_vector.h	/^  const_reference operator[](size_type n) const { return *(begin() + n); }$/;"	f	class:vector	access:public	signature:(size_type n) const
vector::operator []	stl_vector.h	/^  reference operator[](size_type n) { return *(begin() + n); }$/;"	f	class:vector	access:public	signature:(size_type n)
vector::pointer	stl_bvector.h	/^  typedef __bit_reference* pointer;$/;"	t	class:vector	access:public
vector::pointer	stl_vector.h	/^  typedef value_type* pointer;$/;"	t	class:vector	access:public
vector::pop_back	stl_bvector.h	/^  void pop_back() { --finish; }$/;"	f	class:vector	access:public	signature:()
vector::pop_back	stl_vector.h	/^  void pop_back() {$/;"	f	class:vector	access:public	signature:()
vector::push_back	stl_bvector.h	/^  void push_back(bool x) {$/;"	f	class:vector	access:public	signature:(bool x)
vector::push_back	stl_vector.h	/^  void push_back(const T& x) {$/;"	f	class:vector	access:public	signature:(const T& x)
vector::range_initialize	stl_vector.h	/^  void range_initialize(ForwardIterator first, ForwardIterator last,$/;"	f	class:vector	access:protected	signature:(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
vector::range_initialize	stl_vector.h	/^  void range_initialize(InputIterator first, InputIterator last,$/;"	f	class:vector	access:protected	signature:(InputIterator first, InputIterator last, input_iterator_tag)
vector::range_insert	stl_vector.h	/^  void range_insert(iterator pos,$/;"	p	class:vector	access:protected	signature:(iterator pos, ForwardIterator first, ForwardIterator last, forward_iterator_tag)
vector::range_insert	stl_vector.h	/^  void range_insert(iterator pos,$/;"	p	class:vector	access:protected	signature:(iterator pos, InputIterator first, InputIterator last, input_iterator_tag)
vector::range_insert	stl_vector.h	/^void vector<T, Alloc>::range_insert(iterator pos,$/;"	f	class:vector	signature:(iterator pos, InputIterator first, InputIterator last, input_iterator_tag)
vector::range_insert	stl_vector.h	/^void vector<T, Alloc>::range_insert(iterator position,$/;"	f	class:vector	signature:(iterator position, ForwardIterator first, ForwardIterator last, forward_iterator_tag)
vector::rbegin	stl_bvector.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:vector	access:public	signature:() const
vector::rbegin	stl_bvector.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:vector	access:public	signature:()
vector::rbegin	stl_vector.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:vector	access:public	signature:() const
vector::rbegin	stl_vector.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:vector	access:public	signature:()
vector::reference	stl_bvector.h	/^  typedef __bit_reference reference;$/;"	t	class:vector	access:public
vector::reference	stl_vector.h	/^  typedef value_type& reference;$/;"	t	class:vector	access:public
vector::rend	stl_bvector.h	/^  const_reverse_iterator rend() const { $/;"	f	class:vector	access:public	signature:() const
vector::rend	stl_bvector.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:vector	access:public	signature:()
vector::rend	stl_vector.h	/^  const_reverse_iterator rend() const { $/;"	f	class:vector	access:public	signature:() const
vector::rend	stl_vector.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:vector	access:public	signature:()
vector::reserve	stl_bvector.h	/^  void reserve(size_type n) {$/;"	f	class:vector	access:public	signature:(size_type n)
vector::reserve	stl_vector.h	/^  void reserve(size_type n) {$/;"	f	class:vector	access:public	signature:(size_type n)
vector::resize	stl_bvector.h	/^  void resize(size_type new_size, bool x = bool()) {$/;"	f	class:vector	access:public	signature:(size_type new_size, bool x = bool())
vector::resize	stl_vector.h	/^  void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:vector	access:public	signature:(size_type new_size)
vector::resize	stl_vector.h	/^  void resize(size_type new_size, const T& x) {$/;"	f	class:vector	access:public	signature:(size_type new_size, const T& x)
vector::reverse_iterator	stl_bvector.h	/^          reverse_iterator;$/;"	t	class:vector	access:public
vector::reverse_iterator	stl_bvector.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:vector	access:public
vector::reverse_iterator	stl_vector.h	/^          reverse_iterator;$/;"	t	class:vector	access:public
vector::reverse_iterator	stl_vector.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:vector	access:public
vector::size	stl_bvector.h	/^  size_type size() const { return size_type(end() - begin()); }$/;"	f	class:vector	access:public	signature:() const
vector::size	stl_vector.h	/^  size_type size() const { return size_type(end() - begin()); }$/;"	f	class:vector	access:public	signature:() const
vector::size_type	stl_bvector.h	/^  typedef size_t size_type;$/;"	t	class:vector	access:public
vector::size_type	stl_vector.h	/^  typedef size_t size_type;$/;"	t	class:vector	access:public
vector::start	stl_bvector.h	/^  iterator start;$/;"	m	class:vector	access:protected
vector::start	stl_vector.h	/^  iterator start;$/;"	m	class:vector	access:protected
vector::swap	stl_bvector.h	/^  void swap(__BVECTOR& x) {$/;"	f	class:vector	access:public	signature:(__BVECTOR& x)
vector::swap	stl_vector.h	/^  void swap(vector<T, Alloc>& x) {$/;"	f	class:vector	access:public	signature:(vector<T, Alloc>& x)
vector::value_type	stl_bvector.h	/^  typedef bool value_type;$/;"	t	class:vector	access:public
vector::value_type	stl_vector.h	/^  typedef T value_type;$/;"	t	class:vector	access:public
vector::vector	stl_vector.h	/^  explicit vector(size_type n) { fill_initialize(n, T()); }$/;"	f	class:vector	access:public	signature:(size_type n)
vector::vector	stl_vector.h	/^  vector() : start(0), finish(0), end_of_storage(0) {}$/;"	f	class:vector	access:public	signature:()
vector::vector	stl_vector.h	/^  vector(InputIterator first, InputIterator last) :$/;"	f	class:vector	access:public	signature:(InputIterator first, InputIterator last)
vector::vector	stl_vector.h	/^  vector(const vector<T, Alloc>& x) {$/;"	f	class:vector	access:public	signature:(const vector<T, Alloc>& x)
vector::vector	stl_vector.h	/^  vector(const_iterator first, const_iterator last) {$/;"	f	class:vector	access:public	signature:(const_iterator first, const_iterator last)
vector::vector	stl_vector.h	/^  vector(int n, const T& value) { fill_initialize(n, value); }$/;"	f	class:vector	access:public	signature:(int n, const T& value)
vector::vector	stl_vector.h	/^  vector(long n, const T& value) { fill_initialize(n, value); }$/;"	f	class:vector	access:public	signature:(long n, const T& value)
vector::vector	stl_vector.h	/^  vector(size_type n, const T& value) { fill_initialize(n, value); }$/;"	f	class:vector	access:public	signature:(size_type n, const T& value)
vector::~__BVECTOR	stl_bvector.h	/^  ~__BVECTOR() { deallocate(); }$/;"	f	class:vector	access:public	signature:()
vector::~vector	stl_vector.h	/^  ~vector() { $/;"	f	class:vector	access:public	signature:()
void_pointer	stl_list.h	/^  typedef void* void_pointer;$/;"	t	class:list	access:protected
void_pointer	stl_list.h	/^  typedef void* void_pointer;$/;"	t	struct:__list_node	access:public
void_pointer	stl_tree.h	/^  typedef void* void_pointer;$/;"	t	class:rb_tree	access:protected
write	stl_rope.h	/^	sequence_buffer& write(value_type *s, size_t len)$/;"	f	class:sequence_buffer	access:public	signature:(value_type *s, size_t len)
wrope	stl_rope.h	/^typedef rope<wchar_t, __ALLOC> wrope;$/;"	t
~__BVECTOR	stl_bvector.h	/^  ~__BVECTOR() { deallocate(); }$/;"	f	class:vector	access:public	signature:()
~__rope_RopeSubstring	stl_rope.h	/^    virtual ~__rope_RopeSubstring() {}$/;"	f	struct:__rope_RopeSubstring	access:public	signature:()
~__rope_char_consumer	stl_rope.h	/^	virtual ~__rope_char_consumer() {};$/;"	f	class:__rope_char_consumer	access:public	signature:()
~__rope_find_char_char_consumer	ropeimpl.h	/^	~__rope_find_char_char_consumer() {}$/;"	f	class:__rope_find_char_char_consumer	access:public	signature:()
~__rope_flatten_char_consumer	ropeimpl.h	/^	~__rope_flatten_char_consumer() {}$/;"	f	class:__rope_flatten_char_consumer	access:public	signature:()
~__rope_insert_char_consumer	ropeimpl.h	/^	~__rope_insert_char_consumer() { };$/;"	f	class:__rope_insert_char_consumer	access:public	signature:()
~__rope_iterator	stl_rope.h	/^    ~__rope_iterator() {$/;"	f	class:__rope_iterator	access:public	signature:()
~__rope_self_destruct_ptr	stl_rope.h	/^    ~__rope_self_destruct_ptr() { __rope_RopeBase<charT,Alloc>::unref(ptr); }$/;"	f	struct:__rope_self_destruct_ptr	access:public	signature:()
~char_producer	stl_rope.h	/^	virtual ~char_producer() {};$/;"	f	class:char_producer	access:public	signature:()
~deque	stl_deque.h	/^  ~deque() {$/;"	f	class:__deque_iterator::deque	access:public	signature:()
~hashtable	stl_hashtable.h	/^  ~hashtable() { clear(); }$/;"	f	class:hashtable	access:public	signature:()
~list	stl_list.h	/^  ~list() {$/;"	f	class:list	access:public	signature:()
~lock	stl_alloc.h	/^            ~lock() { __NODE_ALLOCATOR_UNLOCK; }$/;"	f	class:__default_alloc_template::lock	access:public	signature:()
~rb_tree	stl_tree.h	/^  ~rb_tree() {$/;"	f	class:rb_tree	access:public	signature:()
~rope	stl_rope.h	/^	~rope()$/;"	f	class:rope	access:public	signature:()
~sequence_buffer	stl_rope.h	/^	~sequence_buffer() { flush(); }$/;"	f	class:sequence_buffer	access:public	signature:()
~slist	stl_slist.h	/^  ~slist() { clear(); }$/;"	f	class:slist	access:public	signature:()
~temporary_buffer	stl_tempbuf.h	/^  ~temporary_buffer() {  $/;"	f	class:temporary_buffer	access:public	signature:()
~vector	stl_vector.h	/^  ~vector() { $/;"	f	class:vector	access:public	signature:()
